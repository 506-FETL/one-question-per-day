---
tags: [链式调用,任务队列,异步]
difficulty: medium
---

# LazyMan 懒惰的人

LazyMan除了吃就是睡，很lazy。

LazyMan(name: string, logFn: (log: string) => void) 通过传入logFn打印信息。

基本使用：

```js
LazyMan('Jack', console.log)
// Hi, I'm Jack.
```

可以eat(food: string)：

```js
LazyMan('Jack', console.log)
  .eat('banana')
  .eat('apple')
// Hi, I'm Jack.
// Eat banana.
// Eat apple.
```

可以sleep(time: number)，单位是秒：

```js
LazyMan('Jack', console.log)
  .eat('banana')
  .sleep(10)
  .eat('apple')
  .sleep(1)
// Hi, I'm Jack.
// Eat banana.
// Wake up after 10 seconds.
// Eat apple.
// Wake up after 1 second.
```

sleepFirst(time: number)的话，无论顺序如何，最优先sleep：

```js
LazyMan('Jack', console.log)
  .eat('banana')
  .sleepFirst(10)
  .eat('apple')
  .sleep(1)
// Wake up after 10 seconds.
// Hi, I'm Jack.
// Eat banana.
// Eat apple.
// Wake up after 1 second.
```

请创建一个如此懒惰的LazyMan()。

## 题目模版

::: code-group

```js [LazyMan.js]
/**
 * @param {string} name
 * @param {(log: string) => void} logFn
 */
export default function LazyMan(name, logFn) {

}
```

```ts [LazyMan.ts]
export default function LazyMan(name: string, logFn: (log: string) => void) {

}
```

:::

## 测试代码

::: code-group

```js [LazyMan.spec.js]
import { describe, expect, it, vi } from 'vitest'
import LazyMan from './LazyMan'

describe('day20-LazyMan', () => {
  it('应该支持基本的链式调用', async () => {
    const mockLog = vi.fn()

    LazyMan('Jack', mockLog)

    // 等待异步执行完成
    await new Promise(resolve => setTimeout(resolve, 0))

    expect(mockLog).toHaveBeenCalledTimes(1)
    expect(mockLog).toHaveBeenCalledWith('Hi, I\'m Jack.')
  })

  it('应该支持 eat 方法', async () => {
    const mockLog = vi.fn()

    LazyMan('Jack', mockLog)
      .eat('banana')
      .eat('apple')

    // 等待异步执行完成
    await new Promise(resolve => setTimeout(resolve, 0))

    expect(mockLog).toHaveBeenCalledTimes(3)
    expect(mockLog).toHaveBeenNthCalledWith(1, 'Hi, I\'m Jack.')
    expect(mockLog).toHaveBeenNthCalledWith(2, 'Eat banana.')
    expect(mockLog).toHaveBeenNthCalledWith(3, 'Eat apple.')
  })

  it('应该支持 sleep 方法', async () => {
    const mockLog = vi.fn()

    const startTime = Date.now()
    LazyMan('Jack', mockLog)
      .eat('banana')
      .sleep(1)
      .eat('apple')

    // 等待异步执行完成
    await new Promise(resolve => setTimeout(resolve, 1100))

    const endTime = Date.now()
    const duration = endTime - startTime

    expect(duration).toBeGreaterThanOrEqual(1000)
    expect(mockLog).toHaveBeenCalledTimes(4)
    expect(mockLog).toHaveBeenNthCalledWith(1, 'Hi, I\'m Jack.')
    expect(mockLog).toHaveBeenNthCalledWith(2, 'Eat banana.')
    expect(mockLog).toHaveBeenNthCalledWith(3, 'Wake up after 1 seconds.')
    expect(mockLog).toHaveBeenNthCalledWith(4, 'Eat apple.')
  })

  it('应该支持 sleepFirst 优先执行', async () => {
    const mockLog = vi.fn()

    LazyMan('Jack', mockLog)
      .eat('banana')
      .sleepFirst(1)
      .eat('apple')
      .sleep(1)

    // 等待异步执行完成
    await new Promise(resolve => setTimeout(resolve, 2100))

    expect(mockLog).toHaveBeenCalledTimes(5)
    expect(mockLog).toHaveBeenNthCalledWith(1, 'Wake up after 1 seconds.')
    expect(mockLog).toHaveBeenNthCalledWith(2, 'Hi, I\'m Jack.')
    expect(mockLog).toHaveBeenNthCalledWith(3, 'Eat banana.')
    expect(mockLog).toHaveBeenNthCalledWith(4, 'Eat apple.')
    expect(mockLog).toHaveBeenNthCalledWith(5, 'Wake up after 1 seconds.')
  })
})
```

```ts [LazyMan.spec.ts]
import { describe, expect, it, vi } from 'vitest'
import LazyMan from './LazyMan'

describe('day20-LazyMan', () => {
  it('应该支持基本的链式调用', async () => {
    const mockLog = vi.fn()

    LazyMan('Jack', mockLog)

    // 等待异步执行完成
    await new Promise(resolve => setTimeout(resolve, 0))

    expect(mockLog).toHaveBeenCalledTimes(1)
    expect(mockLog).toHaveBeenCalledWith('Hi, I\'m Jack.')
  })

  it('应该支持 eat 方法', async () => {
    const mockLog = vi.fn()

    LazyMan('Jack', mockLog)
      .eat('banana')
      .eat('apple')

    // 等待异步执行完成
    await new Promise(resolve => setTimeout(resolve, 0))

    expect(mockLog).toHaveBeenCalledTimes(3)
    expect(mockLog).toHaveBeenNthCalledWith(1, 'Hi, I\'m Jack.')
    expect(mockLog).toHaveBeenNthCalledWith(2, 'Eat banana.')
    expect(mockLog).toHaveBeenNthCalledWith(3, 'Eat apple.')
  })

  it('应该支持 sleep 方法', async () => {
    const mockLog = vi.fn()

    const startTime = Date.now()
    LazyMan('Jack', mockLog)
      .eat('banana')
      .sleep(1)
      .eat('apple')

    // 等待异步执行完成
    await new Promise(resolve => setTimeout(resolve, 1100))

    const endTime = Date.now()
    const duration = endTime - startTime

    expect(duration).toBeGreaterThanOrEqual(1000)
    expect(mockLog).toHaveBeenCalledTimes(4)
    expect(mockLog).toHaveBeenNthCalledWith(1, 'Hi, I\'m Jack.')
    expect(mockLog).toHaveBeenNthCalledWith(2, 'Eat banana.')
    expect(mockLog).toHaveBeenNthCalledWith(3, 'Wake up after 1 seconds.')
    expect(mockLog).toHaveBeenNthCalledWith(4, 'Eat apple.')
  })

  it('应该支持 sleepFirst 优先执行', async () => {
    const mockLog = vi.fn()

    LazyMan('Jack', mockLog)
      .eat('banana')
      .sleepFirst(1)
      .eat('apple')
      .sleep(1)

    // 等待异步执行完成
    await new Promise(resolve => setTimeout(resolve, 2100))

    expect(mockLog).toHaveBeenCalledTimes(5)
    expect(mockLog).toHaveBeenNthCalledWith(1, 'Wake up after 1 seconds.')
    expect(mockLog).toHaveBeenNthCalledWith(2, 'Hi, I\'m Jack.')
    expect(mockLog).toHaveBeenNthCalledWith(3, 'Eat banana.')
    expect(mockLog).toHaveBeenNthCalledWith(4, 'Eat apple.')
    expect(mockLog).toHaveBeenNthCalledWith(5, 'Wake up after 1 seconds.')
  })
})
```

:::

## 答案

| 类型    | 路径                                                                                                                              |
| ------- | --------------------------------------------------------------------------------------------------------------------------------- |
| JS 版本 | [problems/Day 20/answer.js](https://github.com/506-FETL/one-question-per-day/blob/main/packages/problems/base/Day%2020/answer.js) |
| TS 版本 | 待补充                                                                                                                            |
| Review  | 待补充                                                                                                                            |
