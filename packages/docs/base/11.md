---
tags: [Fiber,æ·±åº¦éå†]
difficulty: medium
---

# Fiber æ ‘éå†ï¼ˆæäº¤é˜¶æ®µå‰¯ä½œç”¨æ”¶é›†æ¨¡æ‹Ÿï¼‰

## ğŸ§  èƒŒæ™¯

åœ¨ç±» React æ¶æ„ä¸­ï¼ŒUI æ›´æ–°ä¼šç»å† _render_ï¼ˆç”Ÿæˆ Fiber æ ‘ï¼‰ä¸ _commit_ï¼ˆåº”ç”¨å‰¯ä½œç”¨ï¼‰ä¸¤ä¸ªé˜¶æ®µã€‚Fiber é‡‡ç”¨ä¸€å¥—**é“¾å¼æŒ‡é’ˆç»“æ„**æ¥è¡¨ç¤ºä¸€æ£µæ ‘ï¼š

| æŒ‡é’ˆ      | å«ä¹‰                                       |
| --------- | ------------------------------------------ |
| `child`   | ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹ï¼ˆç›¸å½“äºæ™®é€šæ ‘çš„ children[0]ï¼‰ |
| `sibling` | ä¸‹ä¸€ä¸ªå…„å¼ŸèŠ‚ç‚¹ï¼ˆç›¸å½“äºåŒå±‚çš„ä¸‹ä¸€ä¸ªï¼‰       |
| `return`  | æŒ‡å‘çˆ¶èŠ‚ç‚¹ï¼ˆå›æº¯ç”¨ï¼‰                       |

æœ¬é¢˜èšç„¦äº **â€œä»æ ¹å¼€å§‹ï¼ŒæŒ‰ç…§å…ˆåºï¼ˆçˆ¶ â†’ å­ â†’ å…„å¼Ÿï¼‰æ·±åº¦ä¼˜å…ˆâ€** éå†æ•´æ£µ Fiber æ ‘ï¼Œå¹¶å¯¹æ¯ä¸ªèŠ‚ç‚¹è°ƒç”¨ä¸€æ¬¡å›è°ƒ `onCommitUnmount(node)`ï¼ˆé¢˜æ„ä»¥ _unmount_ å‘½åï¼Œå®è´¨ä¸Šåªæ˜¯ä¸€æ¬¡å‰¯ä½œç”¨å¤„ç†çš„æ¨¡æ‹Ÿï¼‰ã€‚

## ğŸ¯ ä»»åŠ¡

å®ç°å‡½æ•°ï¼š

::: code-group

```js{2} [commitNestedComponent.js]
export function commitNestedComponent(root, onCommitUnmount) {
  // TODO å¯¹æ¯ä¸€ä¸ªnode(åŒ…å«root)æ‰§è¡ŒonCommitUnmount(node)
}
```

```ts [commitNestedComponent.ts]
import type { FiberNode } from './types'

/**
 * æ·±åº¦ä¼˜å…ˆéå† (DFS) å½“å‰ fiber å­æ ‘ï¼Œå¯¹æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œ onCommitUnmount å›è°ƒã€‚
 * éå†é¡ºåºï¼šå…ˆè®¿é—®èŠ‚ç‚¹æœ¬èº«ï¼Œå†è¿›å…¥å…¶ childï¼Œchild èµ°åˆ°åº•åå›æº¯æ‰¾ siblingã€‚
 * ä¸ React å†…éƒ¨ commitUnmount é€»è¾‘ç±»ä¼¼çš„éª¨æ¶ï¼šç”¨äºåœ¨å¸è½½é˜¶æ®µè°ƒç”¨æ¸…ç†å‰¯ä½œç”¨ã€‚
 *
 * @param root æ ¹èŠ‚ç‚¹ï¼ˆéå†åœæ­¢è¾¹ç•Œï¼‰
 * @param onCommitUnmount å¯¹æ¯ä¸ªéå†åˆ°çš„èŠ‚ç‚¹è°ƒç”¨çš„å›è°ƒ
 */
export function commitNestedComponent(
  root: FiberNode,
  onCommitUnmount: (node: FiberNode) => void,
): void {}
```

```ts [types.ts]
export interface FiberNode {
  child: FiberNode | null
  sibling: FiberNode | null
  return: FiberNode | null
  [key: string]: any
}
```

:::

è¦æ±‚ï¼š

1. è‹¥ `root` ä¸º `null`ï¼Œç›´æ¥è¿”å›ã€‚
2. å¯¹**æ¯ä¸€ä¸ªèŠ‚ç‚¹æ°å¥½è°ƒç”¨ä¸€æ¬¡** `onCommitUnmount`ï¼ŒåŒ…å«æ ¹èŠ‚ç‚¹ã€‚
3. éå†é¡ºåºï¼š
   - å…ˆè®¿é—®å½“å‰èŠ‚ç‚¹
   - ä¼˜å…ˆè¿›å…¥ `child` é“¾
   - æ²¡æœ‰å­èŠ‚ç‚¹åˆ™å°è¯• `sibling`
   - è‹¥ä¹Ÿæ²¡æœ‰ï¼Œåˆ™ä¸æ–­æ²¿ `return` å›æº¯ï¼Œç›´åˆ°æ‰¾åˆ°æŸä¸ªç¥–å…ˆçš„æœªè®¿é—®å…„å¼Ÿï¼›è‹¥æ²¡æœ‰åˆ™ç»“æŸã€‚
4. æœŸæœ›ç”¨**è¿­ä»£**å®ç°ï¼ˆå¯é€‰ï¼‰ï¼Œé¿å…é€’å½’æ ˆï¼ˆå¯ç”¨é€’å½’ä½†è¦åœ¨è¯´æ˜ä¸­å†™å‡ºå¤æ‚åº¦ï¼‰ã€‚

## ğŸ§© FiberNode ç»“æ„ï¼ˆæµ‹è¯•ä¸­ç¤ºä¾‹ï¼‰

ï¼ˆæµ‹è¯•æ–‡ä»¶é‡Œä¼šåŠ¨æ€æ„å»ºæ ‘ï¼Œä½ æ— éœ€æ”¹åŠ¨æµ‹è¯•é‡Œçš„ç±»å®šä¹‰ï¼›ä¸‹é¢æ˜¯ç®€åŒ–ç¤ºæ„ï¼‰

```ts
class FiberNode {
  key: string
  child: FiberNode | null = null
  sibling: FiberNode | null = null
  return: FiberNode | null = null
  constructor(key: string) { this.key = key }
  // æµ‹è¯•é‡Œæä¾›äº† addChild è¾…åŠ©æ–¹æ³•
}
```

## ğŸ” ç¤ºä¾‹

æ ‘å½¢ï¼ˆå…„å¼Ÿä»å·¦åˆ°å³æ·»åŠ ï¼‰ï¼š

```
       A
     / | \
    B  C  D
   /      /\
  E      F  G
```

æŒ‡é’ˆå…³ç³»ï¼ˆéƒ¨åˆ†ï¼‰ï¼š

```
A.child = B
B.sibling = C
C.sibling = D
B.child = E
D.child = F
F.sibling = G
```

æœŸæœ›éå†é¡ºåºï¼ˆå…ˆåº + å…„å¼Ÿæ¨ªå‘ï¼‰ï¼š

```
A â†’ B â†’ E â†’ C â†’ D â†’ F â†’ G
```

## ğŸ›  æ€è·¯æç¤ºï¼ˆè¿­ä»£ç‰ˆï¼‰

```ts
let current: FiberNode | null = root
while (current) {
  onCommitUnmount(current)

  if (current.child) { // 1. å…ˆæ·±å…¥å­èŠ‚ç‚¹
    current = current.child
    continue
  }

  // 2. æ²¡å­èŠ‚ç‚¹ï¼Œå¯»æ‰¾åŒå±‚å…„å¼Ÿæˆ–å‘ä¸Šå›æº¯
  while (current && !current.sibling) {
    current = current.return // å›æº¯
  }
  if (current)
    current = current.sibling // å…„å¼Ÿç»§ç»­
}
```

## â± å¤æ‚åº¦

| å®ç° | æ—¶é—´ | é¢å¤–ç©ºé—´           |
| ---- | ---- | ------------------ |
| è¿­ä»£ | O(N) | O(1)               |
| é€’å½’ | O(N) | O(H)ï¼ˆH ä¸ºæ ‘é«˜åº¦ï¼‰ |

## âœ… åˆ¤å®šæ ‡å‡†

é€šè¿‡æµ‹è¯•éœ€æ»¡è¶³ï¼š

1. é¡ºåºæ­£ç¡®ï¼ˆä¸é¢˜ç›® DFS å…ˆåº + å…„å¼Ÿå·¦â†’å³ä¸€è‡´ï¼‰
2. ä¸é‡å¤ã€ä¸é—æ¼èŠ‚ç‚¹
3. ç©ºæ ‘èƒ½å®‰å…¨è¿”å›

## ğŸ”„ å¯æ‰©å±•æ€è€ƒ

çœŸå® React æäº¤é˜¶æ®µè¿˜ä¼šï¼š

- å¤„ç†ä¸åŒ effect æ ‡å¿—ï¼ˆPlacement / Update / Deletion ç­‰ï¼‰
- åˆ†ç¦»â€œæŒ‚è½½å‰¯ä½œç”¨â€å’Œâ€œå¸è½½å‰¯ä½œç”¨â€é˜¶æ®µ
  ä½ å¯ä»¥åœ¨èŠ‚ç‚¹ä¸ŠåŠ ä¸€ä¸ª `flags` å­—æ®µï¼Œåœ¨éå†æ—¶åˆ†ç±»å¤„ç†ã€‚

## ğŸ§ª å»ºè®®è‡ªæµ‹ç”¨ä¾‹

1. å•èŠ‚ç‚¹
2. åªæœ‰ä¸€æ¡å‘å·¦/å‘å³çš„é“¾
3. å¤šå…„å¼Ÿ + éƒ¨åˆ†å…„å¼Ÿæœ‰å­
4. ä¸è§„åˆ™â€œç˜¸è…¿â€ç»“æ„ï¼ˆæœ‰çš„èŠ‚ç‚¹åªæœ‰ç¬¬äºŒä¸ª/ç¬¬ä¸‰ä¸ªå­™ï¼‰

ç°åœ¨ï¼Œåœ¨ `fiberTree.js` ä¸­è¡¥å…¨ `commitNestedComponent` çš„å®ç°å³å¯ã€‚

## æµ‹è¯•ä»£ç 

:::code-group

```js [fiberTree.spec.js]
import { beforeEach, describe, expect, it } from 'vitest'
import { commitNestedComponent } from './fiberTree.js'

// The arr array is module-level in answer.js, we need to access it
// Since it's not exported, we'll reset it indirectly before each test
// by importing the module fresh each time or by manipulating it directly
export class FiberNode {
  constructor(key) {
    // èŠ‚ç‚¹æ ‡è¯†
    this.key = key

    // Fiber æ ‘ç»“æ„å¿…è¦å±æ€§
    this.child = null // ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹
    this.sibling = null // ä¸‹ä¸€ä¸ªå…„å¼ŸèŠ‚ç‚¹
    this.return = null // çˆ¶èŠ‚ç‚¹å¼•ç”¨
  }

  // æ·»åŠ å­èŠ‚ç‚¹
  addChild(childNode) {
    if (!childNode)
      return this

    childNode.return = this

    if (!this.child) {
      // å¦‚æœæ²¡æœ‰å­èŠ‚ç‚¹ï¼Œç›´æ¥æ·»åŠ 
      this.child = childNode
    }
    else {
      // å¦‚æœå·²æœ‰å­èŠ‚ç‚¹ï¼Œæ·»åŠ ä¸ºæœ€åä¸€ä¸ªå…„å¼Ÿ
      let lastChild = this.child
      while (lastChild.sibling) {
        lastChild = lastChild.sibling
      }
      lastChild.sibling = childNode
    }

    return childNode
  }
}

describe('day 11 - Fiber Tree Traversal', () => {
  // Reset the global arr before each test
  beforeEach(() => {
    // Since arr is not exported, we'll create a new fiber tree and check
    // if the traversal result matches our expectations
    const arr = []
    function cbFunc(node) {
      arr.push(node.key)
    }
    const testFiber = new FiberNode('reset')
    commitNestedComponent(testFiber, cbFunc)

    // This will run the traversal and set arr to ['reset']
    // We can verify this to ensure we're starting with a clean state
  })

  it('should traverse a single node tree correctly', () => {
    const root = new FiberNode('root')
    // Import the module again to access the updated arr
    // This is a workaround since arr is not directly exported
    const resultKeys = getTraversalResult(root)
    expect(resultKeys).toEqual(['root'])
  })

  it('should traverse a simple tree in DFS order', () => {
    const root = new FiberNode('A')
    const child1 = new FiberNode('B')
    const child2 = new FiberNode('C')

    root.addChild(child1)
    root.addChild(child2)

    const resultKeys = getTraversalResult(root)
    expect(resultKeys).toEqual(['A', 'B', 'C'])
  })

  it('should traverse a complex tree in correct DFS order', () => {
    // Create tree:
    //       A
    //     / | \
    //    B  C  D
    //   /      /\
    //  E      F  G

    const nodeA = new FiberNode('A')
    const nodeB = new FiberNode('B')
    const nodeC = new FiberNode('C')
    const nodeD = new FiberNode('D')
    const nodeE = new FiberNode('E')
    const nodeF = new FiberNode('F')
    const nodeG = new FiberNode('G')

    nodeA.addChild(nodeB)
    nodeA.addChild(nodeC)
    nodeA.addChild(nodeD)
    nodeB.addChild(nodeE)
    nodeD.addChild(nodeF)
    nodeD.addChild(nodeG)

    const resultKeys = getTraversalResult(nodeA)
    expect(resultKeys).toEqual(['A', 'B', 'E', 'C', 'D', 'F', 'G'])
  })

  it('should handle a deeply nested tree correctly', () => {
    // Create a deep path: A -> B -> C -> D -> E
    const nodeA = new FiberNode('A')
    const nodeB = new FiberNode('B')
    const nodeC = new FiberNode('C')
    const nodeD = new FiberNode('D')
    const nodeE = new FiberNode('E')

    nodeA.addChild(nodeB)
    nodeB.addChild(nodeC)
    nodeC.addChild(nodeD)
    nodeD.addChild(nodeE)

    const resultKeys = getTraversalResult(nodeA)
    expect(resultKeys).toEqual(['A', 'B', 'C', 'D', 'E'])
  })

  it('should handle complex sibling relationships', () => {
    // Create tree:
    //     A
    //    /|\
    //   B C D
    //      /|\
    //     E F G
    const nodeA = new FiberNode('A')
    const nodeB = new FiberNode('B')
    const nodeC = new FiberNode('C')
    const nodeD = new FiberNode('D')
    const nodeE = new FiberNode('E')
    const nodeF = new FiberNode('F')
    const nodeG = new FiberNode('G')

    nodeA.addChild(nodeB)
    nodeA.addChild(nodeC)
    nodeA.addChild(nodeD)
    nodeD.addChild(nodeE)
    nodeD.addChild(nodeF)
    nodeD.addChild(nodeG)

    const resultKeys = getTraversalResult(nodeA)
    expect(resultKeys).toEqual(['A', 'B', 'C', 'D', 'E', 'F', 'G'])
  })
})

// Helper function to get traversal result
function getTraversalResult(root) {
  // We need to clear any previous results and run a new traversal
  // Create a dummy node first to reset the array
  const arr = []
  function cbFunc(node) {
    arr.push(node.key)
  }
  // Now run the actual test traversal
  commitNestedComponent(root, cbFunc)
  return arr
}
```

```ts [fiberTree.spec.ts]
import type { FiberNode } from './types'
import { beforeEach, describe, expect, it } from 'vitest'
import { commitNestedComponent } from './fiberTree'

class TestFiberNode implements FiberNode {
  key: string
  child: FiberNode | null = null
  sibling: FiberNode | null = null
  return: FiberNode | null = null
  constructor(key: string) {
    this.key = key
  }

  // æ·»åŠ å­èŠ‚ç‚¹ï¼ˆè¿”å›æ–°æ·»åŠ çš„å­èŠ‚ç‚¹ä¾¿äºé“¾å¼æ„å»ºï¼‰
  addChild<T extends FiberNode>(childNode: T | null | undefined): T | this {
    if (!childNode)
      return this
    childNode.return = this
    if (!this.child) {
      this.child = childNode
    }
    else {
      let lastChild = this.child
      while (lastChild.sibling) lastChild = lastChild.sibling
      lastChild.sibling = childNode
    }
    return childNode
  }
}

describe('day 11 - Fiber Tree Traversal', () => {
  // Reset the global arr before each test
  beforeEach(() => {
    // Since arr is not exported, we'll create a new fiber tree and check
    // if the traversal result matches our expectations
    const arr: string[] = []
    function cbFunc(node: FiberNode) {
      arr.push(node.key)
    }
    const testFiber = new TestFiberNode('reset')
    commitNestedComponent(testFiber, cbFunc)

    // This will run the traversal and set arr to ['reset']
    // We can verify this to ensure we're starting with a clean state
  })

  it('should traverse a single node tree correctly', () => {
    const root = new TestFiberNode('root')
    // Import the module again to access the updated arr
    // This is a workaround since arr is not directly exported
    const resultKeys = getTraversalResult(root)
    expect(resultKeys).toEqual(['root'])
  })

  it('should traverse a simple tree in DFS order', () => {
    const root = new TestFiberNode('A')
    const child1 = new TestFiberNode('B')
    const child2 = new TestFiberNode('C')

    root.addChild(child1)
    root.addChild(child2)

    const resultKeys = getTraversalResult(root)
    expect(resultKeys).toEqual(['A', 'B', 'C'])
  })

  it('should traverse a complex tree in correct DFS order', () => {
    // Create tree:
    //       A
    //     / | \
    //    B  C  D
    //   /      /\
    //  E      F  G

    const nodeA = new TestFiberNode('A')
    const nodeB = new TestFiberNode('B')
    const nodeC = new TestFiberNode('C')
    const nodeD = new TestFiberNode('D')
    const nodeE = new TestFiberNode('E')
    const nodeF = new TestFiberNode('F')
    const nodeG = new TestFiberNode('G')

    nodeA.addChild(nodeB)
    nodeA.addChild(nodeC)
    nodeA.addChild(nodeD)
    nodeB.addChild(nodeE)
    nodeD.addChild(nodeF)
    nodeD.addChild(nodeG)

    const resultKeys = getTraversalResult(nodeA)
    expect(resultKeys).toEqual(['A', 'B', 'E', 'C', 'D', 'F', 'G'])
  })

  it('should handle a deeply nested tree correctly', () => {
    // Create a deep path: A -> B -> C -> D -> E
    const nodeA = new TestFiberNode('A')
    const nodeB = new TestFiberNode('B')
    const nodeC = new TestFiberNode('C')
    const nodeD = new TestFiberNode('D')
    const nodeE = new TestFiberNode('E')

    nodeA.addChild(nodeB)
    nodeB.addChild(nodeC)
    nodeC.addChild(nodeD)
    nodeD.addChild(nodeE)

    const resultKeys = getTraversalResult(nodeA)
    expect(resultKeys).toEqual(['A', 'B', 'C', 'D', 'E'])
  })

  it('should handle complex sibling relationships', () => {
    // Create tree:
    //     A
    //    /|\
    //   B C D
    //      /|\
    //     E F G
    const nodeA = new TestFiberNode('A')
    const nodeB = new TestFiberNode('B')
    const nodeC = new TestFiberNode('C')
    const nodeD = new TestFiberNode('D')
    const nodeE = new TestFiberNode('E')
    const nodeF = new TestFiberNode('F')
    const nodeG = new TestFiberNode('G')

    nodeA.addChild(nodeB)
    nodeA.addChild(nodeC)
    nodeA.addChild(nodeD)
    nodeD.addChild(nodeE)
    nodeD.addChild(nodeF)
    nodeD.addChild(nodeG)

    const resultKeys = getTraversalResult(nodeA)
    expect(resultKeys).toEqual(['A', 'B', 'C', 'D', 'E', 'F', 'G'])
  })
})

// Helper function to get traversal result
function getTraversalResult(root: FiberNode): string[] {
  // We need to clear any previous results and run a new traversal
  // Create a dummy node first to reset the array
  const arr: string[] = []
  function cbFunc(node: FiberNode) {
    arr.push(node.key)
  }
  // Now run the actual test traversal
  commitNestedComponent(root, cbFunc)
  return arr
}
```

:::

## ç­”æ¡ˆ

| ç±»å‹    | è·¯å¾„                                                                                                                                    |
| ------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| JS ç‰ˆæœ¬ | [problems/Day 11/answer.js](https://github.com/506-FETL/one-question-per-day/blob/main/packages/problems/base/Day%2011/answer.js)       |
| TS ç‰ˆæœ¬ | [problems/Day 11/ts/answer.ts](https://github.com/506-FETL/one-question-per-day/blob/main/packages/problems/base/Day%2011/ts/answer.ts) |
| Review  | [11.md](/review/11)                                                                                                                     |
