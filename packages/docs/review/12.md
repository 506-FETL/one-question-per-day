# Day 12 复习文档

## 题目描述

实现一个 **compose 函数**，用于函数组合：

- 将一系列函数像管道一样连接起来
- 支持同步和异步函数的混合组合
- 数据从第一个函数流向最后一个函数
- 实现函数式编程中的核心概念

本题考查 **函数式编程**、**异步编程** 和 **高阶函数** 的综合应用。

## 核心知识点

### 1. 函数组合的核心概念

```javascript
// 函数组合的基本思想
const add = (x) => x + 1;
const multiply = (x) => x * 2;
const square = (x) => x * x;

// 传统写法
const result = square(multiply(add(5))); // ((5+1)*2)² = 144

// compose 写法
const composed = compose([add, multiply, square]);
const result = composed(5); // 144
```

### 2. 执行顺序（从左到右）

```javascript
// compose([f, g, h]) 执行顺序：
// input → f(input) → g(f(input)) → h(g(f(input))) → output

// 这与数学中的函数组合 h∘g∘f 相反
// 但更符合直觉的数据流动方向
```

### 3. 同步与异步兼容

```javascript
// 同步函数
const syncFn = (x) => x * 2;

// 异步函数
const asyncFn = (x) => Promise.resolve(x + 1);

// 混合使用
const mixed = compose([syncFn, asyncFn, syncFn]);
// 自动处理同步/异步的差异
```

### 4. Promise 链式处理

```javascript
// 核心原理：将所有函数返回值用 Promise.resolve 包装
// 确保 .then() 方法始终可用
return fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(input));
```

## 代码实现

```javascript
/**
 * 基础版本：支持同步和异步函数组合
 * 时间复杂度：O(n)，空间复杂度：O(1)
 */
export default function compose(fns) {
  // 边界情况：空数组
  if (fns.length === 0) {
    return (x) => x;
  }

  // 边界情况：单个函数
  if (fns.length === 1) {
    return fns[0];
  }

  return function (...args) {
    // 第一个函数可以接收多个参数
    const firstFn = fns[0];
    const restFns = fns.slice(1);

    // 执行第一个函数
    const initialResult = firstFn(...args);

    // 使用 reduce 依次执行剩余函数
    return restFns.reduce((promise, currentFn) => {
      return promise.then((result) => {
        // 确保返回值被 Promise 包装
        const fnResult = currentFn(result);
        return Promise.resolve(fnResult);
      });
    }, Promise.resolve(initialResult));
  };
}

/**
 * 增强版本：支持错误处理和类型检查
 */
function composeAdvanced(fns) {
  // 参数验证
  if (!Array.isArray(fns)) {
    throw new TypeError("compose expects an array of functions");
  }

  // 检查所有元素都是函数
  for (let i = 0; i < fns.length; i++) {
    if (typeof fns[i] !== "function") {
      throw new TypeError(`Element at index ${i} is not a function`);
    }
  }

  if (fns.length === 0) {
    return (x) => Promise.resolve(x);
  }

  if (fns.length === 1) {
    return (...args) => Promise.resolve(fns[0](...args));
  }

  return function (...args) {
    const [firstFn, ...restFns] = fns;

    try {
      const initialResult = firstFn(...args);

      return restFns.reduce((promise, currentFn) => {
        return promise.then((result) => {
          try {
            const fnResult = currentFn(result);
            return Promise.resolve(fnResult);
          } catch (error) {
            return Promise.reject(error);
          }
        });
      }, Promise.resolve(initialResult));
    } catch (error) {
      return Promise.reject(error);
    }
  };
}

/**
 * 右到左组合版本（传统数学函数组合）
 */
function composeRight(fns) {
  if (fns.length === 0) return (x) => x;
  if (fns.length === 1) return fns[0];

  return function (...args) {
    // 从右到左执行：最后一个函数先执行
    const lastFn = fns[fns.length - 1];
    const restFns = fns.slice(0, -1).reverse();

    const initialResult = lastFn(...args);

    return restFns.reduce(
      (promise, currentFn) => promise.then(currentFn),
      Promise.resolve(initialResult),
    );
  };
}

/**
 * 支持管道操作符的版本
 */
function pipe(fns) {
  // pipe 是 compose 的别名，但更直观地表示从左到右
  return compose(fns);
}

/**
 * 支持中间件模式的组合
 */
function composeMiddleware(middlewares) {
  return function (context, next) {
    let index = -1;

    function dispatch(i) {
      if (i <= index) {
        return Promise.reject(new Error("next() called multiple times"));
      }

      index = i;
      let fn = middlewares[i];

      if (i === middlewares.length) {
        fn = next;
      }

      if (!fn) {
        return Promise.resolve();
      }

      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err);
      }
    }

    return dispatch(0);
  };
}

/**
 * 支持并行执行的组合
 */
function composeParallel(fns) {
  return function (...args) {
    const results = fns.map((fn) => {
      try {
        return Promise.resolve(fn(...args));
      } catch (error) {
        return Promise.reject(error);
      }
    });

    return Promise.all(results);
  };
}

/**
 * 支持条件执行的组合
 */
function composeConditional(conditions, fns) {
  if (conditions.length !== fns.length) {
    throw new Error(
      "conditions and functions arrays must have the same length",
    );
  }

  return function (...args) {
    let result = Promise.resolve(args[0]);

    for (let i = 0; i < fns.length; i++) {
      result = result.then((value) => {
        const shouldExecute = conditions[i](value);
        return shouldExecute ? fns[i](value) : value;
      });
    }

    return result;
  };
}

/**
 * 支持重试机制的组合
 */
function composeWithRetry(fns, maxRetries = 3) {
  return function (...args) {
    const executeWithRetry = (fn, value, retries = 0) => {
      return Promise.resolve(fn(value)).catch((error) => {
        if (retries < maxRetries) {
          console.log(
            `Retrying function (attempt ${retries + 1}/${maxRetries})`,
          );
          return executeWithRetry(fn, value, retries + 1);
        }
        throw error;
      });
    };

    const [firstFn, ...restFns] = fns;
    let result = Promise.resolve(firstFn(...args));

    for (const fn of restFns) {
      result = result.then((value) => executeWithRetry(fn, value));
    }

    return result;
  };
}

/**
 * 支持性能监控的组合
 */
function composeWithTiming(fns, onTiming) {
  return function (...args) {
    const timings = [];
    const [firstFn, ...restFns] = fns;

    const executeWithTiming = (fn, value, index) => {
      const start = performance.now();

      return Promise.resolve(fn(value)).then((result) => {
        const end = performance.now();
        const timing = {
          functionIndex: index,
          duration: end - start,
          functionName: fn.name || `anonymous_${index}`,
        };

        timings.push(timing);

        if (onTiming) {
          onTiming(timing);
        }

        return result;
      });
    };

    const start = performance.now();
    let result = executeWithTiming(firstFn, args[0], 0);

    restFns.forEach((fn, index) => {
      result = result.then((value) => executeWithTiming(fn, value, index + 1));
    });

    return result.then((finalResult) => {
      const totalTime = performance.now() - start;

      if (onTiming) {
        onTiming({
          type: "total",
          duration: totalTime,
          individualTimings: timings,
        });
      }

      return finalResult;
    });
  };
}
```

## 算法分析

- **时间复杂度**: O(n) - n 为函数数量，每个函数执行一次
- **空间复杂度**: O(1) - 只使用常量额外空间（Promise 链）
- **特点**: 异步友好、链式执行、错误传播

## 关键技术点

### 1. Promise.resolve 的妙用

```javascript
// 统一处理同步和异步返回值
const result = fn(value);
return Promise.resolve(result); // 同步值包装成 Promise

// 这样后续都可以使用 .then() 方法
```

### 2. reduce 实现链式调用

```javascript
// 核心模式：accumulator 是 Promise，currentValue 是函数
return fns.reduce(
  (promise, fn) => promise.then(fn),
  Promise.resolve(initialValue),
);
```

### 3. 首个函数的特殊处理

```javascript
// 第一个函数可以接收多个参数
const [firstFn, ...restFns] = fns;
const initialResult = firstFn(...args); // 多参数

// 后续函数只接收一个参数（上一个函数的返回值）
restFns.forEach((fn) => (result = result.then(fn)));
```

### 4. 错误处理和传播

```javascript
// Promise 链自动传播错误
promise.then(fn).catch((error) => {
  // 任何环节的错误都会被捕获
  console.error("Function composition error:", error);
  throw error; // 继续传播
});
```

### 5. 常见陷阱和坑点

- **参数传递**: 第一个函数需要多参数支持
- **返回值包装**: 同步函数返回值需要 Promise 包装
- **空数组处理**: 边界情况的恒等函数
- **错误传播**: 确保异常能正确传播
- **执行顺序**: 左到右 vs 右到左的选择

## 使用示例

```javascript
// 基本示例：数据处理管道
const add = (x) => x + 1;
const multiply = (x) => x * 2;
const square = (x) => x * x;

const pipeline = compose([add, multiply, square]);
pipeline(5).then((result) => {
  console.log(result); // ((5+1)*2)² = 144
});

// 异步函数示例
const fetchUser = (id) => fetch(`/api/users/${id}`).then((r) => r.json());
const getProfile = (user) =>
  fetch(`/api/profiles/${user.id}`).then((r) => r.json());
function formatProfile(profile) {
  return {
    name: profile.name,
    avatar: profile.avatar,
    bio: profile.bio,
  };
}

const getUserProfile = compose([fetchUser, getProfile, formatProfile]);
getUserProfile(123).then((profile) => {
  console.log(profile); // 格式化的用户档案
});

// 混合同步异步
function validateInput(input) {
  if (!input) throw new Error("Input required");
  return input.trim();
}

const normalizeText = (text) => text.toLowerCase();

async function saveToDb(text) {
  const response = await fetch("/api/save", {
    method: "POST",
    body: JSON.stringify({ text }),
    headers: { "Content-Type": "application/json" },
  });
  return response.json();
}

const processText = compose([validateInput, normalizeText, saveToDb]);
processText("  Hello World  ")
  .then((result) => {
    console.log("Saved:", result);
  })
  .catch((error) => {
    console.error("Error:", error.message);
  });

// 数组处理管道
const numbers = [1, 2, 3, 4, 5];

const filterEven = (arr) => arr.filter((n) => n % 2 === 0);
const doubleValues = (arr) => arr.map((n) => n * 2);
const sumValues = (arr) => arr.reduce((sum, n) => sum + n, 0);

const processNumbers = compose([filterEven, doubleValues, sumValues]);
processNumbers(numbers).then((result) => {
  console.log(result); // (2+4)*2 = 12
});

// 错误处理示例
function riskyOperation(x) {
  if (x < 0) throw new Error("Negative input not allowed");
  return x * 2;
}

const safeOperation = (x) => x + 10;

const safePipeline = compose([riskyOperation, safeOperation]);

safePipeline(5).then((result) => {
  console.log("Success:", result); // 20
});

safePipeline(-1).catch((error) => {
  console.error("Error caught:", error.message);
});

// 复杂数据转换示例
const rawData = {
  users: [
    { id: 1, name: "Alice", age: 30, status: "active" },
    { id: 2, name: "Bob", age: 25, status: "inactive" },
    { id: 3, name: "Charlie", age: 35, status: "active" },
  ],
};

const extractUsers = (data) => data.users;
const filterActive = (users) =>
  users.filter((user) => user.status === "active");
function addAgeGroup(users) {
  return users.map((user) => ({
    ...user,
    ageGroup: user.age >= 30 ? "senior" : "junior",
  }));
}
const sortByAge = (users) => users.sort((a, b) => a.age - b.age);

const processUserData = compose([
  extractUsers,
  filterActive,
  addAgeGroup,
  sortByAge,
]);

processUserData(rawData).then((result) => {
  console.log("Processed users:", result);
  // [
  //   { id: 1, name: 'Alice', age: 30, status: 'active', ageGroup: 'senior' },
  //   { id: 3, name: 'Charlie', age: 35, status: 'active', ageGroup: 'senior' }
  // ]
});

// 中间件模式示例
function logger(ctx, next) {
  console.log(`Entering: ${ctx.path}`);
  return next().then(() => {
    console.log(`Exiting: ${ctx.path}`);
  });
}

function auth(ctx, next) {
  if (!ctx.user) {
    throw new Error("Unauthorized");
  }
  return next();
}

function handler(ctx, next) {
  ctx.response = `Hello, ${ctx.user.name}!`;
  return next();
}

const middleware = composeMiddleware([logger, auth, handler]);

const context = {
  path: "/api/hello",
  user: { name: "Alice" },
};

middleware(context).then(() => {
  console.log("Response:", context.response);
});

// 性能监控示例
async function slowOperation(x) {
  await new Promise((resolve) => setTimeout(resolve, 100));
  return x * 2;
}

const fasterOperation = (x) => x + 10;

const monitoredPipeline = composeWithTiming(
  [slowOperation, fasterOperation],
  (timing) => {
    if (timing.type === "total") {
      console.log(`Total execution time: ${timing.duration}ms`);
    } else {
      console.log(`${timing.functionName}: ${timing.duration}ms`);
    }
  },
);

monitoredPipeline(5).then((result) => {
  console.log("Final result:", result);
});

// 函数组合的组合（高阶组合）
const mathOperations = compose([
  (x) => x + 1, // +1
  (x) => x * 2, // *2
  (x) => x - 3, // -3
]);

const stringOperations = compose([
  (x) => x.toString(), // 转字符串
  (x) => x.padStart(5, "0"), // 补零
  (x) => `Result: ${x}`, // 添加前缀
]);

const fullPipeline = compose([mathOperations, stringOperations]);
fullPipeline(10).then((result) => {
  console.log(result); // "Result: 00019"
});
```

## 记忆要点

### 核心记忆点

1. **执行顺序** - 从左到右，符合数据流直觉
2. **Promise包装** - 统一处理同步异步返回值
3. **reduce模式** - 使用reduce实现链式调用
4. **首参特殊** - 第一个函数支持多参数
5. **错误传播** - Promise链自动处理错误传播

### 实现模式记忆

```javascript
// 标准模式
// 1. 边界检查（空数组、单函数）
// 2. 分离首个函数（多参数支持）
// 3. reduce链式调用
// 4. Promise包装统一返回
```

## 扩展思考

### 1. 支持分支的组合

```javascript
function composeBranch(condition, trueBranch, falseBranch) {
  return function (input) {
    return Promise.resolve(condition(input)).then((shouldTakeTrueBranch) => {
      const branch = shouldTakeTrueBranch ? trueBranch : falseBranch;
      return compose(branch)(input);
    });
  };
}

// 使用示例
const isEven = (x) => x % 2 === 0;
const evenBranch = [(x) => x / 2, (x) => `Even result: ${x}`];
const oddBranch = [(x) => x * 3 + 1, (x) => `Odd result: ${x}`];

const conditionalPipeline = composeBranch(isEven, evenBranch, oddBranch);
```

### 2. 支持循环的组合

```javascript
function composeLoop(fns, condition, maxIterations = 100) {
  return function (input) {
    const result = Promise.resolve(input);
    let iterations = 0;

    const iterate = (value) => {
      if (iterations >= maxIterations || !condition(value)) {
        return value;
      }

      iterations++;
      return compose(fns)(value).then(iterate);
    };

    return result.then(iterate);
  };
}

// 使用示例：计算平方根（牛顿法）
const improve = (x) => (y) => (y + x / y) / 2;
const goodEnough = (x) => (y) => Math.abs(y * y - x) < 0.001;

function sqrt(x) {
  return composeLoop([improve(x)], goodEnough(x))(1.0);
}
```

### 3. 支持记忆化的组合

```javascript
function composeMemoized(fns, keyGenerator = JSON.stringify) {
  const cache = new Map();
  const composedFn = compose(fns);

  return function (...args) {
    const key = keyGenerator(args);

    if (cache.has(key)) {
      return Promise.resolve(cache.get(key));
    }

    return composedFn(...args).then((result) => {
      cache.set(key, result);
      return result;
    });
  };
}
```

### 4. 支持并发控制的组合

```javascript
function composeWithConcurrency(fns, concurrency = 2) {
  return function (...args) {
    const queue = [...fns];
    const results = [];
    const running = [];

    const executeNext = () => {
      if (queue.length === 0) {
        return Promise.all(running);
      }

      const fn = queue.shift();
      const promise = Promise.resolve(fn(...args));
      running.push(promise);

      if (running.length >= concurrency) {
        return Promise.race(running).then(() => {
          const index = running.findIndex((p) => p === promise);
          running.splice(index, 1);
          return executeNext();
        });
      }

      return executeNext();
    };

    return executeNext();
  };
}
```

### 5. 支持流式处理的组合

```javascript
function composeStream(fns) {
  return function (inputStream) {
    return fns.reduce((stream, fn) => {
      return stream.pipe(
        new Transform({
          objectMode: true,
          transform(chunk, encoding, callback) {
            try {
              const result = fn(chunk);

              if (result && typeof result.then === "function") {
                result
                  .then((value) => callback(null, value))
                  .catch((error) => callback(error));
              } else {
                callback(null, result);
              }
            } catch (error) {
              callback(error);
            }
          },
        }),
      );
    }, inputStream);
  };
}
```

## 复习检查清单

- [ ] 理解函数组合的核心概念和执行顺序
- [ ] 掌握同步异步函数的统一处理方法
- [ ] 熟练使用 reduce 实现链式调用
- [ ] 理解 Promise.resolve 的作用和用法
- [ ] 能够处理边界情况和错误传播
- [ ] 了解不同组合模式的适用场景
- [ ] 掌握性能优化和内存管理技巧
- [ ] 熟悉函数式编程的相关概念
- [ ] 能够扩展和定制组合函数的功能
- [ ] 理解在实际项目中的应用场景
