# Fiber

## 题目描述

实现 **Fiber 树的副作用处理**，核心要求：

- 理解 Fiber 架构的链表结构（child、sibling、return）
- 实现深度优先的树遍历算法
- 按照正确的顺序处理节点的副作用
- 模拟 React 中的 commit 阶段处理

本题考查 **树遍历算法**、**链表操作** 和 **React Fiber 架构** 的深度理解。

## 核心知识点

### 1. Fiber 架构的链表结构

```javascript
// 传统树结构 vs Fiber链表结构
// 传统树：        Fiber链表：
//     A              A
//   / | \           /
//  B  C  D    =>   B - C - D
//    /             /
//   E             E
```

**Fiber 节点三个关键指针**：

- `child`: 指向第一个子节点
- `sibling`: 指向下一个兄弟节点
- `return`: 指向父节点（向上回溯用）

### 2. Fiber 架构的优势

- **可中断遍历**: 可以暂停和恢复遍历过程
- **优先级调度**: 支持不同优先级的任务调度
- **增量更新**: 将工作分片，避免长时间阻塞主线程
- **双缓冲**: current 树和 workInProgress 树切换

### 3. React Commit 阶段的处理顺序

```javascript
// 1. commitBeforeMutationEffects (DOM 变更前)
// 2. commitMutationEffects (DOM 变更)
// 3. commitLayoutEffects (DOM 变更后)

// 每个阶段都需要深度优先遍历整个 Fiber 树
```

### 4. 深度优先遍历的关键点

- **先子后兄**: 优先处理子节点，再处理兄弟节点
- **回溯机制**: 利用 return 指针向上回溯
- **完整遍历**: 确保每个节点都被访问到

## 代码实现

```javascript
export function commitNestedComponent(root, onCommitUnmount) {
  // 深度优先遍历整个子树
  let node = root

  // 使用循环代替递归，遵循 Fiber 树的特殊遍历方式
  while (node !== null) {
    // 对当前节点执行卸载回调
    onCommitUnmount(node)

    // 如果有子节点，先处理子节点
    if (node.child !== null) {
      node = node.child
      continue
    }

    // 如果已经到达根节点的最深处，开始回溯
    if (node === root) {
      return
    }

    // 没有子节点了，处理兄弟节点
    while (node.sibling === null) {
      // 如果没有兄弟节点，返回父节点
      if (node.return === null || node.return === root) {
        return
      }
      node = node.return
    }

    // 处理下一个兄弟节点
    node = node.sibling
  }
}

```

## 关键技术点

### 1. Fiber 链表结构遍历

```javascript
// 核心遍历逻辑
while (current) {
  // 处理当前节点
  process(current)

  // 优先处理子节点
  if (current.child) {
    current = current.child
  }
  // 其次处理兄弟节点
  else if (current.sibling) {
    current = current.sibling
  }
  // 最后回溯到父节点
  else {
    current = findNextSibling(current)
  }
}
```

### 2. 回溯算法的关键

```javascript
// 向上回溯直到找到有兄弟节点的祖先
function findNextSibling(node) {
  let current = node.return

  while (current && !current.sibling) {
    current = current.return
  }

  return current ? current.sibling : null
}
```

### 3. React Fiber 的三个阶段

```javascript
// 1. beforeMutation 阶段：DOM 变更前
//    - 执行 getSnapshotBeforeUpdate
//    - 调度 useEffect

// 2. mutation 阶段：DOM 变更
//    - 根据 effectTag 执行 DOM 操作
//    - 插入、更新、删除节点

// 3. layout 阶段：DOM 变更后
//    - 执行 useLayoutEffect
//    - 调用生命周期方法
```

### 4. 可中断执行的实现

```javascript
function interruptibleTraverse(root, onCommit) {
  let current = root

  return function step() {
    const startTime = performance.now()

    while (current && performance.now() - startTime < 5) {
      onCommit(current)
      current = getNextNode(current)
    }

    return current !== null // 返回是否还有未处理的节点
  }
}
```

## 扩展思考

### 1. 支持条件遍历

```javascript
function conditionalCommit(root, shouldVisit, onCommit) {
  let current = root

  while (current) {
    if (shouldVisit(current)) {
      onCommit(current)
    }

    // 根据条件决定是否遍历子树
    if (current.child && shouldVisit(current)) {
      current = current.child
    }
    else if (current.sibling) {
      current = current.sibling
    }
    else {
      current = findNextSiblingFromAncestor(current)
    }
  }
}

// 使用示例：只处理特定类型的组件
conditionalCommit(
  root,
  fiber => fiber.tag.startsWith('User'), // 只处理用户组件
  fiber => console.log(`Processing user component: ${fiber.tag}`),
)
```

### 2. 支持并行处理

```javascript
async function parallelCommit(root, onCommit, concurrency = 4) {
  const queue = []
  const workers = []

  // 收集所有节点
  commitNestedComponent(root, (fiber) => {
    queue.push(fiber)
  })

  // 创建工作器
  for (let i = 0; i < concurrency; i++) {
    workers.push(processQueue())
  }

  async function processQueue() {
    while (queue.length > 0) {
      const fiber = queue.shift()
      if (fiber) {
        await onCommit(fiber)
      }
    }
  }

  await Promise.all(workers)
}
```

### 3. 支持 Diff 算法

```javascript
function commitWithDiff(oldRoot, newRoot, onUpdate) {
  const oldNodes = new Map()
  const newNodes = new Map()

  // 收集旧树节点
  commitNestedComponent(oldRoot, (fiber) => {
    oldNodes.set(fiber.key || fiber.tag, fiber)
  })

  // 收集新树节点并进行对比
  commitNestedComponent(newRoot, (fiber) => {
    const key = fiber.key || fiber.tag
    const oldFiber = oldNodes.get(key)

    if (!oldFiber) {
      onUpdate('INSERT', fiber, null)
    }
    else if (hasChanged(oldFiber, fiber)) {
      onUpdate('UPDATE', fiber, oldFiber)
    }

    newNodes.set(key, fiber)
    oldNodes.delete(key)
  })

  // 处理删除的节点
  for (const [key, fiber] of oldNodes) {
    onUpdate('DELETE', null, fiber)
  }
}
```

### 4. 支持时间切片调度

```javascript
class FiberScheduler {
  constructor() {
    this.taskQueue = []
    this.isRunning = false
    this.frameDeadline = 0
  }

  schedule(root, onCommit, priority = 'normal') {
    const task = {
      root,
      onCommit,
      priority,
      traverser: new FiberTraverser(root),
    }

    this.taskQueue.push(task)
    this.taskQueue.sort(
      (a, b) =>
        this.getPriorityValue(b.priority) - this.getPriorityValue(a.priority),
    )

    if (!this.isRunning) {
      this.scheduleWork()
    }
  }

  scheduleWork() {
    this.isRunning = true
    requestIdleCallback(this.performWork.bind(this))
  }

  performWork(deadline) {
    this.frameDeadline = deadline.timeRemaining()

    while (this.taskQueue.length > 0 && this.frameDeadline > 1) {
      const task = this.taskQueue[0]

      const hasMore = task.traverser.step(
        task.onCommit,
        () => this.frameDeadline > 1,
      )

      if (!hasMore) {
        this.taskQueue.shift() // 任务完成
      }

      this.frameDeadline = deadline.timeRemaining()
    }

    if (this.taskQueue.length > 0) {
      this.scheduleWork() // 继续调度
    }
    else {
      this.isRunning = false
    }
  }

  getPriorityValue(priority) {
    const priorities = { immediate: 3, high: 2, normal: 1, low: 0 }
    return priorities[priority] || 1
  }
}
```

### 5. 支持副作用链优化

```javascript
function buildEffectList(root) {
  let firstEffect = null
  let lastEffect = null

  function appendEffect(fiber) {
    if (!firstEffect) {
      firstEffect = lastEffect = fiber
    }
    else {
      lastEffect.nextEffect = fiber
      lastEffect = fiber
    }
    fiber.nextEffect = null
  }

  function collectEffects(fiber) {
    let childEffect = null

    // 收集子树的副作用
    let child = fiber.child
    while (child) {
      const effect = collectEffects(child)
      if (effect) {
        if (!childEffect) {
          childEffect = effect
        }
      }
      child = child.sibling
    }

    // 添加当前节点的副作用
    if (fiber.effectTag) {
      appendEffect(fiber)
    }

    return firstEffect
  }

  return collectEffects(root)
}

// 使用优化的副作用链
function commitEffectList(firstEffect, onCommit) {
  let effect = firstEffect

  while (effect) {
    onCommit(effect)
    effect = effect.nextEffect
  }
}
```
