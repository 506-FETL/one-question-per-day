# Day 02 复习文档

## 题目描述

实现一个 `generatorToAsync` 函数，将生成器函数转换为异步函数：

- 输入是一个生成器函数
- 输出是一个返回 Promise 的异步函数
- 自动处理 `yield` 返回的 Promise 和普通值
- 正确处理错误情况

本题考查 **生成器函数**、**迭代器协议** 和 **Promise 链式调用** 的深度理解。

## 核心知识点

### 1. 生成器函数 (Generator Function)

- **语法**: 使用 `function*` 声明
- **执行**: 调用返回迭代器对象，不立即执行函数体
- **控制**: 通过 `yield` 暂停，`next()` 继续执行
- **状态**: 保持函数内部状态和变量

### 2. 迭代器协议 (Iterator Protocol)

- **next()**: 返回 `{value, done}` 格式的对象
- **value**: 当前 yield 的值或 return 的值
- **done**: boolean，表示生成器是否完成
- **参数传递**: `next(value)` 可以向生成器内部传值

### 3. async/await 模拟原理

- **核心思想**: 自动处理 Promise 的 then/catch 链
- **状态管理**: 通过递归函数控制执行流程
- **错误传播**: 将异步错误转换为 Promise rejection

## 代码实现

```javascript
export default function generatorToAsync(func) {
  // 参数验证：检查是否为生成器函数
  if (typeof func !== 'function') {
    throw new TypeError('传入参数必须是函数')
  }

  // 测试是否为生成器函数
  let iterator
  try {
    iterator = func()
    if (!iterator || typeof iterator.next !== 'function') {
      throw new TypeError('传入的函数必须是生成器函数')
    }
  }
  catch (error) {
    throw new TypeError('传入的函数必须是生成器函数')
  }

  // Promise-like 对象检测
  const isPromiseLike = (v) => {
    if (v !== null && (typeof v === 'function' || typeof v === 'object')) {
      return typeof v.then === 'function'
    }
    return false
  }

  // 返回异步函数
  return (...args) => {
    // 重新创建迭代器以支持参数传递
    const iterator = func(...args)

    return new Promise((resolve, reject) => {
      function step(prev) {
        let result
        try {
          // 执行生成器的下一步
          result = iterator.next(prev)
        }
        catch (error) {
          // 捕获同步错误
          return reject(error)
        }

        const { value, done } = result

        if (done) {
          // 生成器执行完毕，返回最终结果
          return resolve(value)
        }

        if (isPromiseLike(value)) {
          // 如果是 Promise，等待其完成后继续
          return Promise.resolve(value).then(step, reject)
        }
        else {
          // 普通值，直接继续执行
          return step(value)
        }
      }

      // 开始执行（第一次不传参数）
      step()
    })
  }
}
```

## 算法分析

- **时间复杂度**: O(n) - n 为生成器中 yield 的数量
- **空间复杂度**: O(n) - 递归调用栈的深度
- **特点**: 将同步的生成器转换为异步的 Promise 链

## 关键技术点

### 1. 生成器函数检测

```javascript
// 方法1：检查函数调用结果
const iterator = func()
if (!iterator || typeof iterator.next !== 'function') {
  throw new TypeError('不是生成器函数')
}

// 方法2：检查构造函数
func.constructor.name === 'GeneratorFunction'

// 方法3：检查原型链
func.constructor === function* () {}.constructor
```

### 2. Promise-like 检测

```javascript
function isPromiseLike(v) {
  // 必须是对象或函数
  if (v !== null && (typeof v === 'function' || typeof v === 'object')) {
    // 必须有 then 方法
    return typeof v.then === 'function'
  }
  return false
}

// 为什么不用 instanceof Promise？
// 1. 可能是其他 thenable 对象
// 2. 跨 iframe 或 Worker 的 Promise 检测
// 3. 自定义 thenable 对象支持
```

### 3. 迭代器参数传递机制

```javascript
function* example() {
  const a = yield 1 // 第一次 next() 返回 {value: 1, done: false}
  const b = yield a + 2 // 第二次 next(10) 传入 10，a = 10
  return b + 3 // 第三次 next(20) 传入 20，b = 20，返回 23
}

const it = example()
console.log(it.next()) // {value: 1, done: false}
console.log(it.next(10)) // {value: 12, done: false}
console.log(it.next(20)) // {value: 23, done: true}
```

### 4. 递归执行控制

```javascript
function step(prev) {
  // prev 是上一个异步操作的结果
  try {
    const { value, done } = iterator.next(prev)

    if (done) {
      resolve(value) // 完成
    }
    else if (isPromiseLike(value)) {
      Promise.resolve(value).then(step, reject) // 异步继续
    }
    else {
      step(value) // 同步继续
    }
  }
  catch (error) {
    reject(error) // 错误处理
  }
}
```

### 5. 常见陷阱和坑点

- **参数传递忘记**: 忘记重新创建迭代器导致参数无法传递
- **错误处理不全**: 只处理异步错误，忘记同步错误
- **Promise 包装**: 忘记用 `Promise.resolve()` 包装 thenable
- **栈溢出**: 同步值过多可能导致递归栈溢出

## 使用示例

```javascript
// 基本异步操作
function* fetchData() {
  const user = yield fetch('/api/user').then(r => r.json())
  const posts = yield fetch(`/api/users/${user.id}/posts`).then(r =>
    r.json(),
  )
  return { user, posts }
}

const asyncFetchData = generatorToAsync(fetchData)
asyncFetchData().then((result) => {
  console.log(result) // { user: {...}, posts: [...] }
})

// 混合同步异步操作
function* mixedOperations() {
  const syncValue = yield 42 // 同步值
  const asyncValue = yield Promise.resolve(100) // 异步值
  const computed = yield syncValue + asyncValue // 计算结果
  return computed * 2
}

const asyncMixed = generatorToAsync(mixedOperations)
asyncMixed().then(console.log) // 284

// 错误处理
function* errorGenerator() {
  try {
    const data = yield Promise.reject(new Error('网络错误'))
    return data
  }
  catch (error) {
    return `处理了错误: ${error.message}`
  }
}

const asyncError = generatorToAsync(errorGenerator)
asyncError().then(console.log) // "处理了错误: 网络错误"

// 参数传递
function* withParams(x, y) {
  const result1 = yield Promise.resolve(x + y)
  const result2 = yield result1 * 2
  return result2
}

const asyncWithParams = generatorToAsync(withParams)
asyncWithParams(5, 3).then(console.log) // 16

// 复杂的异步流程控制
function* complexFlow() {
  try {
    // 并行请求
    const [users, products] = yield Promise.all([
      fetch('/api/users').then(r => r.json()),
      fetch('/api/products').then(r => r.json()),
    ])

    // 串行处理
    const enrichedUsers = []
    for (const user of users) {
      const profile = yield fetch(`/api/users/${user.id}/profile`).then(r =>
        r.json(),
      )
      enrichedUsers.push({ ...user, profile })
    }

    return { users: enrichedUsers, products }
  }
  catch (error) {
    console.error('流程执行失败:', error)
    return null
  }
}

const asyncComplexFlow = generatorToAsync(complexFlow)
asyncComplexFlow().then((result) => {
  if (result) {
    console.log('数据加载完成:', result)
  }
})
```

## 记忆要点

### 核心记忆点

1. **生成器检测** - 调用函数检查返回值是否有 `next` 方法
2. **递归控制** - `step` 函数递归处理每个 yield 值
3. **参数传递** - `next(prev)` 将异步结果传回生成器
4. **Promise 处理** - 用 `Promise.resolve()` 统一处理 thenable
5. **错误捕获** - try-catch 捕获同步错误，Promise.catch 处理异步错误

### async/await 对比

```javascript
// 生成器版本
function* getData() {
  const user = yield fetchUser();
  const posts = yield fetchPosts(user.id);
  return { user, posts };
}

// async/await 版本
async function getData() {
  const user = await fetchUser();
  const posts = await fetchPosts(user.id);
  return { user, posts };
}
```

## 扩展思考

### 1. 支持生成器错误注入

```javascript
function generatorToAsyncAdvanced(func) {
  return (...args) => {
    const iterator = func(...args)

    return new Promise((resolve, reject) => {
      function step(prev, isError = false) {
        let result
        try {
          // 根据是否是错误决定调用 next 还是 throw
          result = isError ? iterator.throw(prev) : iterator.next(prev)
        }
        catch (error) {
          return reject(error)
        }

        const { value, done } = result

        if (done) {
          return resolve(value)
        }

        if (isPromiseLike(value)) {
          return Promise.resolve(value).then(
            val => step(val, false),
            err => step(err, true), // 错误时调用 generator.throw()
          )
        }
        else {
          return step(value, false)
        }
      }

      step()
    })
  }
}
```

### 2. 支持取消操作

```javascript
function generatorToAsyncCancellable(func) {
  return (...args) => {
    const iterator = func(...args)
    let cancelled = false

    const promise = new Promise((resolve, reject) => {
      function step(prev) {
        if (cancelled) {
          iterator.return?.() // 清理生成器状态
          return reject(new Error('操作已取消'))
        }

        // ... 正常执行逻辑
      }

      step()
    })

    // 添加取消方法
    promise.cancel = () => {
      cancelled = true
    }

    return promise
  }
}
```

### 3. 性能优化版本

```javascript
function generatorToAsyncOptimized(func) {
  return (...args) => {
    const iterator = func(...args)

    return new Promise((resolve, reject) => {
      let value, done

      // 同步值直接循环处理，避免不必要的 Promise 创建
      while (true) {
        try {
          ({ value, done } = iterator.next(value))
        }
        catch (error) {
          return reject(error)
        }

        if (done) {
          return resolve(value)
        }

        if (isPromiseLike(value)) {
          // 只有遇到 Promise 才转为异步
          return Promise.resolve(value).then(function asyncStep(prev) {
            try {
              const { value, done } = iterator.next(prev)

              if (done) {
                return resolve(value)
              }

              if (isPromiseLike(value)) {
                return Promise.resolve(value).then(asyncStep, reject)
              }
              else {
                return asyncStep(value)
              }
            }
            catch (error) {
              reject(error)
            }
          }, reject)
        }

        // 同步值继续循环
      }
    })
  }
}
```

### 4. 与 co.js 库的对比

```javascript
// co.js 的核心实现原理
function co(gen) {
  const ctx = this
  const args = Array.prototype.slice.call(arguments, 1)

  return new Promise((resolve, reject) => {
    if (typeof gen === 'function')
      gen = gen.apply(ctx, args)
    if (!gen || typeof gen.next !== 'function')
      return resolve(gen)

    onFulfilled()

    function onFulfilled(res) {
      let ret
      try {
        ret = gen.next(res)
      }
      catch (e) {
        return reject(e)
      }
      next(ret)
    }

    function onRejected(err) {
      let ret
      try {
        ret = gen.throw(err)
      }
      catch (e) {
        return reject(e)
      }
      next(ret)
    }

    function next(ret) {
      if (ret.done)
        return resolve(ret.value)
      const value = toPromise.call(ctx, ret.value)
      if (value && isPromise(value))
        return value.then(onFulfilled, onRejected)
      return onRejected(
        new TypeError(
          'You may only yield a function, promise, generator, array, or object',
        ),
      )
    }
  })
}
```

## 复习检查清单

- [ ] 理解生成器函数的基本语法和执行机制
- [ ] 掌握迭代器协议和参数传递方式
- [ ] 熟练实现 Promise-like 对象检测
- [ ] 理解递归控制流的设计模式
- [ ] 掌握同步和异步错误的统一处理
- [ ] 了解与 async/await 的关系和区别
- [ ] 能够扩展支持错误注入和取消操作
- [ ] 理解性能优化和内存管理技巧
- [ ] 熟悉相关库（如 co.js）的实现原理
- [ ] 掌握实际应用场景和最佳实践
