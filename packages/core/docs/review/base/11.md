# Fiber

## 题目描述

实现 **Fiber 树的副作用处理**，核心要求：

- 理解 Fiber 架构的链表结构（child、sibling、return）
- 实现深度优先的树遍历算法
- 按照正确的顺序处理节点的副作用
- 模拟 React 中的 commit 阶段处理

本题考查 **树遍历算法**、**链表操作** 和 **React Fiber 架构** 的深度理解。

## 核心知识点

### 1. Fiber 架构的链表结构

```javascript
// 传统树结构 vs Fiber链表结构
// 传统树：        Fiber链表：
//     A              A
//   / | \           /
//  B  C  D    =>   B - C - D
//    /             /
//   E             E
```

**Fiber 节点三个关键指针**：

- `child`: 指向第一个子节点
- `sibling`: 指向下一个兄弟节点
- `return`: 指向父节点（向上回溯用）

### 2. Fiber 架构的优势

- **可中断遍历**: 可以暂停和恢复遍历过程
- **优先级调度**: 支持不同优先级的任务调度
- **增量更新**: 将工作分片，避免长时间阻塞主线程
- **双缓冲**: current 树和 workInProgress 树切换

### 3. React Commit 阶段的处理顺序

```javascript
// 1. commitBeforeMutationEffects (DOM 变更前)
// 2. commitMutationEffects (DOM 变更)
// 3. commitLayoutEffects (DOM 变更后)

// 每个阶段都需要深度优先遍历整个 Fiber 树
```

### 4. 深度优先遍历的关键点

- **先子后兄**: 优先处理子节点，再处理兄弟节点
- **回溯机制**: 利用 return 指针向上回溯
- **完整遍历**: 确保每个节点都被访问到

## 代码实现

```javascript
/**
 * Fiber 节点类型定义
 */
class FiberNode {
  constructor(tag, key = null) {
    this.tag = tag // 节点标识
    this.key = key // React key
    this.child = null // 第一个子节点
    this.sibling = null // 下一个兄弟节点
    this.return = null // 父节点
    this.effects = [] // 副作用列表
    this.effectTag = null // 副作用类型
  }
}

/**
 * 基础实现：Fiber 树的深度优先遍历
 * 时间复杂度：O(n)，空间复杂度：O(1)
 */
function commitNestedComponent(root, onCommitUnmount) {
  if (!root)
    return

  let current = root

  while (current) {
    // 处理当前节点
    onCommitUnmount(current)

    // 深度优先遍历策略
    if (current.child) {
      // 1. 优先处理子节点
      current = current.child
    }
    else if (current.sibling) {
      // 2. 没有子节点，处理兄弟节点
      current = current.sibling
    }
    else {
      // 3. 没有子节点和兄弟节点，向上回溯
      current = current.return

      // 查找未处理的兄弟节点
      while (current && !current.sibling) {
        current = current.return
      }

      // 继续处理兄弟节点
      if (current) {
        current = current.sibling
      }
    }
  }
}

/**
 * 增强版实现：支持副作用收集和处理
 */
function commitWithEffects(root, onCommitUnmount) {
  const effectList = []

  function traverseAndCollect(fiber) {
    if (!fiber)
      return

    // 收集有副作用的节点
    if (fiber.effectTag) {
      effectList.push(fiber)
    }

    // 深度优先遍历
    let current = fiber
    while (current) {
      // 处理当前节点
      onCommitUnmount(current)

      if (current.child) {
        current = current.child
      }
      else if (current.sibling) {
        current = current.sibling
      }
      else {
        // 回溯到有兄弟节点的祖先
        current = current.return
        while (current && current !== fiber && !current.sibling) {
          current = current.return
        }

        if (current && current !== fiber) {
          current = current.sibling
        }
        else {
          break
        }
      }
    }
  }

  traverseAndCollect(root)

  // 处理收集到的副作用
  effectList.forEach((fiber) => {
    console.log(`Processing effect: ${fiber.effectTag} on ${fiber.tag}`)
  })

  return effectList
}

/**
 * 递归版本实现（更容易理解）
 */
function commitNestedComponentRecursive(root, onCommitUnmount) {
  if (!root)
    return

  // 处理当前节点
  onCommitUnmount(root)

  // 递归处理子树
  let child = root.child
  while (child) {
    commitNestedComponentRecursive(child, onCommitUnmount)
    child = child.sibling
  }
}

/**
 * 支持中断的可恢复遍历
 */
class FiberTraverser {
  constructor(root) {
    this.root = root
    this.current = root
    this.isComplete = false
    this.visited = new Set()
  }

  // 执行一步遍历
  step(onCommitUnmount, shouldContinue = () => true) {
    if (this.isComplete || !this.current) {
      return false
    }

    const startTime = performance.now()

    while (this.current && shouldContinue()) {
      // 避免重复处理
      if (!this.visited.has(this.current)) {
        onCommitUnmount(this.current)
        this.visited.add(this.current)
      }

      // 移动到下一个节点
      if (this.current.child && !this.visited.has(this.current.child)) {
        this.current = this.current.child
      }
      else if (this.current.sibling) {
        this.current = this.current.sibling
      }
      else {
        // 回溯
        this.current = this.current.return
        while (this.current && !this.current.sibling) {
          this.current = this.current.return
        }

        if (this.current) {
          this.current = this.current.sibling
        }
        else {
          this.isComplete = true
          break
        }
      }

      // 防止长时间阻塞
      if (performance.now() - startTime > 5) {
        break
      }
    }

    return !this.isComplete
  }

  // 完整遍历
  traverse(onCommitUnmount) {
    while (this.step(onCommitUnmount)) {
      // 可以在这里添加调度逻辑
    }
  }
}

/**
 * 模拟 React 的 commit 阶段
 */
function simulateReactCommit(root) {
  const phases = ['beforeMutation', 'mutation', 'layout']

  phases.forEach((phase) => {
    console.log(`Starting ${phase} phase`)

    commitNestedComponent(root, (fiber) => {
      if (fiber.effects.includes(phase)) {
        console.log(`${phase}: processing ${fiber.tag}`)
      }
    })

    console.log(`Completed ${phase} phase`)
  })
}

/**
 * 支持优先级的副作用处理
 */
function commitWithPriority(root, onCommitUnmount) {
  const highPriorityNodes = []
  const normalPriorityNodes = []
  const lowPriorityNodes = []

  // 收集并分类节点
  commitNestedComponent(root, (fiber) => {
    if (fiber.priority === 'high') {
      highPriorityNodes.push(fiber)
    }
    else if (fiber.priority === 'low') {
      lowPriorityNodes.push(fiber)
    }
    else {
      normalPriorityNodes.push(fiber)
    }
  })

  // 按优先级处理
  const processNodes = (nodes, priority) => {
    console.log(`Processing ${priority} priority nodes`)
    nodes.forEach(onCommitUnmount)
  }

  processNodes(highPriorityNodes, 'high')
  processNodes(normalPriorityNodes, 'normal')
  processNodes(lowPriorityNodes, 'low')
}

/**
 * 支持错误边界的遍历
 */
function commitWithErrorHandling(root, onCommitUnmount, onError) {
  let current = root
  const errorStack = []

  while (current) {
    try {
      onCommitUnmount(current)

      if (current.child) {
        errorStack.push(current) // 记录路径用于错误恢复
        current = current.child
      }
      else if (current.sibling) {
        current = current.sibling
      }
      else {
        // 回溯
        errorStack.pop()
        current = current.return

        while (current && !current.sibling) {
          errorStack.pop()
          current = current.return
        }

        if (current) {
          current = current.sibling
        }
      }
    }
    catch (error) {
      console.error(`Error processing fiber node ${current.tag}:`, error)

      if (onError) {
        const shouldContinue = onError(error, current, errorStack)
        if (!shouldContinue) {
          break
        }
      }

      // 跳过当前节点，继续处理
      if (current.sibling) {
        current = current.sibling
      }
      else {
        // 回溯到安全位置
        current = errorStack.pop()?.return
        while (current && !current.sibling) {
          current = current.return
        }

        if (current) {
          current = current.sibling
        }
      }
    }
  }
}
```

## 算法分析

- **时间复杂度**: O(n) - n 为 Fiber 树中节点的总数
- **空间复杂度**: O(1) - 迭代版本，O(h) - 递归版本(h为树高)
- **特点**: 深度优先遍历、链表操作、可中断执行

## 关键技术点

### 1. Fiber 链表结构遍历

```javascript
// 核心遍历逻辑
while (current) {
  // 处理当前节点
  process(current)

  // 优先处理子节点
  if (current.child) {
    current = current.child
  }
  // 其次处理兄弟节点
  else if (current.sibling) {
    current = current.sibling
  }
  // 最后回溯到父节点
  else {
    current = findNextSibling(current)
  }
}
```

### 2. 回溯算法的关键

```javascript
// 向上回溯直到找到有兄弟节点的祖先
function findNextSibling(node) {
  let current = node.return

  while (current && !current.sibling) {
    current = current.return
  }

  return current ? current.sibling : null
}
```

### 3. React Fiber 的三个阶段

```javascript
// 1. beforeMutation 阶段：DOM 变更前
//    - 执行 getSnapshotBeforeUpdate
//    - 调度 useEffect

// 2. mutation 阶段：DOM 变更
//    - 根据 effectTag 执行 DOM 操作
//    - 插入、更新、删除节点

// 3. layout 阶段：DOM 变更后
//    - 执行 useLayoutEffect
//    - 调用生命周期方法
```

### 4. 可中断执行的实现

```javascript
function interruptibleTraverse(root, onCommit) {
  let current = root

  return function step() {
    const startTime = performance.now()

    while (current && performance.now() - startTime < 5) {
      onCommit(current)
      current = getNextNode(current)
    }

    return current !== null // 返回是否还有未处理的节点
  }
}
```

### 5. 常见陷阱和坑点

- **无限循环**: 回溯逻辑错误导致的循环
- **节点遗漏**: 兄弟节点链处理不当
- **内存泄漏**: 长时间持有 Fiber 节点引用
- **顺序错误**: 没有按照正确的深度优先顺序
- **异常处理**: 节点处理失败时的恢复机制

## 使用示例

```javascript
// 构建 Fiber 树示例
//       A
//      /
//     B - C - D
//    /       /
//   E - F   G

function createFiberTree() {
  const A = new FiberNode('A')
  const B = new FiberNode('B')
  const C = new FiberNode('C')
  const D = new FiberNode('D')
  const E = new FiberNode('E')
  const F = new FiberNode('F')
  const G = new FiberNode('G')

  // 设置父子关系
  A.child = B
  B.child = E
  E.sibling = F

  // 设置兄弟关系
  B.sibling = C
  C.sibling = D
  D.child = G

  // 设置 return 指针
  B.return = A
  C.return = A
  D.return = A
  E.return = B
  F.return = B
  G.return = D

  return A
}

// 基本遍历示例
const root = createFiberTree()
const visitOrder = []

commitNestedComponent(root, (fiber) => {
  visitOrder.push(fiber.tag)
  console.log(`Visiting: ${fiber.tag}`)
})

console.log('Visit order:', visitOrder)
// 输出: ['A', 'B', 'E', 'F', 'C', 'D', 'G']

// 副作用处理示例
function setupEffects(root) {
  // 为节点添加副作用
  root.effectTag = 'UPDATE'
  root.child.effectTag = 'INSERT'
  root.child.sibling.effectTag = 'DELETE'

  return root
}

const rootWithEffects = setupEffects(createFiberTree())
const effects = commitWithEffects(rootWithEffects, (fiber) => {
  if (fiber.effectTag) {
    console.log(`Effect: ${fiber.effectTag} on ${fiber.tag}`)
  }
})

// 可中断遍历示例
const traverser = new FiberTraverser(createFiberTree())
let stepCount = 0

// 模拟时间切片
function timeSlicedTraversal() {
  const hasMore = traverser.step(
    (fiber) => {
      console.log(`Step ${++stepCount}: ${fiber.tag}`)
    },
    () => performance.now() % 10 < 5,
  ) // 50% 概率继续

  if (hasMore) {
    setTimeout(timeSlicedTraversal, 16) // 下一帧继续
  }
  else {
    console.log('Traversal complete')
  }
}

timeSlicedTraversal()

// 错误处理示例
const problematicRoot = createFiberTree()
problematicRoot.child.sibling.tag = null // 制造错误

commitWithErrorHandling(
  problematicRoot,
  (fiber) => {
    if (!fiber.tag) {
      throw new Error('Invalid fiber node')
    }
    console.log(`Processing: ${fiber.tag}`)
  },
  (error, fiber, stack) => {
    console.error(`Error at ${fiber?.tag || 'unknown'}:`, error.message)
    console.log(
      'Error stack:',
      stack.map(f => f.tag),
    )
    return true // 继续执行
  },
)

// 优先级处理示例
function setPriorities(root) {
  root.priority = 'high'
  root.child.priority = 'normal'
  root.child.sibling.priority = 'low'
  root.child.child.priority = 'high'

  return root
}

const prioritizedRoot = setPriorities(createFiberTree())
commitWithPriority(prioritizedRoot, (fiber) => {
  console.log(`Processing ${fiber.priority} priority: ${fiber.tag}`)
})

// 性能测试
function performanceTest() {
  // 创建大型 Fiber 树
  function createLargeFiberTree(depth, breadth) {
    const root = new FiberNode(`node-0`)

    function buildLevel(parent, currentDepth, nodeIndex) {
      if (currentDepth >= depth)
        return nodeIndex

      let prevSibling = null
      for (let i = 0; i < breadth; i++) {
        const node = new FiberNode(`node-${nodeIndex++}`)
        node.return = parent

        if (i === 0) {
          parent.child = node
        }
        else {
          prevSibling.sibling = node
        }

        nodeIndex = buildLevel(node, currentDepth + 1, nodeIndex)
        prevSibling = node
      }

      return nodeIndex
    }

    buildLevel(root, 0, 1)
    return root
  }

  const largeTree = createLargeFiberTree(6, 3) // 深度6，每层3个节点
  let nodeCount = 0

  console.time('Fiber traversal')
  commitNestedComponent(largeTree, () => {
    nodeCount++
  })
  console.timeEnd('Fiber traversal')

  console.log(`Processed ${nodeCount} nodes`)
}

performanceTest()

// 与传统树遍历对比
function traditionalTreeTraversal(node, visit) {
  if (!node)
    return

  visit(node)

  // 假设传统树有 children 数组
  if (node.children) {
    node.children.forEach((child) => {
      traditionalTreeTraversal(child, visit)
    })
  }
}

// 模拟 React 组件树
function createReactComponentTree() {
  const App = new FiberNode('App')
  const Header = new FiberNode('Header')
  const Main = new FiberNode('Main')
  const Footer = new FiberNode('Footer')
  const Nav = new FiberNode('Nav')
  const Content = new FiberNode('Content')

  App.child = Header
  Header.sibling = Main
  Main.sibling = Footer

  Header.child = Nav
  Main.child = Content

  // 设置 return 指针
  Header.return = App
  Main.return = App
  Footer.return = App
  Nav.return = Header
  Content.return = Main

  return App
}

const componentTree = createReactComponentTree()
console.log('React component tree traversal:')
commitNestedComponent(componentTree, (fiber) => {
  console.log(`Rendering component: ${fiber.tag}`)
})
```

## 记忆要点

### 核心记忆点

1. **三指针结构** - child(子)、sibling(兄)、return(父)
2. **深度优先** - 先子节点、再兄弟节点、最后回溯
3. **迭代实现** - 避免递归栈溢出，支持中断
4. **回溯算法** - 向上查找未处理的兄弟节点
5. **副作用收集** - 遍历过程中收集需要处理的副作用

### 遍历顺序记忆

```javascript
// 遍历优先级：child > sibling > return
// 1. 有子节点 -> 进入子节点
// 2. 无子节点有兄弟 -> 进入兄弟节点
// 3. 无子无兄弟 -> 回溯到父节点
// 4. 重复直到回溯到根节点且无兄弟节点
```

## 扩展思考

### 1. 支持条件遍历

```javascript
function conditionalCommit(root, shouldVisit, onCommit) {
  let current = root

  while (current) {
    if (shouldVisit(current)) {
      onCommit(current)
    }

    // 根据条件决定是否遍历子树
    if (current.child && shouldVisit(current)) {
      current = current.child
    }
    else if (current.sibling) {
      current = current.sibling
    }
    else {
      current = findNextSiblingFromAncestor(current)
    }
  }
}

// 使用示例：只处理特定类型的组件
conditionalCommit(
  root,
  fiber => fiber.tag.startsWith('User'), // 只处理用户组件
  fiber => console.log(`Processing user component: ${fiber.tag}`),
)
```

### 2. 支持并行处理

```javascript
async function parallelCommit(root, onCommit, concurrency = 4) {
  const queue = []
  const workers = []

  // 收集所有节点
  commitNestedComponent(root, (fiber) => {
    queue.push(fiber)
  })

  // 创建工作器
  for (let i = 0; i < concurrency; i++) {
    workers.push(processQueue())
  }

  async function processQueue() {
    while (queue.length > 0) {
      const fiber = queue.shift()
      if (fiber) {
        await onCommit(fiber)
      }
    }
  }

  await Promise.all(workers)
}
```

### 3. 支持 Diff 算法

```javascript
function commitWithDiff(oldRoot, newRoot, onUpdate) {
  const oldNodes = new Map()
  const newNodes = new Map()

  // 收集旧树节点
  commitNestedComponent(oldRoot, (fiber) => {
    oldNodes.set(fiber.key || fiber.tag, fiber)
  })

  // 收集新树节点并进行对比
  commitNestedComponent(newRoot, (fiber) => {
    const key = fiber.key || fiber.tag
    const oldFiber = oldNodes.get(key)

    if (!oldFiber) {
      onUpdate('INSERT', fiber, null)
    }
    else if (hasChanged(oldFiber, fiber)) {
      onUpdate('UPDATE', fiber, oldFiber)
    }

    newNodes.set(key, fiber)
    oldNodes.delete(key)
  })

  // 处理删除的节点
  for (const [key, fiber] of oldNodes) {
    onUpdate('DELETE', null, fiber)
  }
}
```

### 4. 支持时间切片调度

```javascript
class FiberScheduler {
  constructor() {
    this.taskQueue = []
    this.isRunning = false
    this.frameDeadline = 0
  }

  schedule(root, onCommit, priority = 'normal') {
    const task = {
      root,
      onCommit,
      priority,
      traverser: new FiberTraverser(root),
    }

    this.taskQueue.push(task)
    this.taskQueue.sort(
      (a, b) =>
        this.getPriorityValue(b.priority) - this.getPriorityValue(a.priority),
    )

    if (!this.isRunning) {
      this.scheduleWork()
    }
  }

  scheduleWork() {
    this.isRunning = true
    requestIdleCallback(this.performWork.bind(this))
  }

  performWork(deadline) {
    this.frameDeadline = deadline.timeRemaining()

    while (this.taskQueue.length > 0 && this.frameDeadline > 1) {
      const task = this.taskQueue[0]

      const hasMore = task.traverser.step(
        task.onCommit,
        () => this.frameDeadline > 1,
      )

      if (!hasMore) {
        this.taskQueue.shift() // 任务完成
      }

      this.frameDeadline = deadline.timeRemaining()
    }

    if (this.taskQueue.length > 0) {
      this.scheduleWork() // 继续调度
    }
    else {
      this.isRunning = false
    }
  }

  getPriorityValue(priority) {
    const priorities = { immediate: 3, high: 2, normal: 1, low: 0 }
    return priorities[priority] || 1
  }
}
```

### 5. 支持副作用链优化

```javascript
function buildEffectList(root) {
  let firstEffect = null
  let lastEffect = null

  function appendEffect(fiber) {
    if (!firstEffect) {
      firstEffect = lastEffect = fiber
    }
    else {
      lastEffect.nextEffect = fiber
      lastEffect = fiber
    }
    fiber.nextEffect = null
  }

  function collectEffects(fiber) {
    let childEffect = null

    // 收集子树的副作用
    let child = fiber.child
    while (child) {
      const effect = collectEffects(child)
      if (effect) {
        if (!childEffect) {
          childEffect = effect
        }
      }
      child = child.sibling
    }

    // 添加当前节点的副作用
    if (fiber.effectTag) {
      appendEffect(fiber)
    }

    return firstEffect
  }

  return collectEffects(root)
}

// 使用优化的副作用链
function commitEffectList(firstEffect, onCommit) {
  let effect = firstEffect

  while (effect) {
    onCommit(effect)
    effect = effect.nextEffect
  }
}
```

## 复习检查清单

- [ ] 理解 Fiber 架构的链表结构和优势
- [ ] 掌握深度优先遍历的迭代实现
- [ ] 熟练使用三指针(child/sibling/return)导航
- [ ] 理解回溯算法在树遍历中的应用
- [ ] 掌握可中断遍历的实现原理
- [ ] 了解 React Fiber 的工作原理
- [ ] 能够处理副作用收集和处理
- [ ] 熟悉错误处理和恢复机制
- [ ] 理解时间切片和优先级调度
- [ ] 掌握性能优化和内存管理技巧
