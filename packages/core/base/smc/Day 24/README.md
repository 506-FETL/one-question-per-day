## 题目：可配置的节流函数（Throttle with Options）

实现一个增强版的 `throttle(fn, wait, options?)`，第三个参数允许传入：

```ts
interface ThrottleOptions {
   leading?: boolean  // 是否在时间窗口开始立刻执行一次（默认 true）
   trailing?: boolean // 是否在窗口结束时（若有被压缩的调用）再补执行一次（默认 true）
}
```

> 注意：本题期望的行为与常见库（如 lodash.throttle）细节不完全相同，请完全以题面描述与时间轴示例为准。

### 基础概念

给定一个固定长度的“时间窗口”（例如示例中的 `wait = 3` 单位），对一串在不同时间点发起的调用进行“压缩”，使得在窗口期内的多次调用按配置仅保留特定的执行时刻。

### 时间轴示例

原始调用序列（字母代表调用标识，位置代表调用时间刻度）：

```
─ A ─ B ─ C ─ ─ D ─ ─ ─ ─ ─ ─ E ─ ─ F ─ G
0   2   3           6           12  13  14 (时间刻度示意)
```

在 `wait = 3` 的前提下，不同 `options` 组合对应“保留下来的执行”应如下（仅保留题面核心差异）：

| options                               | 结果执行序列 | 说明                                                     |
| ------------------------------------- | ------------ | -------------------------------------------------------- |
| `{ leading: true,  trailing: true }`  | A C D E G    | 窗口开始立即执行；窗口内再次调用可在末尾补一次；F 被压缩 |
| `{ leading: false, trailing: true }`  | C D G        | 跳过每个窗口的第一次（如 A、E）但在窗口末尾补发          |
| `{ leading: true,  trailing: false }` | A D E        | 仅窗口开头，末尾不补发（C、G 被压缩）                    |
| `{ leading: false, trailing: false }` | （无执行）   | 两者皆禁用 => 不触发                                     |

> 若实现中发现与该表格不一致，说明窗口起止或补发逻辑处理有偏差。

### 需求要点（必须满足）

1. 尊重 `leading` 与 `trailing` 的组合：四种情形输出与表格一致。
2. `leading === false && trailing === false` 时不会产生任何执行。
3. 仅在允许的时间点执行，且不多执行、不漏执行。
4. `trailing` 补发只在窗口内“曾经有被压缩的调用”时才发生。
5. 不依赖真实时间精度：评测环境会对 `setTimeout / clearTimeout` 做可控替换。

### 行为细节

- “窗口开始”指：某次执行后的 `wait` 周期起点。
- 如果 `leading = false`，第一次调用不会立即执行，窗口基准需推后（具体实现方式由你决定，但结果必须符合表格）。
- 如果在一个窗口内多次调用，且 `trailing = true`，窗口结束时应使用“最后一次调用的参数”再执行一次。
- 如果在窗口期间没有新的调用，则不应产生“多余的 trailing 执行”。
