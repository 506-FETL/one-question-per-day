在某些场景里需要并发调用大量 API，例如一次性请求 100 个端点。直接使用 `Promise.all()` 会让 100 个请求同时打到服务端：如果你的服务器性能一般，这种“瞬时洪峰”会带来明显压力。

为此，需要对请求做**并发节流**：任何时刻最多只有 5 个请求在进行中，其余排队等待。请实现一个函数：

**`throttlePromises(funcs, max)`**

- `funcs`: 由 **promise 生成函数** 组成的数组（即 `() => Promise<T>` 的数组，而不是已经开始执行的 Promise）。
- `max`: 并发上限，例如 `5`。

函数行为要求与 `Promise.all` 保持一致：

- 全部成功时，按原任务顺序返回结果数组；
- 任意一个任务失败时，立即以该错误拒绝整个 Promise（与 `Promise.all` 相同语义）。

**示例：**

```js
throttlePromises(callApis, 5)
  .then((data) => {
    // 数据和使用`Promise.all`得到的 一样
  })
  .catch((err) => {
    // 出错时的行为也与 Promise.all 一致
  });
```

通过并发上限为 5，服务器在任何时刻只需处理最多 5 个正在进行的请求，执行上述代码过后，因为任何时候都不会超过5个API请求在进行，性能低下的服务器得救了。
