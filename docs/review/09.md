# Day 09 复习文档

## 题目描述

实现二叉树的**垂直遍历**，要求从左到右、从上到下遍历二叉树。核心挑战是：

- 建立正确的坐标系统（垂直线和深度）
- 处理同一位置多个节点的排序规则
- 保持父节点关系的顺序继承

本题考查 **树遍历算法**、**坐标计算** 和 **多维排序** 的综合应用。

![二叉树垂直遍历示意图](/image.png)

上述二叉树的垂直遍历结果为：[6,4,2,7,1,9,10,3,8,5]

## 核心知识点

### 1. 垂直遍历的坐标系统

```javascript
// 坐标定义：(垂直线, 深度)
//         (0, 0) 根节点
//       /           \
//   (-1, 1)       (1, 1)
//    /    \       /    \
// (-2, 2) (0, 2) (0, 2) (2, 2)
```

**垂直线计算规则**：

- 根节点垂直线为 0
- 左子节点垂直线 = 父节点垂直线 - 1
- 右子节点垂直线 = 父节点垂直线 + 1

**深度计算规则**：

- 根节点深度为 0
- 子节点深度 = 父节点深度 + 1

### 2. 复杂排序规则

1. **主排序**：按垂直线从左到右（升序）
2. **次排序**：同垂直线按深度从上到下（升序）
3. **三级排序**：同位置按父节点的遍历顺序

### 3. 关键难点：同位置节点处理

```javascript
// 示例：节点9和10都在位置(1, 3)
// 因为节点8在节点7之后被访问，所以10在9之后
//     ...
//    /   \
//   7     8
//  /     /
// 9     10
```

### 4. 三种实现方案对比

- **DFS + 排序**: 简单但效率较低，O(n log n)
- **BFS + 分组**: 按层处理，便于理解
- **DFS + 直接构建**: 最优解，O(n)

## 代码实现

```javascript
// 节点类定义
export class Node {
  constructor(val) {
    this.value = val;
    this.left = null;
    this.right = null;
  }
}

/**
 * 方案一：DFS + 坐标收集 + 排序
 * 时间复杂度：O(n log n)，空间复杂度：O(n)
 */
export function traverse(root) {
  if (!root) return [];

  const nodes = [];

  // DFS 收集所有节点的坐标信息
  function dfs(node, col, row, parentCol) {
    if (!node) return;

    // 收集节点信息：[值, 垂直线, 深度, 父节点垂直线]
    nodes.push([node.value, col, row, parentCol]);

    // 递归遍历子树
    dfs(node.left, col - 1, row + 1, col);
    dfs(node.right, col + 1, row + 1, col);
  }

  dfs(root, 0, 0, 0);

  // 多级排序
  nodes.sort((a, b) => {
    const [val1, col1, row1, parentCol1] = a;
    const [val2, col2, row2, parentCol2] = b;

    // 1. 按垂直线排序
    if (col1 !== col2) return col1 - col2;

    // 2. 同垂直线按深度排序
    if (row1 !== row2) return row1 - row2;

    // 3. 同位置按父节点垂直线排序（左父优先）
    return parentCol1 - parentCol2;
  });

  return nodes.map(([val]) => val);
}

/**
 * 方案二：BFS + 层序处理
 * 时间复杂度：O(n log n)，空间复杂度：O(n)
 */
export function traverseBFS(root) {
  if (!root) return [];

  const columnMap = new Map();
  const queue = [[root, 0, 0]]; // [节点, 垂直线, 深度]

  while (queue.length > 0) {
    const [node, col, row] = queue.shift();

    // 按垂直线分组存储
    if (!columnMap.has(col)) {
      columnMap.set(col, []);
    }
    columnMap.get(col).push([node.value, row]);

    // 添加子节点到队列
    if (node.left) {
      queue.push([node.left, col - 1, row + 1]);
    }
    if (node.right) {
      queue.push([node.right, col + 1, row + 1]);
    }
  }

  // 按垂直线排序并提取结果
  const sortedColumns = Array.from(columnMap.keys()).sort((a, b) => a - b);
  const result = [];

  for (const col of sortedColumns) {
    const nodes = columnMap.get(col);
    // 同垂直线内按深度排序
    nodes.sort((a, b) => a[1] - b[1]);
    result.push(...nodes.map(([val]) => val));
  }

  return result;
}

/**
 * 方案三：DFS + 直接构建结果（最优解）
 * 时间复杂度：O(n)，空间复杂度：O(n)
 */
export function traverseOptimal(root) {
  if (!root) return [];

  const columnMap = new Map();
  let minCol = 0;
  let maxCol = 0;

  // DFS 遍历并直接按顺序记录
  function dfs(node, col, row) {
    if (!node) return;

    // 更新列范围
    minCol = Math.min(minCol, col);
    maxCol = Math.max(maxCol, col);

    // 初始化该列的数组
    if (!columnMap.has(col)) {
      columnMap.set(col, []);
    }

    // 按深度和访问顺序插入
    const column = columnMap.get(col);
    let inserted = false;

    for (let i = 0; i < column.length; i++) {
      if (row < column[i][1]) {
        column.splice(i, 0, [node.value, row]);
        inserted = true;
        break;
      } else if (row === column[i][1]) {
        // 同深度节点，按 DFS 访问顺序决定
        // 这里需要特殊处理，实际上原 DFS 顺序就是正确的
        column.splice(i + 1, 0, [node.value, row]);
        inserted = true;
        break;
      }
    }

    if (!inserted) {
      column.push([node.value, row]);
    }

    // 先左后右的 DFS 顺序
    dfs(node.left, col - 1, row + 1);
    dfs(node.right, col + 1, row + 1);
  }

  dfs(root, 0, 0);

  // 按列顺序收集结果
  const result = [];
  for (let col = minCol; col <= maxCol; col++) {
    if (columnMap.has(col)) {
      const nodes = columnMap.get(col);
      result.push(...nodes.map(([val]) => val));
    }
  }

  return result;
}

/**
 * 增强版：支持重复值处理
 */
export function traverseWithDuplicates(root) {
  if (!root) return [];

  const result = [];
  const columnGroups = new Map();

  function dfs(node, col, row, visitOrder) {
    if (!node) return visitOrder;

    // 记录节点信息
    if (!columnGroups.has(col)) {
      columnGroups.set(col, []);
    }

    columnGroups.get(col).push({
      value: node.value,
      row,
      order: visitOrder,
    });

    // 递归遍历（先左后右）
    visitOrder = dfs(node.left, col - 1, row + 1, visitOrder + 1);
    visitOrder = dfs(node.right, col + 1, row + 1, visitOrder + 1);

    return visitOrder;
  }

  dfs(root, 0, 0, 0);

  // 排序并构建结果
  const sortedColumns = Array.from(columnGroups.keys()).sort((a, b) => a - b);

  for (const col of sortedColumns) {
    const nodes = columnGroups.get(col);

    // 多级排序：行 -> 访问顺序
    nodes.sort((a, b) => {
      if (a.row !== b.row) return a.row - b.row;
      return a.order - b.order;
    });

    result.push(...nodes.map((node) => node.value));
  }

  return result;
}
```

## 算法分析

- **时间复杂度**: O(n) - 最优解只需一次遍历，O(n log n) - 需要排序的方案
- **空间复杂度**: O(n) - 存储所有节点信息和递归栈
- **特点**: 多维排序、坐标映射、树遍历

## 关键技术点

### 1. 坐标系建立

```javascript
// 垂直线和深度的计算
function dfs(node, col, row) {
  // 当前节点位置：(col, row)

  // 左子树：垂直线-1，深度+1
  dfs(node.left, col - 1, row + 1);

  // 右子树：垂直线+1，深度+1
  dfs(node.right, col + 1, row + 1);
}
```

### 2. 多级排序策略

```javascript
// 排序优先级：垂直线 > 深度 > 父节点关系
nodes.sort((a, b) => {
  if (a.col !== b.col) return a.col - b.col; // 垂直线
  if (a.row !== b.row) return a.row - b.row; // 深度
  return a.parentCol - b.parentCol; // 父节点关系
});
```

### 3. 同位置节点的顺序处理

```javascript
// 关键：DFS 的访问顺序天然符合要求
// 左子树先访问，右子树后访问
// 同深度节点的父节点关系决定最终顺序

function handleSamePosition(nodes) {
  // 对于同一位置(col, row)的节点
  // 按照 DFS 中父节点的访问顺序排列
  return nodes.sort((a, b) => a.dfsOrder - b.dfsOrder);
}
```

### 4. 内存优化技巧

```javascript
// 使用 Map 代替对象，支持数字键
const columnMap = new Map();

// 动态范围计算，减少遍历
const minCol = Infinity;
const maxCol = -Infinity;

// 及时清理不需要的数据
for (let col = minCol; col <= maxCol; col++) {
  if (columnMap.has(col)) {
    // 处理完立即删除
    const nodes = columnMap.get(col);
    result.push(...nodes);
    columnMap.delete(col);
  }
}
```

### 5. 常见陷阱和坑点

- **排序规则错误**: 忘记考虑父节点关系
- **坐标计算错误**: 左右子树方向搞反
- **同位置处理**: 没有正确处理同深度同列的节点
- **边界情况**: 空树、单节点、链式树
- **内存溢出**: 大树递归深度过深

## 使用示例

```javascript
// 构建测试二叉树
//       1
//      / \
//     2   3
//    / \   \
//   4   5   6
//  /         \
// 7           8

const root = new Node(1);
root.left = new Node(2);
root.right = new Node(3);
root.left.left = new Node(4);
root.left.right = new Node(5);
root.right.right = new Node(6);
root.left.left.left = new Node(7);
root.right.right.right = new Node(8);

// 垂直遍历
console.log(traverse(root));
// 输出: [7, 4, 2, 1, 5, 3, 6, 8]

// 分析遍历过程：
// 垂直线 -2: [7] (深度3)
// 垂直线 -1: [4] (深度2)
// 垂直线  0: [2, 1, 5] (深度1,0,2)
// 垂直线  1: [3] (深度1)
// 垂直线  2: [6] (深度2)
// 垂直线  3: [8] (深度3)

// 复杂示例：同位置多节点
//       1
//      / \
//     2   3
//    /|   |\
//   4 5   6 7
//    X     X
//   8 9   10 11

const complexRoot = new Node(1);
complexRoot.left = new Node(2);
complexRoot.right = new Node(3);
complexRoot.left.left = new Node(4);
complexRoot.left.right = new Node(5);
complexRoot.right.left = new Node(6);
complexRoot.right.right = new Node(7);
complexRoot.left.right.left = new Node(8);
complexRoot.left.right.right = new Node(9);
complexRoot.right.left.left = new Node(10);
complexRoot.right.left.right = new Node(11);

console.log(traverse(complexRoot));
// 需要特别注意8,9,10,11在垂直线0上的排序

// 边界情况测试
console.log(traverse(null)); // []
console.log(traverse(new Node(42))); // [42]

// 链式树测试
const chainRoot = new Node(1);
let current = chainRoot;
for (let i = 2; i <= 5; i++) {
  current.left = new Node(i);
  current = current.left;
}
console.log(traverse(chainRoot)); // [5, 4, 3, 2, 1]

// 性能测试
function buildPerfectTree(depth) {
  if (depth === 0) return null;

  const root = new Node(depth);
  root.left = buildPerfectTree(depth - 1);
  root.right = buildPerfectTree(depth - 1);
  return root;
}

const perfTree = buildPerfectTree(10);
console.time("traverse");
const result = traverse(perfTree);
console.timeEnd("traverse");
console.log(`Traversed ${result.length} nodes`);

// 验证结果正确性
function validateResult(root, result) {
  const allNodes = [];

  function collectAll(node) {
    if (!node) return;
    allNodes.push(node.value);
    collectAll(node.left);
    collectAll(node.right);
  }

  collectAll(root);

  // 检查节点数量
  if (allNodes.length !== result.length) {
    return false;
  }

  // 检查所有节点都被包含
  const resultSet = new Set(result);
  return allNodes.every((val) => resultSet.has(val));
}

console.log("Result valid:", validateResult(root, traverse(root)));
```

## 记忆要点

### 核心记忆点

1. **坐标系建立** - 垂直线(左-1右+1)和深度(层+1)
2. **三级排序** - 垂直线 > 深度 > 父节点关系
3. **DFS顺序** - 先左后右的访问顺序是关键
4. **同位置处理** - 父节点的访问顺序决定子节点顺序
5. **范围优化** - 动态计算垂直线范围避免无效遍历

### 算法流程记忆

```javascript
// 1. DFS遍历收集坐标信息
// 2. 多级排序(垂直线->深度->父节点)
// 3. 按排序结果提取值
// 4. 返回最终数组
```

## 扩展思考

### 1. 支持自定义排序规则

```javascript
function customTraverse(root, compareFn) {
  const nodes = [];

  function dfs(node, col, row, parent) {
    if (!node) return;

    nodes.push({
      value: node.value,
      col,
      row,
      parent,
      node,
    });

    dfs(node.left, col - 1, row + 1, node);
    dfs(node.right, col + 1, row + 1, node);
  }

  dfs(root, 0, 0, null);

  // 使用自定义比较函数
  nodes.sort(compareFn);

  return nodes.map((n) => n.value);
}

// 使用示例：按值排序
function byValue(a, b) {
  if (a.col !== b.col) return a.col - b.col;
  if (a.row !== b.row) return a.row - b.row;
  return a.value - b.value; // 同位置按值排序
}
```

### 2. 支持水平遍历

```javascript
function horizontalTraverse(root) {
  if (!root) return [];

  const rowMap = new Map();

  function dfs(node, col, row) {
    if (!node) return;

    if (!rowMap.has(row)) {
      rowMap.set(row, []);
    }

    rowMap.get(row).push([node.value, col]);

    dfs(node.left, col - 1, row + 1);
    dfs(node.right, col + 1, row + 1);
  }

  dfs(root, 0, 0);

  const result = [];
  const sortedRows = Array.from(rowMap.keys()).sort((a, b) => a - b);

  for (const row of sortedRows) {
    const nodes = rowMap.get(row);
    nodes.sort((a, b) => a[1] - b[1]); // 按列排序
    result.push(...nodes.map(([val]) => val));
  }

  return result;
}
```

### 3. 支持对角线遍历

```javascript
function diagonalTraverse(root) {
  if (!root) return [];

  const diagonalMap = new Map();

  function dfs(node, col, row) {
    if (!node) return;

    // 对角线索引 = col + row
    const diagonal = col + row;

    if (!diagonalMap.has(diagonal)) {
      diagonalMap.set(diagonal, []);
    }

    diagonalMap.get(diagonal).push({
      value: node.value,
      col,
      row,
    });

    dfs(node.left, col - 1, row + 1);
    dfs(node.right, col + 1, row + 1);
  }

  dfs(root, 0, 0);

  const result = [];
  const sortedDiagonals = Array.from(diagonalMap.keys()).sort((a, b) => a - b);

  for (const diag of sortedDiagonals) {
    const nodes = diagonalMap.get(diag);
    // 同对角线按列排序
    nodes.sort((a, b) => a.col - b.col);
    result.push(...nodes.map((n) => n.value));
  }

  return result;
}
```

### 4. 支持层次统计

```javascript
function traverseWithStats(root) {
  if (!root) return { result: [], stats: {} };

  const nodes = [];
  const stats = {
    totalNodes: 0,
    maxDepth: 0,
    columnRange: [0, 0],
    nodesPerColumn: new Map(),
    nodesPerRow: new Map(),
  };

  function dfs(node, col, row) {
    if (!node) return;

    stats.totalNodes++;
    stats.maxDepth = Math.max(stats.maxDepth, row);
    stats.columnRange[0] = Math.min(stats.columnRange[0], col);
    stats.columnRange[1] = Math.max(stats.columnRange[1], col);

    // 统计每列节点数
    stats.nodesPerColumn.set(col, (stats.nodesPerColumn.get(col) || 0) + 1);
    stats.nodesPerRow.set(row, (stats.nodesPerRow.get(row) || 0) + 1);

    nodes.push([node.value, col, row]);

    dfs(node.left, col - 1, row + 1);
    dfs(node.right, col + 1, row + 1);
  }

  dfs(root, 0, 0);

  nodes.sort((a, b) => {
    if (a[1] !== b[1]) return a[1] - b[1];
    return a[2] - b[2];
  });

  return {
    result: nodes.map(([val]) => val),
    stats,
  };
}
```

### 5. 支持可视化输出

```javascript
function visualizeTraversal(root) {
  if (!root) return "";

  const grid = new Map();
  let minCol = 0;
  let maxCol = 0;
  let maxRow = 0;

  function dfs(node, col, row) {
    if (!node) return;

    minCol = Math.min(minCol, col);
    maxCol = Math.max(maxCol, col);
    maxRow = Math.max(maxRow, row);

    if (!grid.has(row)) {
      grid.set(row, new Map());
    }
    grid.get(row).set(col, node.value);

    dfs(node.left, col - 1, row + 1);
    dfs(node.right, col + 1, row + 1);
  }

  dfs(root, 0, 0);

  // 构建可视化字符串
  let result = "";
  for (let row = 0; row <= maxRow; row++) {
    let line = "";
    for (let col = minCol; col <= maxCol; col++) {
      if (grid.has(row) && grid.get(row).has(col)) {
        line += grid.get(row).get(col).toString().padStart(3);
      } else {
        line += "   ";
      }
    }
    result += `${line.trim()}\n`;
  }

  return result;
}

// 使用示例
console.log(visualizeTraversal(root));
//   2
// 4   1   3
// 7     5     6
//               8
```

## 复习检查清单

- [ ] 理解垂直遍历的坐标系统和排序规则
- [ ] 掌握DFS遍历和坐标计算的方法
- [ ] 熟练处理同位置多节点的排序问题
- [ ] 理解三级排序的优先级和实现
- [ ] 能够处理各种特殊树结构的遍历
- [ ] 掌握不同算法方案的时空复杂度
- [ ] 了解内存优化和性能优化技巧
- [ ] 熟悉二叉树遍历的各种变体
- [ ] 能够扩展到其他方向的遍历算法
- [ ] 理解在实际应用中的使用场景
