# Day 07 复习文档

## 题目描述

实现一个类似 **Express.js 的中间件系统**，要求：

- 支持链式调用的中间件函数
- 区分普通中间件和错误处理中间件
- 支持异步操作和错误传播
- 通过 next() 函数控制执行流程

本题考查 **设计模式**、**异步流程控制** 和 **错误处理机制** 的综合应用。

## 核心知识点

### 1. 中间件模式核心概念

- **洋葱模型**: 请求从外到内，响应从内到外，形成洋葱式的执行流程
- **责任链模式**: 每个中间件处理特定逻辑后传递给下一个中间件
- **控制反转**: 通过 next() 函数控制执行流程，实现非阻塞式调用
- **生命周期管理**: 中间件可以在请求前后执行逻辑

### 2. 函数签名区分策略

```javascript
// 普通中间件：2 个参数 (req, next)
function normalMiddleware(req, next) {
  console.log("Processing request:", req.url);
  next(); // 继续下一个中间件
}

// 错误处理中间件：3 个参数 (error, req, next)
function errorMiddleware(error, req, next) {
  console.error("Error occurred:", error.message);
  next(); // 可以选择处理错误或继续传播
}
```

### 3. 错误处理机制

- **同步错误**: 使用 try-catch 捕获
- **异步错误**: 使用 Promise.catch 或 async/await 处理
- **错误传播**: 通过 next(error) 将错误传递给错误处理中间件
- **错误恢复**: 错误中间件可以选择处理错误或继续传播

### 4. 异步流程控制

```javascript
// 支持 Promise 返回的中间件
async function asyncMiddleware(req, next) {
  try {
    await someAsyncOperation();
    next();
  } catch (error) {
    next(error); // 将错误传播给错误处理中间件
  }
}
```

## 代码实现

```javascript
export default class Middleware {
  cbHandlers = []; // 普通中间件存储
  errHandlers = []; // 错误处理中间件存储

  // 注册中间件，根据参数个数自动分类
  use(func) {
    if (func.length === 2) {
      this.cbHandlers.push(func);
    }
    if (func.length === 3) {
      this.errHandlers.push(func);
    }
  }

  // 执行中间件链
  async run(req) {
    let index = 0;

    // 创建 next 函数，支持错误传播
    const next = async (error) => {
      if (error) {
        // 有错误时，查找并执行错误处理中间件
        return this.runErrorHandlers(error, req);
      }

      // 检查是否还有中间件需要执行
      if (index >= this.cbHandlers.length) {
        return; // 所有中间件执行完毕
      }

      const middleware = this.cbHandlers[index++];

      try {
        // 支持同步和异步中间件
        const result = middleware(req, next);

        // 如果返回 Promise，等待其完成
        if (result && typeof result.then === "function") {
          await result;
        }
      } catch (syncError) {
        // 捕获同步错误并传播
        await next(syncError);
      }
    };

    // 开始执行第一个中间件
    await next();
  }

  // 执行错误处理中间件
  async runErrorHandlers(error, req) {
    let errorIndex = 0;

    const nextError = async (err) => {
      // 如果没有传入新错误，继续传播原错误
      const currentError = err || error;

      // 检查是否还有错误处理中间件
      if (errorIndex >= this.errHandlers.length) {
        // 没有更多错误处理中间件，抛出未处理的错误
        throw currentError;
      }

      const errorHandler = this.errHandlers[errorIndex++];

      try {
        const result = errorHandler(currentError, req, nextError);

        if (result && typeof result.then === "function") {
          await result;
        }
      } catch (handlerError) {
        // 错误处理中间件本身出错，继续传播
        await nextError(handlerError);
      }
    };

    await nextError();
  }
}

// 增强版实现：支持更多特性
class AdvancedMiddleware extends Middleware {
  constructor() {
    super();
    this.metadata = new Map(); // 存储中间件元数据
  }

  // 支持中间件命名和条件执行
  use(func, options = {}) {
    const { name, condition, priority = 0 } = options;

    // 存储元数据
    if (name) {
      this.metadata.set(func, { name, condition, priority });
    }

    // 根据优先级插入中间件
    if (func.length === 2) {
      this.insertByPriority(this.cbHandlers, func, priority);
    } else if (func.length === 3) {
      this.insertByPriority(this.errHandlers, func, priority);
    }
  }

  // 按优先级插入中间件
  insertByPriority(handlers, func, priority) {
    const index = handlers.findIndex((handler) => {
      const meta = this.metadata.get(handler);
      return meta && meta.priority < priority;
    });

    if (index === -1) {
      handlers.push(func);
    } else {
      handlers.splice(index, 0, func);
    }
  }

  // 支持条件执行的中间件运行
  async run(req) {
    let index = 0;

    const next = async (error) => {
      if (error) {
        return this.runErrorHandlers(error, req);
      }

      // 跳过不满足条件的中间件
      while (index < this.cbHandlers.length) {
        const middleware = this.cbHandlers[index++];
        const meta = this.metadata.get(middleware);

        // 检查执行条件
        if (meta && meta.condition && !meta.condition(req)) {
          continue;
        }

        try {
          const result = middleware(req, next);
          if (result && typeof result.then === "function") {
            await result;
          }
          break;
        } catch (syncError) {
          await next(syncError);
          break;
        }
      }
    };

    await next();
  }

  // 移除指定的中间件
  remove(name) {
    this.cbHandlers = this.cbHandlers.filter((handler) => {
      const meta = this.metadata.get(handler);
      if (meta && meta.name === name) {
        this.metadata.delete(handler);
        return false;
      }
      return true;
    });

    this.errHandlers = this.errHandlers.filter((handler) => {
      const meta = this.metadata.get(handler);
      if (meta && meta.name === name) {
        this.metadata.delete(handler);
        return false;
      }
      return true;
    });
  }

  // 获取中间件信息
  getMiddlewareInfo() {
    const info = {
      normal: this.cbHandlers.map((handler) => {
        const meta = this.metadata.get(handler);
        return {
          name: meta?.name || "anonymous",
          priority: meta?.priority || 0,
          hasCondition: !!meta?.condition,
        };
      }),
      error: this.errHandlers.map((handler) => {
        const meta = this.metadata.get(handler);
        return {
          name: meta?.name || "anonymous",
          priority: meta?.priority || 0,
        };
      }),
    };
    return info;
  }
}
```

## 算法分析

- **时间复杂度**: O(n) - n 为中间件的总数
- **空间复杂度**: O(n) - 存储中间件函数和调用栈
- **特点**: 支持异步执行、错误传播、条件执行

## 关键技术点

### 1. 参数长度判断技巧

```javascript
// 利用 Function.length 属性区分中间件类型
function.length === 2  // 普通中间件 (req, next)
function.length === 3  // 错误中间件 (error, req, next)

// 注意：Function.length 不包括剩余参数和默认参数
const func = (a, b = 1, ...rest) => {} // func.length === 1
```

### 2. 异步流程控制模式

```javascript
// Promise 链式调用
async function next(error) {
  if (error) return handleError(error);

  const middleware = getNextMiddleware();
  try {
    const result = middleware(req, next);

    // 检查是否返回 Promise
    if (result && typeof result.then === "function") {
      await result;
    }
  } catch (error) {
    await next(error);
  }
}
```

### 3. 错误边界设计

```javascript
// 错误处理的三个层次：
// 1. 中间件内部错误处理
// 2. 错误中间件处理
// 3. 全局错误处理（抛出未捕获错误）

try {
  await middleware(req, next);
} catch (error) {
  await runErrorHandlers(error, req);
} finally {
  // 清理资源
}
```

### 4. 洋葱模型实现

```javascript
// 前置处理
function authMiddleware(req, next) {
  console.log("Auth: before");

  // 继续执行下一个中间件
  const result = next();

  // 后置处理（如果 next 返回 Promise）
  if (result && result.then) {
    return result.then(() => {
      console.log("Auth: after");
    });
  }

  console.log("Auth: after");
}
```

### 5. 常见陷阱和坑点

- **忘记调用 next()**: 导致中间件链中断
- **错误处理遗漏**: 异步错误没有正确捕获
- **重复调用 next()**: 可能导致中间件重复执行
- **this 绑定问题**: 中间件中 this 指向问题
- **内存泄漏**: 长时间运行的中间件没有清理资源

## 使用示例

```javascript
const app = new Middleware();

// 注册日志中间件
app.use((req, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
  next();
});

// 注册认证中间件
app.use(async (req, next) => {
  try {
    const token = req.headers.authorization;
    req.user = await validateToken(token);
    next();
  } catch (error) {
    next(error); // 传播认证错误
  }
});

// 注册业务逻辑中间件
app.use((req, next) => {
  if (req.url === "/api/users") {
    req.data = { users: ["Alice", "Bob", "Charlie"] };
  }
  next();
});

// 注册错误处理中间件
app.use((error, req, next) => {
  console.error("Error:", error.message);

  if (error.code === "AUTH_FAILED") {
    req.status = 401;
    req.body = { error: "Unauthorized" };
  } else {
    req.status = 500;
    req.body = { error: "Internal Server Error" };
  }

  next(); // 继续处理或不调用 next() 终止错误传播
});

// 执行中间件链
const request = {
  method: "GET",
  url: "/api/users",
  headers: { authorization: "Bearer token123" },
};

app.run(request).catch((error) => {
  console.error("Unhandled error:", error);
});

// 高级用法：条件中间件
const advancedApp = new AdvancedMiddleware();

// 仅对 API 路由执行的中间件
advancedApp.use(
  (req, next) => {
    console.log("API middleware executed");
    next();
  },
  {
    name: "api-only",
    condition: (req) => req.url.startsWith("/api"),
    priority: 10,
  },
);

// 高优先级的安全中间件
advancedApp.use(
  (req, next) => {
    req.headers["x-security"] = "enabled";
    next();
  },
  {
    name: "security",
    priority: 100,
  },
);

// 移除特定中间件
advancedApp.remove("api-only");

// 查看中间件信息
console.log(advancedApp.getMiddlewareInfo());

// 异步中间件示例
app.use(async (req, next) => {
  // 模拟数据库查询
  const data = await new Promise((resolve) => {
    setTimeout(() => resolve({ id: 1, name: "User" }), 100);
  });

  req.userData = data;
  next();
});

// 错误中间件示例
app.use((error, req, next) => {
  // 错误日志记录
  logError(error, req);

  // 根据错误类型设置响应
  if (error instanceof ValidationError) {
    req.status = 400;
    req.body = { error: "Validation failed", details: error.details };
  } else if (error instanceof AuthError) {
    req.status = 401;
    req.body = { error: "Authentication required" };
  } else {
    req.status = 500;
    req.body = { error: "Internal server error" };
  }

  // 不调用 next()，终止错误传播
});

// 最终处理中间件
app.use((req, next) => {
  // 设置默认响应
  if (!req.status) {
    req.status = 200;
    req.body = req.data || { message: "OK" };
  }
  next();
});
```

## 记忆要点

### 核心记忆点

1. **函数长度判断** - 通过 Function.length 区分中间件类型
2. **异步流程控制** - 支持 Promise 和 async/await
3. **错误传播机制** - next(error) 触发错误处理流程
4. **洋葱模型** - 请求进入和响应返回的双向处理
5. **责任链模式** - 每个中间件处理特定职责后传递控制权

### 执行顺序记忆

```javascript
// 1. 注册中间件（根据参数个数分类存储）
// 2. 开始执行（创建 next 函数）
// 3. 顺序调用（支持同步/异步）
// 4. 错误处理（error 参数存在时）
// 5. 完成或抛出（所有中间件执行完毕）
```

## 扩展思考

### 1. 支持中间件优先级

```javascript
class PriorityMiddleware extends Middleware {
  use(func, priority = 0) {
    const middleware = { func, priority };

    if (func.length === 2) {
      this.insertSorted(this.cbHandlers, middleware);
    } else if (func.length === 3) {
      this.insertSorted(this.errHandlers, middleware);
    }
  }

  insertSorted(handlers, middleware) {
    const index = handlers.findIndex(
      (item) => item.priority < middleware.priority,
    );
    if (index === -1) {
      handlers.push(middleware);
    } else {
      handlers.splice(index, 0, middleware);
    }
  }

  async run(req) {
    let index = 0;
    const handlers = this.cbHandlers.map((item) => item.func);

    const next = async (error) => {
      if (error) return this.runErrorHandlers(error, req);
      if (index >= handlers.length) return;

      const middleware = handlers[index++];
      try {
        await middleware(req, next);
      } catch (err) {
        await next(err);
      }
    };

    await next();
  }
}
```

### 2. 支持中间件分组

```javascript
class GroupedMiddleware extends Middleware {
  constructor() {
    super();
    this.groups = new Map();
  }

  group(name) {
    if (!this.groups.has(name)) {
      this.groups.set(name, new Middleware());
    }
    return this.groups.get(name);
  }

  async run(req, groupName) {
    if (groupName && this.groups.has(groupName)) {
      return this.groups.get(groupName).run(req);
    }

    // 运行默认中间件
    return super.run(req);
  }
}

// 使用示例
const app = new GroupedMiddleware();

// API 组中间件
const apiGroup = app.group("api");
apiGroup.use((req, next) => {
  console.log("API middleware");
  next();
});

// 认证组中间件
const authGroup = app.group("auth");
authGroup.use((req, next) => {
  console.log("Auth middleware");
  next();
});

// 运行特定组
await app.run(request, "api");
```

### 3. 支持中间件缓存

```javascript
class CachedMiddleware extends Middleware {
  constructor() {
    super();
    this.cache = new Map();
    this.cacheConfig = new Map();
  }

  use(func, options = {}) {
    super.use(func);

    if (options.cache) {
      this.cacheConfig.set(func, {
        ttl: options.cache.ttl || 60000, // 默认1分钟
        key: options.cache.key || ((req) => req.url),
      });
    }
  }

  async run(req) {
    const cacheKey = this.getCacheKey(req);

    if (cacheKey && this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < cached.ttl) {
        Object.assign(req, cached.data);
        return;
      }
    }

    const originalReq = { ...req };
    await super.run(req);

    // 缓存结果
    if (cacheKey) {
      this.cache.set(cacheKey, {
        data: { ...req },
        timestamp: Date.now(),
        ttl: this.getCacheTTL(req),
      });
    }
  }

  getCacheKey(req) {
    for (const [func, config] of this.cacheConfig) {
      if (this.cbHandlers.includes(func)) {
        return config.key(req);
      }
    }
    return null;
  }
}
```

### 4. 支持中间件依赖注入

```javascript
class DIMiddleware extends Middleware {
  constructor() {
    super();
    this.container = new Map();
  }

  register(name, factory) {
    this.container.set(name, {
      factory,
      instance: null,
      singleton: true,
    });
  }

  resolve(name) {
    if (!this.container.has(name)) {
      throw new Error(`Service ${name} not found`);
    }

    const service = this.container.get(name);

    if (service.singleton && service.instance) {
      return service.instance;
    }

    const instance = service.factory();
    if (service.singleton) {
      service.instance = instance;
    }

    return instance;
  }

  async run(req) {
    // 注入依赖到请求对象
    req.get = (name) => this.resolve(name);

    return super.run(req);
  }
}

// 使用示例
const app = new DIMiddleware();

// 注册服务
app.register("logger", () => new Logger());
app.register("db", () => new Database());

// 使用依赖注入的中间件
app.use((req, next) => {
  const logger = req.get("logger");
  const db = req.get("db");

  logger.info("Processing request");
  req.data = db.query("SELECT * FROM users");
  next();
});
```

### 5. 支持中间件热重载

```javascript
class HotReloadMiddleware extends Middleware {
  constructor() {
    super();
    this.watchedFiles = new Set();
    this.fileMiddlewareMap = new Map();
  }

  useFromFile(filePath, options = {}) {
    this.watchFile(filePath);

    const middleware = require(filePath);
    this.fileMiddlewareMap.set(filePath, middleware);

    return super.use(middleware, options);
  }

  watchFile(filePath) {
    if (this.watchedFiles.has(filePath)) return;

    this.watchedFiles.add(filePath);

    if (typeof window === "undefined") {
      // Node.js 环境
      const fs = require("node:fs");
      fs.watchFile(filePath, () => {
        this.reloadMiddleware(filePath);
      });
    }
  }

  reloadMiddleware(filePath) {
    try {
      // 清除 require 缓存
      delete require.cache[require.resolve(filePath)];

      // 重新加载中间件
      const newMiddleware = require(filePath);
      const oldMiddleware = this.fileMiddlewareMap.get(filePath);

      // 替换中间件
      const index = this.cbHandlers.indexOf(oldMiddleware);
      if (index !== -1) {
        this.cbHandlers[index] = newMiddleware;
      }

      this.fileMiddlewareMap.set(filePath, newMiddleware);

      console.log(`Middleware reloaded: ${filePath}`);
    } catch (error) {
      console.error(`Failed to reload middleware: ${filePath}`, error);
    }
  }
}
```

## 复习检查清单

- [ ] 理解中间件模式和洋葱模型的原理
- [ ] 掌握通过函数参数个数区分中间件类型
- [ ] 熟练处理同步和异步中间件执行
- [ ] 理解错误传播和处理机制
- [ ] 掌握 next() 函数的正确使用方法
- [ ] 了解责任链模式在中间件中的应用
- [ ] 能够处理复杂的异步流程控制
- [ ] 熟悉中间件系统的扩展和优化策略
- [ ] 理解在实际项目中的应用场景
- [ ] 掌握调试和性能优化的技巧

  start(req) {
  let idx = 0,
  errIdx = 0
  const that = this

      function next(nextErr) {
        const args = [req, next]
        let func = null

        if (nextErr) {
          func = that.errHandlers[errIdx++]
          args.unshift(nextErr)
        } else {
          func = that.cbHandlers[idx++]
        }
        try {
          func && Promise.resolve(func(...args)).catch((error) => next(error))
        } catch (error) {
          next(error)
        }
      }

      next()

  }
  }

```

## 🧠 算法分析

### 核心思路

1. **函数分类**：根据参数数量区分普通中间件和错误处理中间件
2. **顺序执行**：普通中间件按注册顺序执行
3. **错误跳转**：出现错误时跳过普通中间件，执行错误处理中间件
4. **异步支持**：使用 Promise 包装支持异步中间件

### 执行流程

```

start() → next() → 中间件1 → next() → 中间件2 → next() → ...
↓ error
跳过普通中间件 → 错误处理中间件

````

### 时间复杂度

- **O(n)**：其中 n 是中间件数量，顺序执行

### 空间复杂度

- **O(n)**：存储中间件函数数组
- **O(d)**：递归调用栈深度

## 🔍 关键技术点

### 1. 函数参数数量检测

```javascript
// 利用 function.length 属性区分中间件类型
if (func.length === 2) this.cbHandlers.push(func) // 普通中间件
if (func.length === 3) this.errHandlers.push(func) // 错误处理中间件
````

### 2. 递归执行机制

```javascript
function next(nextErr) {
  // 根据是否有错误选择不同的处理队列
  if (nextErr) {
    func = that.errHandlers[errIdx++]; // 错误处理中间件
    args.unshift(nextErr); // 错误作为第一个参数
  } else {
    func = that.cbHandlers[idx++]; // 普通中间件
  }
}
```

### 3. 同步和异步错误处理

```javascript
try {
  // Promise.resolve 包装支持异步中间件
  func && Promise.resolve(func(...args)).catch((error) => next(error));
} catch (error) {
  // 捕获同步错误
  next(error);
}
```

### 4. 闭包保持状态

```javascript
const that = this; // 保持对实例的引用
const idx = 0;
const errIdx = 0; // 维护执行索引
```

## 🧪 使用示例

### 基础中间件链

```javascript
const middleware = new Middleware();

middleware.use((req, next) => {
  req.a = 1;
  next();
});

middleware.use((req, next) => {
  req.b = 2;
  next();
});

middleware.use((req, next) => {
  console.log(req); // {a: 1, b: 2}
});

middleware.start({});
```

### 错误处理示例

```javascript
const middleware = new Middleware();

// 抛出错误
middleware.use((req, next) => {
  req.a = 1;
  throw new Error("something wrong");
  // 或者 next(new Error('something wrong'))
});

// 这个中间件会被跳过
middleware.use((req, next) => {
  req.b = 2;
  next();
});

// 错误处理中间件
middleware.use((error, req, next) => {
  console.log(error.message); // 'something wrong'
  console.log(req); // {a: 1}
});

middleware.start({});
```

### 异步中间件

```javascript
middleware.use(async (req, next) => {
  req.data = await fetchData();
  next();
});

middleware.use((req, next) => {
  console.log(req.data); // 异步获取的数据
  next();
});
```

### 条件执行

```javascript
middleware.use((req, next) => {
  if (req.user) {
    next(); // 继续执行
  } else {
    next(new Error("Unauthorized")); // 跳转到错误处理
  }
});
```

## 💡 关键记忆点

1. **函数签名区分**：通过 `func.length` 区分普通和错误处理中间件
2. **执行顺序**：普通中间件顺序执行，错误时跳转到错误处理中间件
3. **异步支持**：使用 `Promise.resolve()` 包装支持异步函数
4. **错误传播**：同步错误用 try-catch，异步错误用 Promise.catch
5. **索引维护**：分别维护普通中间件和错误处理中间件的执行索引
6. **递归执行**：通过 `next()` 函数实现递归调用链

## 🤔 扩展思考

### 与 Express.js 的关系

- **相同点**：中间件模式、错误处理机制、next() 控制流程
- **不同点**：Express 支持路由匹配、更复杂的错误处理

### 洋葱模型

```javascript
// 真正的洋葱模型需要支持"回程"
middleware.use(async (req, next) => {
  console.log("进入");
  await next();
  console.log("离开"); // 这需要额外的实现
});
```

### 应用场景

- **身份验证**：检查用户登录状态
- **日志记录**：记录请求信息
- **错误处理**：统一处理应用错误
- **数据转换**：处理请求/响应数据
- **性能监控**：统计执行时间

### 优化方向

- **错误恢复**：支持从错误中恢复继续执行
- **并行执行**：支持并行执行某些中间件
- **条件跳过**：支持条件性跳过中间件
- **路由支持**：添加路径匹配功能

## 📝 复习要点

- [ ] 理解中间件模式和责任链模式
- [ ] 掌握通过函数参数数量区分中间件类型
- [ ] 熟悉同步和异步错误的处理方式
- [ ] 理解 next() 函数的递归调用机制
- [ ] 掌握错误时的执行流程跳转
- [ ] 能够实现支持异步操作的中间件系统
