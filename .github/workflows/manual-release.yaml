name: 手动 Release

on:
  # 只保留手动触发，移除自动触发
  workflow_dispatch:
    inputs:
      version_type:
        description: '版本类型'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      custom_version:
        description: '自定义版本号 (可选，格式: v1.2.3)'
        required: false
        type: string
      skip_tests:
        description: '跳过测试检查'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

jobs:
  manual-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: 安装依赖
        run: pnpm install --frozen-lockfile

      - name: 运行开发流程和构建
        if: ${{ !github.event.inputs.skip_tests }}
        run: |
          pnpm run dev

      - name: 仅构建（跳过测试时）
        if: ${{ github.event.inputs.skip_tests }}
        run: |
          pnpm run build

      - name: 统计项目信息
        id: stats
        run: |
          # 统计题目数量
          TOTAL_DAYS=$(find problems/days -type d -name "Day *" | wc -l | tr -d ' ')
          echo "total-days=$TOTAL_DAYS" >> $GITHUB_OUTPUT

          # 统计贡献者（排除机器人账户，使用 mailmap 去重相同身份）
          CONTRIBUTORS=$(git shortlog -sne --all | grep -v -E "(GitHub Action|action@github\.com|xier164.*gitee\.com)" | wc -l | tr -d ' ')
          echo "contributors=$CONTRIBUTORS" >> $GITHUB_OUTPUT

      - name: 生成版本号
        id: version
        run: |
          # 函数：验证版本号格式
          validate_version() {
            local version=$1
            if [[ $version =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+(\.[a-zA-Z0-9]+)*)?$ ]]; then
              return 0
            else
              return 1
            fi
          }

          # 函数：解析版本号
          parse_version() {
            local version=$1
            # 移除 v 前缀
            version=${version#v}
            # 分离主版本和预发布标识
            if [[ $version == *"-"* ]]; then
              local base_version=${version%-*}
              local prerelease=${version#*-}
            else
              local base_version=$version
              local prerelease=""
            fi
            
            # 解析主版本号
            IFS='.' read -r MAJOR MINOR PATCH <<< "$base_version"
            
            # 验证解析结果
            if [[ ! $MAJOR =~ ^[0-9]+$ ]] || [[ ! $MINOR =~ ^[0-9]+$ ]] || [[ ! $PATCH =~ ^[0-9]+$ ]]; then
              echo "错误：无法解析版本号 $1"
              exit 1
            fi
            
            echo "$MAJOR $MINOR $PATCH $prerelease"
          }

          if [ -n "${{ github.event.inputs.custom_version }}" ]; then
            NEW_VERSION="${{ github.event.inputs.custom_version }}"
            echo "使用自定义版本号: $NEW_VERSION"
            
            # 验证自定义版本号格式
            if ! validate_version "$NEW_VERSION"; then
              echo "错误：自定义版本号格式不正确"
              echo "支持的格式: v1.2.3 或 v1.2.3-beta.1"
              exit 1
            fi
          else
            # 获取当前最新版本
            CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null)
            
            if [ -z "$CURRENT_VERSION" ]; then
              # 如果没有任何标签，从 package.json 获取当前版本
              PACKAGE_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "1.0.0")
              CURRENT_VERSION="v$PACKAGE_VERSION"
              echo "没有找到 Git 标签，使用 package.json 版本: $CURRENT_VERSION"
            else
              echo "当前版本: $CURRENT_VERSION"
            fi
            
            # 验证当前版本格式
            if ! validate_version "$CURRENT_VERSION"; then
              echo "警告：当前版本格式不标准，重置为 v1.0.0"
              CURRENT_VERSION="v1.0.0"
            fi
            
            # 解析当前版本
            read -r MAJOR MINOR PATCH PRERELEASE <<< "$(parse_version "$CURRENT_VERSION")"
            
            echo "解析结果: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH, PRERELEASE=$PRERELEASE"
            
            # 根据选择的版本类型递增版本号
            case "${{ github.event.inputs.version_type }}" in
              "major")
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                echo "升级主版本: $MAJOR.0.0"
                ;;
              "minor")
                MINOR=$((MINOR + 1))
                PATCH=0
                echo "升级次版本: $MAJOR.$MINOR.0"
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                echo "升级补丁版本: $MAJOR.$MINOR.$PATCH"
                ;;
              *)
                echo "错误：不支持的版本类型 ${{ github.event.inputs.version_type }}"
                exit 1
                ;;
            esac
            
            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "🏷️ 新版本号: $NEW_VERSION"

          # 验证最终版本号
          if ! validate_version "$NEW_VERSION"; then
            echo "错误：生成的版本号格式不正确: $NEW_VERSION"
            exit 1
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: 检查构建输出
        id: create-release-package
        run: |
          echo "📦 检查构建输出"

          # 检查 dist 目录是否存在
          if [ ! -d "dist" ]; then
            echo "❌ dist 目录不存在，构建可能失败"
            exit 1
          fi

          # 查找构建生成的文件
          TAR_FILE=$(find dist -name "*.tar.gz" | head -1)
          ZIP_FILE=$(find dist -name "*.zip" | head -1)
          RELEASE_NOTES=$(find dist -name "release-notes-*.md" | head -1)

          if [ -z "$TAR_FILE" ] || [ -z "$ZIP_FILE" ]; then
            echo "❌ 未找到构建生成的压缩包"
            ls -la dist/
            exit 1
          fi

          # 获取文件信息
          PACKAGE_NAME=$(basename "$TAR_FILE" .tar.gz)
          TAR_SIZE=$(du -h "$TAR_FILE" | cut -f1)
          ZIP_SIZE=$(du -h "$ZIP_FILE" | cut -f1)
          TAR_SHA256=$(shasum -a 256 "$TAR_FILE" | cut -d' ' -f1)
          ZIP_SHA256=$(shasum -a 256 "$ZIP_FILE" | cut -d' ' -f1)

          echo "✅ 发布包检查完成:"
          echo "📦 $(basename "$TAR_FILE") ($TAR_SIZE)"
          echo "📦 $(basename "$ZIP_FILE") ($ZIP_SIZE)"
          echo ""
          echo "🔐 SHA256 校验码:"
          echo "tar.gz: $TAR_SHA256"
          echo "zip: $ZIP_SHA256"

          # 输出到 GitHub Actions
          echo "package-name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
          echo "tar-file=$(basename "$TAR_FILE")" >> $GITHUB_OUTPUT
          echo "zip-file=$(basename "$ZIP_FILE")" >> $GITHUB_OUTPUT
          echo "tar-size=$TAR_SIZE" >> $GITHUB_OUTPUT
          echo "zip-size=$ZIP_SIZE" >> $GITHUB_OUTPUT
          echo "tar-sha256=$TAR_SHA256" >> $GITHUB_OUTPUT
          echo "zip-sha256=$ZIP_SHA256" >> $GITHUB_OUTPUT
          echo "release-notes-file=$RELEASE_NOTES" >> $GITHUB_OUTPUT

      - name: 生成 Release Notes
        id: release-notes
        run: |
          # 检查是否有构建生成的 Release Notes
          RELEASE_NOTES_FILE="${{ steps.create-release-package.outputs.release-notes-file }}"

          if [ -n "$RELEASE_NOTES_FILE" ] && [ -f "$RELEASE_NOTES_FILE" ]; then
            echo "📝 使用构建生成的 Release Notes: $RELEASE_NOTES_FILE"
            
            # 将构建生成的 Release Notes 复制到标准位置
            cp "$RELEASE_NOTES_FILE" release-notes-output.md
            echo "release-notes-file=release-notes-output.md" >> $GITHUB_OUTPUT
          else
            echo "📝 构建的 Release Notes 不存在，生成默认 Release Notes"
            
            # 获取最新的更新文档作为备用
            LATEST_UPDATE=$(find updates -name "*.md" -not -name "README.md" | sort -r | head -1)

            # 生成默认 Release Notes
            cat > release-notes.md << 'EOF'
          # 📚 506实验室每日一题 Release

          ## 🎯 本次更新概览

          EOF

            # 如果有更新文档，包含其内容
            if [ -f "$LATEST_UPDATE" ]; then
              echo "从 $LATEST_UPDATE 生成 Release Notes..."
              echo "" >> release-notes.md
              echo "## 📝 详细更新内容" >> release-notes.md
              echo "" >> release-notes.md
              cat "$LATEST_UPDATE" >> release-notes.md
              echo "" >> release-notes.md
            fi

            # 添加项目统计
            echo "## 📊 项目统计" >> release-notes.md
            echo "" >> release-notes.md
            echo "- 📚 总题目数量: **${{ steps.stats.outputs.total-days }}** 题" >> release-notes.md
            echo "- 👥 贡献者数量: **${{ steps.stats.outputs.contributors }}** 人" >> release-notes.md
            echo "" >> release-notes.md

            # 添加发布包信息
            echo "## 📦 发布包下载" >> release-notes.md
            echo "" >> release-notes.md
            echo "本版本提供以下发布包（仅包含题目文件）：" >> release-notes.md
            echo "" >> release-notes.md
            echo "| 格式 | 文件名 | 大小 | SHA256 |" >> release-notes.md
            echo "|------|--------|------|--------|" >> release-notes.md
            echo "| ZIP | \`${{ steps.create-release-package.outputs.zip-file }}\` | ${{ steps.create-release-package.outputs.zip-size }} | \`${{ steps.create-release-package.outputs.zip-sha256 }}\` |" >> release-notes.md
            echo "| TAR.GZ | \`${{ steps.create-release-package.outputs.tar-file }}\` | ${{ steps.create-release-package.outputs.tar-size }} | \`${{ steps.create-release-package.outputs.tar-sha256 }}\` |" >> release-notes.md
            echo "" >> release-notes.md

            # 设置文件输出而不是多行字符串
            echo "release-notes-file=release-notes.md" >> $GITHUB_OUTPUT
          fi

      - name: 更新 CHANGELOG
        id: update-changelog
        run: |
          # 获取最新的更新文档
          LATEST_UPDATE=$(find updates -name "*.md" -not -name "README.md" | sort -r | head -1)

          # 更新 CHANGELOG.md
          if [ -f "CHANGELOG.md" ]; then
            # 获取当前日期
            CURRENT_DATE=$(date +%Y-%m-%d)
            
            # 创建临时文件
            temp_changelog="changelog-temp.md"
            
            # 查找 [未发布] 行的位置
            unreleased_line=$(grep -n "## \[未发布\]" CHANGELOG.md | cut -d: -f1)
            
            if [ -n "$unreleased_line" ]; then
              # 复制文件头部分
              head -n $((unreleased_line + 5)) CHANGELOG.md > $temp_changelog
              
              # 添加新版本条目
              echo "" >> $temp_changelog
              echo "## [${{ steps.version.outputs.version }}] - $CURRENT_DATE" >> $temp_changelog
              echo "" >> $temp_changelog
              
              # 如果有最新更新文档，直接添加其内容
              if [ -f "$LATEST_UPDATE" ]; then
                echo "### 更新内容" >> $temp_changelog
                echo "" >> $temp_changelog
                # 获取更新文档的标题
                echo "**$(head -1 "$LATEST_UPDATE" | sed 's/^# //')**" >> $temp_changelog
                echo "" >> $temp_changelog
                # 添加更新概述（跳过标题和元信息，提取主要内容）
                sed -n '/## /,$p' "$LATEST_UPDATE" | head -20 | grep -E '^- |^## ' | sed 's/^## /#### /' >> $temp_changelog
                echo "" >> $temp_changelog
                echo "详细信息请查看: [更新文档]($LATEST_UPDATE)" >> $temp_changelog
                echo "" >> $temp_changelog
              else
                # 如果没有更新文档，添加通用条目
                echo "### 更新内容" >> $temp_changelog
                echo "- 手动发布版本 ${{ steps.version.outputs.version }}" >> $temp_changelog
                echo "" >> $temp_changelog
              fi
              
              # 添加其余内容
              tail -n +$((unreleased_line + 6)) CHANGELOG.md >> $temp_changelog
              
              # 替换原文件
              mv $temp_changelog CHANGELOG.md
              
              echo "changelog-updated=true" >> $GITHUB_OUTPUT
            else
              echo "changelog-updated=false" >> $GITHUB_OUTPUT
              echo "警告: CHANGELOG.md 格式不标准，跳过自动更新"
            fi
          else
            echo "changelog-updated=false" >> $GITHUB_OUTPUT
            echo "警告: CHANGELOG.md 不存在，跳过自动更新"
          fi

      - name: 更新 package.json 版本号
        run: |
          # 移除 v 前缀用于 package.json
          VERSION_NUMBER=${{ steps.version.outputs.version }}
          VERSION_NUMBER=${VERSION_NUMBER#v}

          # 获取当前 package.json 中的版本号
          CURRENT_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "1.0.0")

          echo "🔍 版本检查:"
          echo "当前版本: $CURRENT_VERSION"
          echo "目标版本: $VERSION_NUMBER"

          if [ "$CURRENT_VERSION" = "$VERSION_NUMBER" ]; then
            echo "⏭️ 版本号相同，跳过更新"
          else
            echo "🔄 更新版本号..."
            # 直接修改 package.json，避免 npm/pnpm 的版本检查
            if command -v jq >/dev/null 2>&1; then
              # 如果有 jq，使用 jq 修改（更安全）
              jq ".version = \"$VERSION_NUMBER\"" package.json > package.json.tmp && mv package.json.tmp package.json
            else
              # 使用 sed 直接修改
              sed -i.bak "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION_NUMBER\"/" package.json
              rm -f package.json.bak
            fi
            echo "✅ 版本号已更新为: $VERSION_NUMBER"
          fi

      - name: 创建发布分支
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          BRANCH_NAME="release/${{ steps.version.outputs.version }}"

          # 检查远程分支是否存在
          if git ls-remote --heads origin $BRANCH_NAME | grep -q $BRANCH_NAME; then
            echo "⚠️ 远程分支 $BRANCH_NAME 已存在，正在删除..."
            git push origin --delete $BRANCH_NAME || echo "删除远程分支失败，可能已被删除"
          fi

          # 检查本地分支是否存在并删除
          if git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
            echo "⚠️ 本地分支 $BRANCH_NAME 已存在，正在删除..."
            git branch -D $BRANCH_NAME
          fi

          # 创建新分支
          git checkout -b $BRANCH_NAME
          echo "✅ 创建新分支: $BRANCH_NAME"
          echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT
        id: create-branch

      - name: 提交更改到发布分支
        run: |
          git add package.json
          if [ "${{ steps.update-changelog.outputs.changelog-updated }}" = "true" ]; then
            git add CHANGELOG.md
          fi

          # 检查是否有更改需要提交
          if git diff --staged --quiet; then
            echo "⚠️ 没有检测到更改，跳过提交"
          else
            git commit -m "chore: release ${{ steps.version.outputs.version }}

          - 更新 package.json 版本号
          - 更新 CHANGELOG.md 添加版本记录"
            echo "✅ 提交完成"
          fi

          # 强制推送到远程（因为我们已经清理了冲突的分支）
          git push origin ${{ steps.create-branch.outputs.branch-name }}

      - name: 创建或更新 Pull Request
        id: create_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CONTRIB_TOKEN }}
          script: |
            const branchName = '${{ steps.create-branch.outputs.branch-name }}';
            const version = '${{ steps.version.outputs.version }}';

            // 检查是否已有相同的开放PR
            const { data: existingPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branchName}`,
              state: 'open'
            });

            if (existingPRs.length > 0) {
              const existingPR = existingPRs[0];
              console.log(`⚠️ 发现现有的PR #${existingPR.number}: ${existingPR.html_url}`);
              
              // 更新现有PR的描述
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: existingPR.number,
                body: `## 📚 506实验室每日一题 Release (更新)

            ### 🎯 发布内容
            - 版本号更新至 ${version}
            - 更新 CHANGELOG.md
            - 总题目数量: ${{ steps.stats.outputs.total-days }} 天
            - 贡献者数量: ${{ steps.stats.outputs.contributors }} 人

            ### 🔍 自动检查
            此 PR 将自动触发必要的检查：
            - ✅ 代码格式检查 (Lint)
            - ✅ 类型检查 (Type Check)  
            - ✅ 单元测试 (Test)

            ### 📝 下一步
            1. 等待所有检查通过
            2. 合并此 PR 到 main 分支
            3. 自动创建 Git Tag 和 GitHub Release

            ---
            *此 PR 由 GitHub Actions 自动更新于 ${new Date().toISOString()}*`
              });
              
              core.setOutput('pr_number', existingPR.number);
              core.setOutput('pr_url', existingPR.html_url);
              core.setOutput('pr_action', 'updated');
              
              return existingPR.number;
            }

            // 创建新的PR
            const { data: pullRequest } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `🚀 Release ${version}`,
              head: branchName,
              base: 'main',
              body: `## 📚 506实验室每日一题 Release

            ### 🎯 发布内容
            - 版本号更新至 ${version}
            - 更新 CHANGELOG.md
            - 总题目数量: ${{ steps.stats.outputs.total-days }} 天
            - 贡献者数量: ${{ steps.stats.outputs.contributors }} 人

            ### 🔍 自动检查
            此 PR 将自动触发必要的检查：
            - ✅ 代码格式检查 (Lint)
            - ✅ 类型检查 (Type Check)  
            - ✅ 单元测试 (Test)

            ### 📝 下一步
            1. 等待所有检查通过
            2. 合并此 PR 到 main 分支
            3. 自动创建 Git Tag 和 GitHub Release

            ---
            *此 PR 由 GitHub Actions 自动创建*`
            });

            core.setOutput('pr_number', pullRequest.number);
            core.setOutput('pr_url', pullRequest.html_url);
            core.setOutput('pr_action', 'created');

            return pullRequest.number;

      - name: 发布成功通知
        run: |
          echo "✅ Release PR 处理完成!"
          echo ""
          echo "📚 项目: 506实验室每日一题"
          echo "🏷️ 版本: ${{ steps.version.outputs.version }}"
          echo "📊 总题目数: ${{ steps.stats.outputs.total-days }} 天"
          echo "👥 贡献者: ${{ steps.stats.outputs.contributors }} 人"
          echo ""
          echo "📋 下一步操作："
          echo "1. 访问 GitHub PR 页面"
          echo "2. 等待所有 CI 检查通过"
          echo "3. 手动合并 PR 到 main 分支"
          echo "4. 合并后自动创建 Git Tag 和 GitHub Release"
