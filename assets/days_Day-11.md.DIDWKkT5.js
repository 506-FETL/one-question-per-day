import{_ as i,c as a,o as n,ah as l}from"./chunks/framework.CQPaoDZe.js";const c=JSON.parse('{"title":"Day 11","description":"","frontmatter":{},"headers":[],"relativePath":"days/Day-11.md","filePath":"days/Day-11.md","lastUpdated":1755921294000}'),t={name:"days/Day-11.md"};function h(e,s,p,k,d,r){return n(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="day-11" tabindex="-1">Day 11 <a class="header-anchor" href="#day-11" aria-label="Permalink to “Day 11”">​</a></h1><h1 id="fiber-树遍历-提交阶段副作用收集模拟" tabindex="-1">Fiber 树遍历（提交阶段副作用收集模拟） <a class="header-anchor" href="#fiber-树遍历-提交阶段副作用收集模拟" aria-label="Permalink to “Fiber 树遍历（提交阶段副作用收集模拟）”">​</a></h1><h2 id="🧠-背景" tabindex="-1">🧠 背景 <a class="header-anchor" href="#🧠-背景" aria-label="Permalink to “🧠 背景”">​</a></h2><p>在类 React 架构中，UI 更新会经历 <em>render</em>（生成 Fiber 树）与 <em>commit</em>（应用副作用）两个阶段。Fiber 采用一套<strong>链式指针结构</strong>来表示一棵树：</p><table tabindex="0"><thead><tr><th>指针</th><th>含义</th></tr></thead><tbody><tr><td><code>child</code></td><td>第一个子节点（相当于普通树的 children[0]）</td></tr><tr><td><code>sibling</code></td><td>下一个兄弟节点（相当于同层的下一个）</td></tr><tr><td><code>return</code></td><td>指向父节点（回溯用）</td></tr></tbody></table><p>本题聚焦于 <strong>“从根开始，按照先序（父 → 子 → 兄弟）深度优先”</strong> 遍历整棵 Fiber 树，并对每个节点调用一次回调 <code>onCommitUnmount(node)</code>（题意以 <em>unmount</em> 命名，实质上只是一次副作用处理的模拟）。</p><h2 id="🎯-任务" tabindex="-1">🎯 任务 <a class="header-anchor" href="#🎯-任务" aria-label="Permalink to “🎯 任务”">​</a></h2><p>实现函数：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> commitNestedComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FiberNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onCommitUnmount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FiberNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span></span></code></pre></div><p>要求：</p><ol><li>若 <code>root</code> 为 <code>null</code>，直接返回。</li><li>对<strong>每一个节点恰好调用一次</strong> <code>onCommitUnmount</code>，包含根节点。</li><li>遍历顺序： <ul><li>先访问当前节点</li><li>优先进入 <code>child</code> 链</li><li>没有子节点则尝试 <code>sibling</code></li><li>若也没有，则不断沿 <code>return</code> 回溯，直到找到某个祖先的未访问兄弟；若没有则结束。</li></ul></li><li>期望用<strong>迭代</strong>实现（可选），避免递归栈（可用递归但要在说明中写出复杂度）。</li></ol><h2 id="🧩-fibernode-结构-测试中示例" tabindex="-1">🧩 FiberNode 结构（测试中示例） <a class="header-anchor" href="#🧩-fibernode-结构-测试中示例" aria-label="Permalink to “🧩 FiberNode 结构（测试中示例）”">​</a></h2><p>（测试文件里会动态构建树，你无需改动测试里的类定义；下面是简化示意）</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FiberNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FiberNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  sibling</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FiberNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FiberNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 测试里提供了 addChild 辅助方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="🔍-示例" tabindex="-1">🔍 示例 <a class="header-anchor" href="#🔍-示例" aria-label="Permalink to “🔍 示例”">​</a></h2><p>树形（兄弟从左到右添加）：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>       A</span></span>
<span class="line"><span>     / | \\</span></span>
<span class="line"><span>    B  C  D</span></span>
<span class="line"><span>   /      /\\</span></span>
<span class="line"><span>  E      F  G</span></span></code></pre></div><p>指针关系（部分）：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>A.child = B</span></span>
<span class="line"><span>B.sibling = C</span></span>
<span class="line"><span>C.sibling = D</span></span>
<span class="line"><span>B.child = E</span></span>
<span class="line"><span>D.child = F</span></span>
<span class="line"><span>F.sibling = G</span></span></code></pre></div><p>期望遍历顺序（先序 + 兄弟横向）：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>A → B → E → C → D → F → G</span></span></code></pre></div><h2 id="🛠-思路提示-迭代版" tabindex="-1">🛠 思路提示（迭代版） <a class="header-anchor" href="#🛠-思路提示-迭代版" aria-label="Permalink to “🛠 思路提示（迭代版）”">​</a></h2><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FiberNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onCommitUnmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current.child) {            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 先深入子节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.child</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    continue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 2. 没子节点，寻找同层兄弟或向上回溯</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">current.sibling) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.return       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 回溯</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current) current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.sibling </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 兄弟继续</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="⏱-复杂度" tabindex="-1">⏱ 复杂度 <a class="header-anchor" href="#⏱-复杂度" aria-label="Permalink to “⏱ 复杂度”">​</a></h2><table tabindex="0"><thead><tr><th>实现</th><th>时间</th><th>额外空间</th></tr></thead><tbody><tr><td>迭代</td><td>O(N)</td><td>O(1)</td></tr><tr><td>递归</td><td>O(N)</td><td>O(H)（H 为树高度）</td></tr></tbody></table><h2 id="✅-判定标准" tabindex="-1">✅ 判定标准 <a class="header-anchor" href="#✅-判定标准" aria-label="Permalink to “✅ 判定标准”">​</a></h2><p>通过测试需满足：</p><ol><li>顺序正确（与题目 DFS 先序 + 兄弟左→右一致）</li><li>不重复、不遗漏节点</li><li>空树能安全返回</li></ol><h2 id="🔄-可扩展思考" tabindex="-1">🔄 可扩展思考 <a class="header-anchor" href="#🔄-可扩展思考" aria-label="Permalink to “🔄 可扩展思考”">​</a></h2><p>真实 React 提交阶段还会：</p><ul><li>处理不同 effect 标志（Placement / Update / Deletion 等）</li><li>分离“挂载副作用”和“卸载副作用”阶段 你可以在节点上加一个 <code>flags</code> 字段，在遍历时分类处理。</li></ul><h2 id="🧪-建议自测用例" tabindex="-1">🧪 建议自测用例 <a class="header-anchor" href="#🧪-建议自测用例" aria-label="Permalink to “🧪 建议自测用例”">​</a></h2><ol><li>单节点</li><li>只有一条向左/向右的链</li><li>多兄弟 + 部分兄弟有子</li><li>不规则“瘸腿”结构（有的节点只有第二个/第三个孙）</li></ol><p>现在，在 <code>fiberTree.js</code> 中补全 <code>commitNestedComponent</code> 的实现即可。</p><h2 id="代码" tabindex="-1">代码 <a class="header-anchor" href="#代码" aria-label="Permalink to “代码”">​</a></h2><table tabindex="0"><thead><tr><th>类型</th><th>路径</th></tr></thead><tbody><tr><td>JS 答案</td><td>problems/days/Day 11/answer.js</td></tr></tbody></table>`,36)])])}const o=i(t,[["render",h]]);export{c as __pageData,o as default};
