import{_ as l,c as i,o,ah as a}from"./chunks/framework.CQPaoDZe.js";const p=JSON.parse('{"title":"Day 08","description":"","frontmatter":{},"headers":[],"relativePath":"days/Day-08.md","filePath":"days/Day-08.md","lastUpdated":1755921294000}'),r={name:"days/Day-08.md"};function d(t,e,s,c,n,h){return o(),i("div",null,[...e[0]||(e[0]=[a('<h1 id="day-08" tabindex="-1">Day 08 <a class="header-anchor" href="#day-08" aria-label="Permalink to “Day 08”">​</a></h1><h1 id="自定义实现-promise" tabindex="-1">自定义实现 Promise <a class="header-anchor" href="#自定义实现-promise" aria-label="Permalink to “自定义实现 Promise”">​</a></h1><h2 id="题目描述" tabindex="-1">题目描述 <a class="header-anchor" href="#题目描述" aria-label="Permalink to “题目描述”">​</a></h2><p>在 JavaScript 中，Promise 对异步编程的支持非常重要。你的任务是<strong>实现一个与 ES6 原生 Promise 类似的自定义 Promise 类（命名为 <code>MyPromise</code>）</strong>。 你需要完成如下功能：</p><ul><li>状态管理</li><li>基于链式调用的回调处理</li><li>错误捕获与传递</li><li>最终状态的处理（<code>finally</code>）</li><li>静态方法（<code>resolve</code> 和 <code>reject</code>）</li></ul><p>要求不使用原生的 <code>Promise</code> 进行包装，而是通过底层的状态机、回调队列和微任务等机制来独立实现 <code>MyPromise</code> 的行为。</p><h2 id="需求说明" tabindex="-1">需求说明 <a class="header-anchor" href="#需求说明" aria-label="Permalink to “需求说明”">​</a></h2><h3 id="_1-状态管理" tabindex="-1">1. 状态管理 <a class="header-anchor" href="#_1-状态管理" aria-label="Permalink to “1. 状态管理”">​</a></h3><ul><li><p><strong>状态定义</strong><code>MyPromise</code> 必须至少具有三种状态：</p><ul><li><code>pending</code>（等待中）</li><li><code>fulfilled</code>（已成功）</li><li><code>rejected</code>（已拒绝）</li></ul></li><li><p><strong>状态不可逆性</strong> 一旦 Promise 的状态从 <code>pending</code> 转到 <code>fulfilled</code> 或 <code>rejected</code> 后，就不可再改变。</p></li><li><p><strong>结果存储</strong> 除了状态外，需要保存成功时的值或拒绝时的原因，以便在后续的处理链中传递。</p></li></ul><h3 id="_2-构造函数与执行器方法" tabindex="-1">2. 构造函数与执行器方法 <a class="header-anchor" href="#_2-构造函数与执行器方法" aria-label="Permalink to “2. 构造函数与执行器方法”">​</a></h3><ul><li><p>构造函数接收一个执行器函数 <code>executor(resolve, reject)</code>，在构造实例时立即执行。</p></li><li><p><strong>处理异常</strong></p><ul><li>在执行器函数内部若抛出异常，应该捕获并调用 <code>reject</code>，使 Promise 状态变为拒绝。</li></ul></li><li><p><strong>resolve 和 reject 方法</strong></p><ul><li>需要保证当调用 <code>resolve(data)</code> 或 <code>reject(reason)</code> 时，能触发状态改变并通知已注册的回调。</li><li>保证调用多次 <code>resolve</code> 或 <code>reject</code> 不会改变 Promise 的状态（即状态只能从 <code>pending</code> 转换一次）。</li></ul></li></ul><h3 id="_3-链式调用-then-方法" tabindex="-1">3. 链式调用：then 方法 <a class="header-anchor" href="#_3-链式调用-then-方法" aria-label="Permalink to “3. 链式调用：then 方法”">​</a></h3><ul><li><p><strong>回调注册</strong></p><ul><li><code>then</code> 方法接收两个参数：<code>onFulfilled</code>（成功时回调）、<code>onRejected</code>（失败时回调）。</li><li>当 Promise 状态改变后，自动依次按注册顺序执行对应的回调函数。</li></ul></li><li><p><strong>返回新 Promise</strong></p><ul><li>每次 <code>then</code> 调用都应返回一个新的 Promise，从而实现链式调用。</li><li>在链式调用中，若对应状态回调不存在，则需要进行“透传”： <ul><li>成功状态直接将原始值传递；</li><li>失败状态直接将拒因传递。</li></ul></li></ul></li><li><p><strong>错误传递</strong></p><ul><li>回调函数中的同步异常必须被捕获，确保错误能传递给链条中的下一个 <code>catch</code> 或对应的错误回调。</li></ul></li></ul><h3 id="_4-错误处理-catch-方法" tabindex="-1">4. 错误处理：catch 方法 <a class="header-anchor" href="#_4-错误处理-catch-方法" aria-label="Permalink to “4. 错误处理：catch 方法”">​</a></h3><ul><li>实现 <code>catch</code> 方法，其实际上等同于调用 <code>then(undefined, onRejected)</code>。</li><li>确保在链式调用中，只要有异常被抛出，能够进入错误分支处理。</li></ul><h3 id="_5-最终处理-finally-方法" tabindex="-1">5. 最终处理：finally 方法 <a class="header-anchor" href="#_5-最终处理-finally-方法" aria-label="Permalink to “5. 最终处理：finally 方法”">​</a></h3><ul><li><strong>无论成功或失败</strong><ul><li>无论 Promise 的状态如何，<code>finally</code> 中的回调总会被执行。</li></ul></li><li><strong>数据透传</strong><ul><li>若 <code>finally</code> 回调不返回新的 Promise，则应原样传递之前的结果或错误。</li><li>若回调返回新的 Promise，则需要等待该 Promise 解析完成后，再将原始结果或错误传递出去。</li></ul></li></ul><h3 id="_6-异步执行机制" tabindex="-1">6. 异步执行机制 <a class="header-anchor" href="#_6-异步执行机制" aria-label="Permalink to “6. 异步执行机制”">​</a></h3><ul><li><strong>回调的异步执行</strong><ul><li>必须保证所有注册的回调都是以微任务的方式异步执行，这与原生 Promise 的行为保持一致。</li></ul></li><li><strong>微任务方案选择</strong><ul><li>首选在 Node.js 环境中使用 <code>process.nextTick</code>；</li><li>在浏览器环境中可以使用 <code>MutationObserver</code>；</li><li>当以上两种方式不存在时，可使用 <code>setTimeout(func, 0)</code> 作为降级方案。</li></ul></li></ul><h3 id="_7-静态方法" tabindex="-1">7. 静态方法 <a class="header-anchor" href="#_7-静态方法" aria-label="Permalink to “7. 静态方法”">​</a></h3><ul><li><p><strong><code>MyPromise.resolve(value)</code></strong></p><ul><li>如果传入的 <code>value</code> 是一个 <code>MyPromise</code> 实例，则直接返回该实例。</li><li>如果传入的 <code>value</code> 是一个“类 Promise 对象”（即具有 <code>then</code> 方法），则需要等待其决议，并根据其状态决定新 Promise 的状态。</li><li>对于其他普通值，直接创建一个成功状态的 <code>MyPromise</code> 并返回。</li></ul></li><li><p><strong><code>MyPromise.reject(reason)</code></strong></p><ul><li>创建并返回一个处于拒绝状态的 <code>MyPromise</code> 实例，拒因为传入的 <code>reason</code>。</li></ul></li></ul><h2 id="实现注意事项" tabindex="-1">实现注意事项 <a class="header-anchor" href="#实现注意事项" aria-label="Permalink to “实现注意事项”">​</a></h2><ul><li><p><strong>私有属性与封装</strong></p><ul><li>建议使用私有变量（例如 ES6 中的私有字段）来存储内部状态、结果值和回调函数队列，从而避免外部直接修改内部数据。</li></ul></li><li><p><strong>状态更新的原子性</strong></p><ul><li>确保状态转换的逻辑仅执行一次，后续对状态或结果的更新应当被忽略。</li></ul></li><li><p><strong>回调队列管理</strong></p><ul><li>在 Promise 状态未定（<code>pending</code>）时，必须将所有 <code>then</code> 注册的回调存入内部队列；</li><li>当状态确定后，依次处理队列中的每个回调，且需要清空队列，避免重复执行。</li></ul></li><li><p><strong>异步调用细节</strong></p><ul><li>回调函数的执行必须在当前调用栈清空后开始（即微任务队列执行时机），从而确保符合 Promise 的异步规定。</li></ul></li><li><p><strong>异常处理</strong></p><ul><li>在处理每个回调时，要注意捕获内部异常并将异常传递至下一个 Promise 的拒绝处理分支。</li></ul></li><li><p><strong>链式调用与返回值处理</strong></p><ul><li>如果 <code>then</code> 中的回调返回的是一个新的“类 Promise 对象”，则正确处理其异步状态以及后续 <code>then</code> 的链接；</li><li>如果返回普通值，则直接将该值作为下一个 Promise 的 resolve 值传递。</li></ul></li><li><p><strong>finally 的实现细节</strong></p><ul><li>即使在 <code>finally</code> 中注册的回调返回一个 Promise，也不要改变之前 Promise 的最终结果或拒因，原始结果应在等待 <code>finally</code> 处理完毕后透传下去。</li></ul></li><li><p><strong>then 方法非函数透传机制</strong></p><ul><li>当传入 <code>then</code> 的回调为非函数时，应按照当前状态直接调用内部的 <code>resolve</code> 或 <code>reject</code> 方法，实现“值透传”与“不干扰”后续链的效果。</li></ul></li></ul><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">​</a></h2><p>本题目旨在考查对 Promise 内部原理的理解，包括状态机、回调队列管理、异步执行（微任务）以及链式调用等机制。 实现过程中需要注重以下几点：</p><ul><li>状态不可逆性与正确的状态转换；</li><li>异步回调的正确调度机制；</li><li>错误捕获、透传与链式调用的完善对接；</li><li>对“类 Promise 对象”的处理，确保静态方法的语义一致性。</li></ul><h2 id="代码" tabindex="-1">代码 <a class="header-anchor" href="#代码" aria-label="Permalink to “代码”">​</a></h2><table tabindex="0"><thead><tr><th>类型</th><th>路径</th></tr></thead><tbody><tr><td>JS 答案</td><td>problems/days/Day 08/answer.js</td></tr><tr><td>TS 答案</td><td>problems/days/Day 08/ts/answer.ts</td></tr><tr><td>模板</td><td>problems/days/Day 08/ts/MyPromise.ts</td></tr><tr><td>模板</td><td>problems/days/Day 08/ts/types.ts</td></tr><tr><td>测试</td><td>problems/days/Day 08/ts/MyPromise.spec.ts</td></tr></tbody></table>',28)])])}const m=l(r,[["render",d]]);export{p as __pageData,m as default};
