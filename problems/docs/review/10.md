# Day 10 复习文档

## 题目描述

手写实现 JavaScript 的**核心方法**，包括：

- Function.prototype.call - 改变函数执行上下文
- Function.prototype.apply - 类似 call，但参数为数组
- Function.prototype.bind - 返回绑定上下文的新函数
- instanceof 操作符 - 检查原型链关系
- new 操作符 - 创建实例对象

本题考查 **this 绑定机制**、**原型链原理** 和 **JavaScript 底层实现** 的深度理解。

## 核心知识点

### 1. this 绑定机制的四种规则

```javascript
// 1. 默认绑定 - 独立函数调用
function foo() {
  console.log(this);
}
foo(); // 严格模式: undefined, 非严格模式: window

// 2. 隐式绑定 - 对象方法调用
const obj = {
  foo() {
    console.log(this);
  },
};
obj.foo(); // this 指向 obj

// 3. 显式绑定 - call/apply/bind
foo.call(obj); // 强制 this 指向 obj

// 4. new 绑定 - 构造函数调用
function Constructor() {
  this.name = "test";
}
new Constructor(); // this 指向新创建的实例
```

### 2. 原型链关系图

```javascript
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function () {
  return `Hello, ${this.name}`;
};

const alice = new Person("Alice");

// 原型链关系：
// alice.__proto__ === Person.prototype
// Person.prototype.__proto__ === Object.prototype
// Object.prototype.__proto__ === null
```

### 3. 构造函数调用的四个步骤

1. 创建一个新的空对象
2. 将空对象的 **proto** 指向构造函数的 prototype
3. 将构造函数的 this 绑定到新对象
4. 如果构造函数返回对象，则返回该对象；否则返回新对象

### 4. Symbol 的妙用

```javascript
// 使用 Symbol 避免属性名冲突
const uniqueKey = Symbol("temp");
obj[uniqueKey] = func;
// 执行后删除，不会污染原对象
delete obj[uniqueKey];
```

## 代码实现

```javascript
/**
 * 1. 手写 Function.prototype.call
 * 改变函数的 this 指向，并立即执行函数
 */
Function.prototype.myCall = function (context, ...args) {
  // 处理边界情况：context 为 null 或 undefined
  if (context === null || context === undefined) {
    context = globalThis; // 兼容 Node.js 和浏览器
  }

  // 确保 context 是对象类型
  context = new Object(context);

  // 使用 Symbol 创建唯一属性名，避免冲突
  const fnSymbol = Symbol("fn");

  // 将当前函数赋值给 context 的属性
  context[fnSymbol] = this;

  try {
    // 通过对象方法调用的方式执行函数（隐式绑定）
    const result = context[fnSymbol](...args);
    return result;
  } finally {
    // 清理临时属性，避免污染原对象
    delete context[fnSymbol];
  }
};

/**
 * 2. 手写 Function.prototype.apply
 * 与 call 类似，但参数以数组形式传递
 */
Function.prototype.myApply = function (context, argsArray) {
  // 处理边界情况
  if (context === null || context === undefined) {
    context = globalThis;
  }

  context = new Object(context);

  // 参数数组默认为空数组
  const args = Array.isArray(argsArray) ? argsArray : [];

  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;

  try {
    const result = context[fnSymbol](...args);
    return result;
  } finally {
    delete context[fnSymbol];
  }
};

/**
 * 3. 手写 Function.prototype.bind
 * 返回一个新函数，预设 this 和部分参数（柯里化）
 */
Function.prototype.myBind = function (context, ...outerArgs) {
  // 保存原函数
  const originalFunc = this;

  // 检查调用者是否为函数
  if (typeof originalFunc !== "function") {
    throw new TypeError("Function.prototype.bind called on non-function");
  }

  // 返回绑定后的新函数
  const boundFunction = function (...innerArgs) {
    // 判断是否通过 new 调用
    if (new.target) {
      // new 调用：忽略绑定的 this，使用新创建的对象
      return new originalFunc(...outerArgs, ...innerArgs);
    } else {
      // 普通调用：使用绑定的 this
      return originalFunc.myCall(context, ...outerArgs, ...innerArgs);
    }
  };

  // 处理原型链继承
  if (originalFunc.prototype) {
    // 创建一个空函数作为中介，避免直接引用
    function Empty() {}
    Empty.prototype = originalFunc.prototype;
    boundFunction.prototype = new Empty();
  }

  return boundFunction;
};

/**
 * 4. 手写 instanceof 操作符
 * 检查对象的原型链中是否存在构造函数的 prototype
 */
function myInstanceof(left, right) {
  // 处理基本类型
  if (typeof left !== "object" || left === null) {
    return false;
  }

  // 检查右侧是否为函数
  if (typeof right !== "function") {
    throw new TypeError("Right-hand side of instanceof is not a function");
  }

  // 获取构造函数的 prototype
  const prototype = right.prototype;

  // 从对象的原型链开始查找
  let current = Object.getPrototypeOf(left);

  while (current !== null) {
    if (current === prototype) {
      return true;
    }
    current = Object.getPrototypeOf(current);
  }

  return false;
}

/**
 * 5. 手写 new 操作符
 * 模拟 new 的完整过程
 */
function myNew(constructor, ...args) {
  // 检查构造函数
  if (typeof constructor !== "function") {
    throw new TypeError("Constructor must be a function");
  }

  // 1. 创建新对象，并设置原型链
  const newObj = Object.create(constructor.prototype);

  // 2. 执行构造函数，绑定 this 到新对象
  const result = constructor.apply(newObj, args);

  // 3. 判断构造函数的返回值
  // 如果返回对象类型，则返回该对象；否则返回新创建的对象
  if (
    result !== null &&
    (typeof result === "object" || typeof result === "function")
  ) {
    return result;
  }

  return newObj;
}

/**
 * 增强版 bind：支持更多特性
 */
Function.prototype.myBindAdvanced = function (context, ...outerArgs) {
  const originalFunc = this;

  if (typeof originalFunc !== "function") {
    throw new TypeError("Function.prototype.bind called on non-function");
  }

  const boundFunction = function (...innerArgs) {
    const isNewCall = new.target === boundFunction;

    if (isNewCall) {
      // new 调用时的特殊处理
      const instance = Object.create(originalFunc.prototype);
      const result = originalFunc.apply(instance, [...outerArgs, ...innerArgs]);

      // 如果构造函数返回对象，使用该对象；否则使用创建的实例
      return result && typeof result === "object" ? result : instance;
    } else {
      // 普通调用
      return originalFunc.apply(context, [...outerArgs, ...innerArgs]);
    }
  };

  // 维护原型链
  if (originalFunc.prototype) {
    boundFunction.prototype = Object.create(originalFunc.prototype);
  }

  // 复制函数属性
  Object.defineProperty(boundFunction, "length", {
    value: Math.max(0, originalFunc.length - outerArgs.length),
    configurable: true,
  });

  Object.defineProperty(boundFunction, "name", {
    value: `bound ${originalFunc.name}`,
    configurable: true,
  });

  return boundFunction;
};

/**
 * 更精确的 instanceof 实现
 */
function myInstanceofAdvanced(left, right) {
  // 处理 null 和 undefined
  if (left == null) return false;

  // 处理基本类型的包装
  if (typeof left !== "object" && typeof left !== "function") {
    // 检查基本类型的包装对象
    if (right === String && typeof left === "string") return false;
    if (right === Number && typeof left === "number") return false;
    if (right === Boolean && typeof left === "boolean") return false;
    return false;
  }

  // 检查右侧
  if (typeof right !== "function") {
    throw new TypeError("Right-hand side of instanceof is not callable");
  }

  // 特殊处理：Function 的 instanceof
  if (right === Function) {
    return typeof left === "function";
  }

  // 特殊处理：Object 的 instanceof
  if (right === Object) {
    return typeof left === "object" || typeof left === "function";
  }

  const prototype = right.prototype;
  if (prototype == null) {
    throw new TypeError(
      "Function has non-object prototype in instanceof check",
    );
  }

  let current = Object.getPrototypeOf(left);

  while (current != null) {
    if (current === prototype) {
      return true;
    }
    current = Object.getPrototypeOf(current);
  }

  return false;
}

/**
 * 支持类语法的 new 实现
 */
function myNewAdvanced(constructor, ...args) {
  if (typeof constructor !== "function") {
    throw new TypeError("Constructor must be a function");
  }

  // 检查是否为箭头函数（不能作为构造函数）
  if (!constructor.prototype) {
    throw new TypeError("Constructor is not constructable");
  }

  // 创建新对象
  const newObj = Object.create(constructor.prototype);

  // 设置正确的 new.target
  const boundConstructor = constructor.bind(newObj);
  Object.defineProperty(boundConstructor, "prototype", {
    value: constructor.prototype,
  });

  try {
    const result = Reflect.construct(constructor, args, constructor);

    // 检查返回值
    if (
      result != null &&
      (typeof result === "object" || typeof result === "function")
    ) {
      return result;
    }
  } catch (error) {
    // 如果构造函数执行出错，确保清理工作
    throw error;
  }

  return newObj;
}
```

## 算法分析

- **时间复杂度**: O(1) - call/apply/bind, O(n) - instanceof(n为原型链长度)
- **空间复杂度**: O(1) - 基本实现，O(1) - 临时Symbol属性
- **特点**: 原生JS行为模拟、原型链操作、this绑定

## 关键技术点

### 1. Symbol 避免属性冲突

```javascript
// 错误方式：可能覆盖已有属性
context.fn = this;

// 正确方式：使用 Symbol 确保唯一性
const fnSymbol = Symbol("temp");
context[fnSymbol] = this;
```

### 2. call/apply 的核心原理

```javascript
// 核心思想：利用隐式绑定改变 this
// obj.method() -> method 内的 this 指向 obj

function myCall(context, ...args) {
  context[fn] = this; // 将函数作为 context 的方法
  context[fn](...args); // 调用方法，this 自动绑定到 context
  delete context[fn]; // 清理临时属性
}
```

### 3. bind 的 new 调用检测

```javascript
function boundFunction(...args) {
  // 检测是否通过 new 调用
  if (new.target) {
    // new 调用：忽略绑定的 this
    return new originalFunc(...outerArgs, ...args);
  } else {
    // 普通调用：使用绑定的 this
    return originalFunc.call(context, ...outerArgs, ...args);
  }
}
```

### 4. instanceof 的原型链遍历

```javascript
function myInstanceof(obj, constructor) {
  let current = Object.getPrototypeOf(obj);
  const target = constructor.prototype;

  // 沿着原型链向上查找
  while (current !== null) {
    if (current === target) return true;
    current = Object.getPrototypeOf(current);
  }

  return false;
}
```

### 5. 常见陷阱和坑点

- **this丢失**: 不使用隐式绑定改变this指向
- **属性污染**: 直接在对象上添加属性而不清理
- **参数处理**: apply的参数不是数组时的处理
- **new检测**: bind函数被new调用时的特殊处理
- **原型链**: instanceof的原型链遍历终止条件

## 使用示例

```javascript
// call 使用示例
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: "Alice" };
console.log(greet.myCall(person, "Hello", "!")); // "Hello, Alice!"

// apply 使用示例
const numbers = [1, 5, 3, 9, 2];
console.log(Math.max.myApply(null, numbers)); // 9

// bind 使用示例
const boundGreet = greet.myBind(person, "Hi");
console.log(boundGreet("?")); // "Hi, Alice?"

// bind 的 new 调用
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const BoundPerson = Person.myBind(null, "John");
const john = new BoundPerson(25);
console.log(john.name); // "John"
console.log(john.age); // 25

// instanceof 使用示例
console.log(myInstanceof(john, Person)); // true
console.log(myInstanceof(john, Object)); // true
console.log(myInstanceof(john, Array)); // false

// new 使用示例
function Car(brand, model) {
  this.brand = brand;
  this.model = model;
  this.start = function () {
    return `${this.brand} ${this.model} is starting`;
  };
}

const myCar = myNew(Car, "Toyota", "Camry");
console.log(myCar.brand); // "Toyota"
console.log(myCar.start()); // "Toyota Camry is starting"

// 构造函数返回对象的情况
function SpecialConstructor() {
  this.name = "instance";
  return { custom: "object" }; // 返回自定义对象
}

const special = myNew(SpecialConstructor);
console.log(special.custom); // "object"
console.log(special.name); // undefined

// 复杂继承示例
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function () {
  return `${this.name} makes a sound`;
};

function Dog(name, breed) {
  Animal.myCall(this, name);
  this.breed = breed;
}

// 设置原型链
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function () {
  return `${this.name} barks!`;
};

const dog = myNew(Dog, "Buddy", "Golden Retriever");
console.log(dog.speak()); // "Buddy makes a sound"
console.log(dog.bark()); // "Buddy barks!"
console.log(myInstanceof(dog, Dog)); // true
console.log(myInstanceof(dog, Animal)); // true

// 边界情况测试
console.log(greet.myCall(null, "Hello", "!")); // this指向global
console.log(greet.myCall(undefined, "Hi", "?")); // this指向global
console.log(greet.myCall(42, "Hey", ".")); // this指向Number包装对象

// 箭头函数与 bind（箭头函数无法绑定 this）
const arrowFunc = (x) => x * 2;
const boundArrow = arrowFunc.myBind({ value: 10 });
console.log(boundArrow(5)); // 10（this绑定无效）

// 异常处理测试
try {
  myInstanceof(123, "not a function");
} catch (e) {
  console.log(e.message); // "Right-hand side of instanceof is not a function"
}

try {
  myNew("not a function");
} catch (e) {
  console.log(e.message); // "Constructor must be a function"
}

// 性能对比测试
function performanceTest() {
  const iterations = 1000000;
  const obj = { name: "Test" };

  function testFunc() {
    return this.name;
  }

  // 原生 call
  console.time("Native call");
  for (let i = 0; i < iterations; i++) {
    testFunc.call(obj);
  }
  console.timeEnd("Native call");

  // 自实现 call
  console.time("Custom call");
  for (let i = 0; i < iterations; i++) {
    testFunc.myCall(obj);
  }
  console.timeEnd("Custom call");
}

// performanceTest()
```

## 记忆要点

### 核心记忆点

1. **Symbol技巧** - 使用Symbol避免属性名冲突
2. **隐式绑定** - 通过对象方法调用改变this指向
3. **new检测** - bind函数中判断是否通过new调用
4. **原型链遍历** - instanceof的查找过程
5. **返回值处理** - 构造函数返回对象时的特殊情况

### 实现模式记忆

```javascript
// call/apply 模式
// 1. 处理context（null/undefined）
// 2. 创建Symbol属性
// 3. 赋值函数并调用
// 4. 清理临时属性

// bind 模式
// 1. 保存原函数
// 2. 返回新函数
// 3. 检测new调用
// 4. 选择合适的this
```

## 扩展思考

### 1. 支持异步函数的bind

```javascript
Function.prototype.asyncBind = function (context, ...outerArgs) {
  const originalFunc = this;

  return async function (...innerArgs) {
    if (new.target) {
      throw new TypeError("Async function cannot be called with new");
    }

    try {
      const result = await originalFunc.myCall(
        context,
        ...outerArgs,
        ...innerArgs,
      );
      return result;
    } catch (error) {
      throw error;
    }
  };
};

// 使用示例
async function fetchData(url) {
  const response = await fetch(url);
  return `Data from ${this.name}: ${response.status}`;
}

const api = { name: "UserAPI" };
const boundFetch = fetchData.asyncBind(api);
boundFetch("/users").then(console.log);
```

### 2. 支持装饰器的call

```javascript
Function.prototype.decoratedCall = function (
  context,
  decorators = [],
  ...args
) {
  let func = this;

  // 应用装饰器
  for (const decorator of decorators.reverse()) {
    func = decorator(func);
  }

  return func.myCall(context, ...args);
};

// 装饰器示例
function logDecorator(func) {
  return function (...args) {
    console.log(`Calling ${func.name} with args:`, args);
    const result = func.apply(this, args);
    console.log(`Result:`, result);
    return result;
  };
}

function timingDecorator(func) {
  return function (...args) {
    const start = performance.now();
    const result = func.apply(this, args);
    const end = performance.now();
    console.log(`Execution time: ${end - start}ms`);
    return result;
  };
}

// 使用示例
function calculate(a, b) {
  return a + b;
}

calculate.decoratedCall({}, [logDecorator, timingDecorator], 5, 3);
```

### 3. 支持柯里化的bind

```javascript
Function.prototype.curry = function (...outerArgs) {
  const originalFunc = this;
  const totalArgs = originalFunc.length;

  function curried(...currentArgs) {
    const allArgs = [...outerArgs, ...currentArgs];

    if (allArgs.length >= totalArgs) {
      return originalFunc.apply(this, allArgs);
    } else {
      return curried.bind(this, ...currentArgs);
    }
  }

  return curried;
};

// 使用示例
function multiply(a, b, c) {
  return a * b * c;
}

const curriedMultiply = multiply.curry();
const step1 = curriedMultiply(2);
const step2 = step1(3);
const result = step2(4); // 24
```

### 4. 支持管道的apply

```javascript
Function.prototype.pipeline = function (context, ...funcs) {
  return (...args) => {
    let result = this.myApply(context, args);

    for (const func of funcs) {
      result = func.call(context, result);
    }

    return result;
  };
};

// 使用示例
function add(a, b) {
  return a + b;
}

function double(x) {
  return x * 2;
}

function square(x) {
  return x * x;
}

const pipeline = add.pipeline(null, double, square);
console.log(pipeline(3, 4)); // ((3+4)*2)^2 = 196
```

### 5. 支持缓存的new

```javascript
function memoizedNew(constructor, cacheKey) {
  const cache = new Map();

  return function (...args) {
    const key = cacheKey ? cacheKey(...args) : JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key);
    }

    const instance = myNew(constructor, ...args);
    cache.set(key, instance);

    return instance;
  };
}

// 使用示例
function ExpensiveObject(id, data) {
  this.id = id;
  this.data = data;
  this.processed = this.heavyProcessing(data);
}

ExpensiveObject.prototype.heavyProcessing = function (data) {
  // 模拟昂贵操作
  return data.toUpperCase();
};

const createCachedObject = memoizedNew(
  ExpensiveObject,
  (id) => id, // 缓存键为 id
);

const obj1 = createCachedObject(1, "test");
const obj2 = createCachedObject(1, "different"); // 返回缓存的 obj1
console.log(obj1 === obj2); // true
```

## 复习检查清单

- [ ] 理解this绑定的四种规则和优先级
- [ ] 掌握call/apply/bind的实现原理
- [ ] 熟练使用Symbol避免属性名冲突
- [ ] 理解new操作符的完整执行过程
- [ ] 掌握instanceof的原型链查找机制
- [ ] 能够处理各种边界情况和异常
- [ ] 了解原生实现与自定义实现的性能差异
- [ ] 熟悉原型链和构造函数的关系
- [ ] 能够扩展和优化基础实现
- [ ] 理解在实际项目中的应用场景
