# Day 14 复习文档

## 题目描述

实现一个基本的 **Observable** 类，支持观察者模式的核心功能：

- 支持订阅者订阅数据流
- 支持 `next`、`error`、`complete` 三种事件
- 支持取消订阅功能
- 支持多个订阅者
- `error` 和 `complete` 只能触发一次，之后的调用被忽略

Observable 决定了 values 如何传递给 Observer，Observer 本质上就是一些 callback 的集合。

```js
const observer = {
  next: (value) => {
    console.log('we got a value', value)
  },
  error: (error) => {
    console.log('we got an error', error)
  },
  complete: () => {
    console.log('ok, no more values')
  },
}
```

本题考查 **观察者模式**、**发布订阅模式** 和 **响应式编程** 的核心概念。

## 核心知识点

### 1. 观察者模式 (Observer Pattern)

- **定义**: 一个对象维护一系列依赖者，当状态发生变化时通知所有依赖者
- **角色**: Observable(被观察者) 和 Observer(观察者)
- **优势**: 低耦合、动态关系、广播通信

### 2. 响应式编程 (Reactive Programming)

- **核心思想**: 数据流和变化传播
- **特点**: 异步数据流、函数式编程、声明式编程
- **应用**: RxJS、Vue 响应式系统、React Hooks

### 3. 订阅生命周期管理

- **订阅状态**: 活跃、已完成、已错误、已取消
- **资源清理**: 避免内存泄漏和重复触发
- **错误处理**: 优雅的错误传播和处理

## 代码实现

```javascript
class Observable {
  constructor(setup) {
    this._setup = setup // 存储设置函数
  }

  subscribe(subscriber) {
    // 创建订阅者包装器，管理订阅状态
    const subscriberWrapper = {
      unsubscribed: false,

      next(value) {
        if (this.unsubscribed) return
        // 支持函数形式的订阅者
        if (subscriber instanceof Function) {
          return subscriber(value)
        }
        return subscriber.next ? subscriber.next(value) : null
      },

      error(value) {
        if (this.unsubscribed) return
        this.unsubscribe() // error 后自动取消订阅
        return subscriber.error ? subscriber.error(value) : null
      },

      complete() {
        if (this.unsubscribed) return
        this.unsubscribe() // complete 后自动取消订阅
        return subscriber.complete ? subscriber.complete() : null
      },

      unsubscribe() {
        this.unsubscribed = true
      },
    }

    if (!subscriber) return

    // 执行设置函数，传入包装器
    this._setup(subscriberWrapper)
    return subscriberWrapper
  }
}

export default Observable
```

## 算法分析

- **时间复杂度**: O(1) - 订阅和取消订阅操作
- **空间复杂度**: O(n) - n 为订阅者数量
- **特点**: 支持多播、惰性执行、状态管理

## 关键技术点

### 1. 订阅者类型处理

```javascript
// 支持三种订阅方式
// 1. 函数形式
observable.subscribe((value) => console.log(value))

// 2. 对象形式 - 完整
observable.subscribe({
  next: (value) => console.log(value),
  error: (err) => console.error(err),
  complete: () => console.log('done'),
})

// 3. 对象形式 - 部分
observable.subscribe({
  next: (value) => console.log(value),
})
```

### 2. 状态管理的关键点

```javascript
// 防止重复触发的设计
if (this.unsubscribed) return

// error 和 complete 的互斥性
error(value) {
  if (this.unsubscribed) return
  this.unsubscribe() // 立即标记为已取消
  return subscriber.error ? subscriber.error(value) : null
}
```

### 3. 内存泄漏防护

```javascript
// 正确的订阅管理
const subscription = observable.subscribe(observer)

// 组件销毁时取消订阅
onDestroy(() => {
  subscription.unsubscribe()
})
```

### 4. 常见陷阱和坑点

- **忘记取消订阅**: 导致内存泄漏和重复执行
- **状态检查遗漏**: 在已完成的流上继续操作
- **错误处理不当**: error 后没有停止流
- **异步操作竞态**: 多个异步操作的执行顺序

## 使用示例

```javascript
// 基本用法
const observable = new Observable((subscriber) => {
  subscriber.next(1)
  subscriber.next(2)
  setTimeout(() => {
    subscriber.next(3)
    subscriber.complete()
  }, 1000)
})

// 订阅方式1：函数
const sub1 = observable.subscribe((value) => {
  console.log('Got value:', value)
})

// 订阅方式2：对象
const sub2 = observable.subscribe({
  next: (value) => console.log('Next:', value),
  error: (err) => console.log('Error:', err),
  complete: () => console.log('Complete!'),
})

// 取消订阅
setTimeout(() => {
  sub1.unsubscribe()
  sub2.unsubscribe()
}, 500)

// 错误处理示例
const errorObservable = new Observable((subscriber) => {
  subscriber.next('start')
  subscriber.error('something wrong')
  subscriber.next('this will not be called') // 被忽略
})

// 多订阅者支持
const multiSub = new Observable((subscriber) => {
  let count = 0
  const timer = setInterval(() => {
    subscriber.next(++count)
    if (count === 5) {
      subscriber.complete()
      clearInterval(timer)
    }
  }, 100)
})

const sub1 = multiSub.subscribe((v) => console.log('Sub1:', v))
const sub2 = multiSub.subscribe((v) => console.log('Sub2:', v))
```

## 记忆要点

### 核心记忆点

1. **Observable 是懒执行的** - 只有在被订阅时才执行
2. **状态管理很关键** - unsubscribed 标志防止重复执行
3. **error/complete 是终结状态** - 执行后自动取消订阅
4. **支持多种订阅方式** - 函数或对象，提高易用性
5. **内存管理** - 及时取消订阅避免泄漏

### 设计原则

```javascript
// SOLID 原则在 Observable 中的体现
// 1. 单一职责：Observable 只负责数据流管理
// 2. 开闭原则：可扩展新的操作符而不修改核心
// 3. 依赖倒置：依赖抽象的 Observer 接口
```

## 扩展思考

### 1. 操作符扩展

```javascript
class Observable {
  // ... 基础实现

  // map 操作符
  map(fn) {
    return new Observable((subscriber) => {
      return this.subscribe({
        next: (value) => subscriber.next(fn(value)),
        error: (err) => subscriber.error(err),
        complete: () => subscriber.complete(),
      })
    })
  }

  // filter 操作符
  filter(predicate) {
    return new Observable((subscriber) => {
      return this.subscribe({
        next: (value) => {
          if (predicate(value)) {
            subscriber.next(value)
          }
        },
        error: (err) => subscriber.error(err),
        complete: () => subscriber.complete(),
      })
    })
  }

  // 链式调用支持
  pipe(...operators) {
    return operators.reduce((prev, fn) => fn(prev), this)
  }
}
```

### 2. 高级特性实现

```javascript
// Subject - 既是 Observable 又是 Observer
class Subject extends Observable {
  constructor() {
    super()
    this.observers = []
    this.closed = false
  }

  subscribe(observer) {
    if (this.closed) return
    this.observers.push(observer)
    return {
      unsubscribe: () => {
        const index = this.observers.indexOf(observer)
        if (index > -1) this.observers.splice(index, 1)
      },
    }
  }

  next(value) {
    if (this.closed) return
    this.observers.forEach((observer) => {
      if (typeof observer === 'function') {
        observer(value)
      } else if (observer.next) {
        observer.next(value)
      }
    })
  }

  error(err) {
    if (this.closed) return
    this.closed = true
    this.observers.forEach((observer) => {
      if (observer.error) observer.error(err)
    })
    this.observers = []
  }

  complete() {
    if (this.closed) return
    this.closed = true
    this.observers.forEach((observer) => {
      if (observer.complete) observer.complete()
    })
    this.observers = []
  }
}
```

### 3. 实际应用场景

```javascript
// 用户输入处理
const createInputObservable = (element) => {
  return new Observable((subscriber) => {
    const handler = (event) => subscriber.next(event.target.value)
    element.addEventListener('input', handler)

    return () => {
      element.removeEventListener('input', handler)
    }
  })
}

// HTTP 请求封装
const createHttpObservable = (url) => {
  return new Observable((subscriber) => {
    fetch(url)
      .then((response) => response.json())
      .then((data) => {
        subscriber.next(data)
        subscriber.complete()
      })
      .catch((err) => subscriber.error(err))
  })
}

// WebSocket 连接
const createWebSocketObservable = (url) => {
  return new Observable((subscriber) => {
    const ws = new WebSocket(url)

    ws.onmessage = (event) => subscriber.next(JSON.parse(event.data))
    ws.onerror = (error) => subscriber.error(error)
    ws.onclose = () => subscriber.complete()

    return () => ws.close()
  })
}
```

## 复习检查清单

- [ ] 理解观察者模式的基本概念和优势
- [ ] 掌握 Observable 的生命周期管理
- [ ] 熟练处理不同类型的订阅者参数
- [ ] 理解 error 和 complete 的终结性质
- [ ] 掌握内存泄漏防护和资源清理
- [ ] 能够实现基本的操作符扩展
- [ ] 理解响应式编程的核心思想
- [ ] 熟悉实际应用场景和最佳实践
- [ ] 掌握调试技巧和性能优化方法
- [ ] 理解与 RxJS 等成熟库的设计差异
