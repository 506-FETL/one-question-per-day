# Day 01 复习文档

## 题目描述

实现一个 JavaScript 版本的**归并排序算法**，要求：

- 直接修改传入的数组，不要返回新数组
- 支持对数字数组进行排序（包括正数、负数、小数）

本题考查 **分治算法**、**递归思想** 和 **数组操作** 的深度理解。

## 核心知识点

### 1. 归并排序算法原理

- **分治思想**: 将复杂问题分解为相同类型的子问题
- **递归结构**: 不断分解直到只有一个元素，然后逐层合并
- **合并过程**: 将两个有序数组合并成一个有序数组
- **时间保证**: 无论任何情况都是 O(n log n)

### 2. 分治算法三步骤

1. **分解 (Divide)**: 将数组从中间分成两部分
2. **解决 (Conquer)**: 递归地对左右两部分分别进行归并排序
3. **合并 (Combine)**: 将排好序的左右两部分合并成一个有序数组

### 3. 稳定性保证

- **稳定排序**: 相等元素的相对位置保持不变
- **实现关键**: 合并时优先选择左边的元素

## 代码实现

```javascript
export default function mergeSort(arr) {
  let l = 0,
    r = arr.length - 1

  function _merge(arr, l, r) {
    // 递归终止条件：只有一个元素或没有元素
    if (l >= r) return

    // 找到中间位置（使用位运算优化）
    const mid = (l + r) >> 1

    // 递归排序左右两部分
    _merge(arr, l, mid)
    _merge(arr, mid + 1, r)

    // 合并两个有序数组
    let i = l,
      j = mid + 1
    const tmp = []

    // 比较两个数组的元素，较小的先放入临时数组
    while (i <= mid && j <= r) {
      if (arr[i] <= arr[j])
        tmp.push(arr[i++]) // <= 保证稳定性
      else tmp.push(arr[j++])
    }

    // 处理剩余元素
    while (i <= mid) tmp.push(arr[i++])
    while (j <= r) tmp.push(arr[j++])

    // 将临时数组的内容复制回原数组
    for (let i = l, j = 0; i <= r; i++, j++) {
      arr[i] = tmp[j]
    }
  }

  _merge(arr, l, r)
}
```

## 算法分析

- **时间复杂度**: O(n log n) - 所有情况下都是这个复杂度
- **空间复杂度**: O(n) - 需要额外的临时数组
- **稳定性**: 稳定排序算法
- **特点**: 性能稳定，不受输入数据分布影响

## 关键技术点

### 1. 递归边界条件

```javascript
if (l >= r) return // 当 l >= r 时，数组已经只有 0 或 1 个元素，无需排序
```

### 2. 中点计算优化

```javascript
const mid = (l + r) >> 1 // 位运算比除法更快
// 等价于 Math.floor((l + r) / 2)
```

### 3. 双指针合并技巧

```javascript
// 核心合并逻辑
while (i <= mid && j <= r) {
  if (arr[i] <= arr[j])
    tmp.push(arr[i++]) // 注意 <= 保证稳定性
  else tmp.push(arr[j++])
}
```

### 4. 剩余元素处理

```javascript
// 左半部分可能有剩余
while (i <= mid) tmp.push(arr[i++])
// 右半部分可能有剩余
while (j <= r) tmp.push(arr[j++])
```

### 5. 常见陷阱和坑点

- **稳定性破坏**: 使用 `<` 而不是 `<=` 会破坏稳定性
- **索引越界**: 合并时要注意边界条件
- **内存管理**: 临时数组的创建和销毁
- **递归深度**: 对于极大数组可能导致栈溢出

## 使用示例

```javascript
// 基础测试
let arr1 = [5, 2, 9, 1, 5, 6]
mergeSort(arr1)
console.log(arr1) // [1, 2, 5, 5, 6, 9]

// 负数处理
let arr2 = [-3, -1, -7, -4, -5]
mergeSort(arr2)
console.log(arr2) // [-7, -5, -4, -3, -1]

// 混合数组
let arr3 = [3, -1, 0, -7, 4, 2]
mergeSort(arr3)
console.log(arr3) // [-7, -1, 0, 2, 3, 4]

// 稳定性测试
let arr4 = [
  { value: 3, id: 'a' },
  { value: 1, id: 'b' },
  { value: 3, id: 'c' },
]
mergeSort(arr4)
// 结果: [{value: 1, id: 'b'}, {value: 3, id: 'a'}, {value: 3, id: 'c'}]
// 注意：两个 value=3 的元素，id='a' 仍在 id='c' 前面

// 边界情况
let arr5 = []
mergeSort(arr5)
console.log(arr5) // []

let arr6 = [42]
mergeSort(arr6)
console.log(arr6) // [42]

// 已排序数组
let arr7 = [1, 2, 3, 4, 5]
mergeSort(arr7)
console.log(arr7) // [1, 2, 3, 4, 5]

// 小数处理
let arr8 = [1.5, 2.3, 4.32, -23.1]
mergeSort(arr8)
console.log(arr8) // [-23.1, 1.5, 2.3, 4.32]
```

## 记忆要点

### 核心记忆点

1. **分治三步骤** - 分解、递归、合并
2. **稳定性关键** - 合并时使用 `<=` 而不是 `<`
3. **时间复杂度恒定** - 任何情况下都是 O(n log n)
4. **空间换时间** - 需要 O(n) 额外空间
5. **递归结构** - 每层处理一半数据，深度为 log n

### 调试技巧

```javascript
// 添加调试信息的版本
function mergeSortDebug(arr, depth = 0) {
  const indent = '  '.repeat(depth)
  console.log(`${indent}Sorting [${arr.join(', ')}]`)

  function _merge(arr, l, r, depth) {
    if (l >= r) return

    const mid = (l + r) >> 1
    console.log(`${indent}Split: [${l}, ${mid}] and [${mid + 1}, ${r}]`)

    _merge(arr, l, mid, depth + 1)
    _merge(arr, mid + 1, r, depth + 1)

    // 合并逻辑...
    console.log(`${indent}Merged: [${arr.slice(l, r + 1).join(', ')}]`)
  }

  _merge(arr, 0, arr.length - 1, depth)
}
```

## 扩展思考

### 1. 迭代版本实现

```javascript
function mergeSortIterative(arr) {
  const n = arr.length

  // 子数组大小从 1 开始，每次翻倍
  for (let size = 1; size < n; size *= 2) {
    // 对每个大小为 size 的子数组进行合并
    for (let left = 0; left < n - 1; left += 2 * size) {
      const mid = Math.min(left + size - 1, n - 1)
      const right = Math.min(left + 2 * size - 1, n - 1)

      merge(arr, left, mid, right)
    }
  }
}

function merge(arr, left, mid, right) {
  const leftArr = arr.slice(left, mid + 1)
  const rightArr = arr.slice(mid + 1, right + 1)

  let i = 0,
    j = 0,
    k = left

  while (i < leftArr.length && j < rightArr.length) {
    if (leftArr[i] <= rightArr[j]) {
      arr[k++] = leftArr[i++]
    } else {
      arr[k++] = rightArr[j++]
    }
  }

  while (i < leftArr.length) arr[k++] = leftArr[i++]
  while (j < rightArr.length) arr[k++] = rightArr[j++]
}
```

### 2. 优化版本

```javascript
function mergeSortOptimized(arr) {
  // 小数组使用插入排序
  function insertionSort(arr, left, right) {
    for (let i = left + 1; i <= right; i++) {
      const key = arr[i]
      let j = i - 1
      while (j >= left && arr[j] > key) {
        arr[j + 1] = arr[j]
        j--
      }
      arr[j + 1] = key
    }
  }

  function _merge(arr, l, r) {
    if (l >= r) return

    // 小数组直接用插入排序
    if (r - l < 10) {
      insertionSort(arr, l, r)
      return
    }

    const mid = (l + r) >> 1

    _merge(arr, l, mid)
    _merge(arr, mid + 1, r)

    // 如果已经有序，跳过合并
    if (arr[mid] <= arr[mid + 1]) return

    // 正常合并逻辑...
  }

  _merge(arr, 0, arr.length - 1)
}
```

### 3. 链表版本

```javascript
class ListNode {
  constructor(val, next = null) {
    this.val = val
    this.next = next
  }
}

function mergeSortList(head) {
  if (!head || !head.next) return head

  // 找到中点
  function findMid(head) {
    let slow = head,
      fast = head,
      prev = null
    while (fast && fast.next) {
      prev = slow
      slow = slow.next
      fast = fast.next.next
    }
    prev.next = null // 切断链表
    return slow
  }

  // 合并两个有序链表
  function merge(l1, l2) {
    const dummy = new ListNode(0)
    let current = dummy

    while (l1 && l2) {
      if (l1.val <= l2.val) {
        current.next = l1
        l1 = l1.next
      } else {
        current.next = l2
        l2 = l2.next
      }
      current = current.next
    }

    current.next = l1 || l2
    return dummy.next
  }

  const mid = findMid(head)
  const left = mergeSortList(head)
  const right = mergeSortList(mid)

  return merge(left, right)
}
```

### 4. 外部排序应用

```javascript
// 处理大文件的外部归并排序思路
class ExternalMergeSort {
  constructor(memoryLimit = 1000) {
    this.memoryLimit = memoryLimit
  }

  async sortLargeArray(largeArray) {
    // 1. 分割成小块，分别排序后存储
    const chunks = []
    for (let i = 0; i < largeArray.length; i += this.memoryLimit) {
      const chunk = largeArray.slice(i, i + this.memoryLimit)
      mergeSort(chunk)
      chunks.push(chunk)
    }

    // 2. 多路归并
    return this.multiWayMerge(chunks)
  }

  multiWayMerge(chunks) {
    while (chunks.length > 1) {
      const newChunks = []

      for (let i = 0; i < chunks.length; i += 2) {
        if (i + 1 < chunks.length) {
          newChunks.push(this.mergeTwoArrays(chunks[i], chunks[i + 1]))
        } else {
          newChunks.push(chunks[i])
        }
      }

      chunks = newChunks
    }

    return chunks[0] || []
  }

  mergeTwoArrays(arr1, arr2) {
    const result = []
    let i = 0,
      j = 0

    while (i < arr1.length && j < arr2.length) {
      if (arr1[i] <= arr2[j]) {
        result.push(arr1[i++])
      } else {
        result.push(arr2[j++])
      }
    }

    while (i < arr1.length) result.push(arr1[i++])
    while (j < arr2.length) result.push(arr2[j++])

    return result
  }
}
```

## 复习检查清单

- [ ] 理解分治算法的基本思想和应用
- [ ] 掌握归并排序的完整实现过程
- [ ] 熟练分析时间和空间复杂度
- [ ] 理解稳定性的概念和保证方法
- [ ] 掌握递归边界条件的设置
- [ ] 熟悉双指针合并技巧
- [ ] 能够识别和避免常见实现错误
- [ ] 了解迭代版本和优化策略
- [ ] 理解与其他排序算法的对比
- [ ] 掌握实际应用场景和扩展思路
