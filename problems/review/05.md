# Day 05 å¤ä¹ æ–‡æ¡£

## é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªå®Œæ•´çš„**æ·±æ‹·è´å‡½æ•°**ï¼Œè¦æ±‚ï¼š

- æ”¯æŒå¯¹è±¡å’Œæ•°ç»„çš„æ·±å±‚å¤åˆ¶
- è§£å†³å¾ªç¯å¼•ç”¨é—®é¢˜
- å¤„ç†å„ç§æ•°æ®ç±»å‹ï¼ˆDateã€RegExpã€Symbol ç­‰ï¼‰
- ä¿æŒåŸå¯¹è±¡çš„æ‰€æœ‰ç‰¹æ€§å’Œå±æ€§

æœ¬é¢˜è€ƒæŸ¥ **é€’å½’ç®—æ³•**ã€**æ•°æ®ç±»å‹åˆ¤æ–­** å’Œ **å¾ªç¯å¼•ç”¨å¤„ç†** çš„ç»¼åˆèƒ½åŠ›ã€‚

## æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. æ·±æ‹·è´ vs æµ…æ‹·è´

- **æµ…æ‹·è´**: åªå¤åˆ¶å¯¹è±¡çš„ç¬¬ä¸€å±‚å±æ€§ï¼Œæ·±å±‚å±æ€§ä»å…±äº«å¼•ç”¨
- **æ·±æ‹·è´**: é€’å½’å¤åˆ¶æ‰€æœ‰å±‚çº§çš„å±æ€§ï¼Œåˆ›å»ºå®Œå…¨ç‹¬ç«‹çš„å‰¯æœ¬
- **åº”ç”¨åœºæ™¯**: é˜²æ­¢æ„å¤–ä¿®æ”¹ã€çŠ¶æ€ç®¡ç†ã€æ•°æ®å¤‡ä»½

### 2. å¾ªç¯å¼•ç”¨é—®é¢˜

```javascript
const a = { name: 'Alice' }
a.self = a // åˆ›å»ºå¾ªç¯å¼•ç”¨

// ä¸å¤„ç†å¾ªç¯å¼•ç”¨ä¼šå¯¼è‡´ï¼š
// RangeError: Maximum call stack size exceeded
```

### 3. JavaScript æ•°æ®ç±»å‹åˆ†ç±»

- **åŸºæœ¬ç±»å‹**: number, string, boolean, undefined, null, symbol, bigint
- **å¼•ç”¨ç±»å‹**: Object, Array, Date, RegExp, Function, Map, Set ç­‰
- **ç‰¹æ®Šå¤„ç†**: Symbol é”®ã€ä¸å¯æšä¸¾å±æ€§ã€getter/setter

## ä»£ç å®ç°

```javascript
export default function deepClone(obj, cache = new Map()) {
  // å¤„ç†å¾ªç¯å¼•ç”¨ï¼šå¦‚æœå·²ç»å…‹éš†è¿‡ï¼Œç›´æ¥è¿”å›
  if (cache.has(obj)) {
    return cache.get(obj)
  }

  let result = null

  if (Array.isArray(obj)) {
    result = handleArray(obj, cache)
  } else if (isObject(obj)) {
    result = handleObject(obj, cache)
  } else {
    result = handleBasic(obj)
  }

  return result
}

// å¤„ç†æ•°ç»„
const handleArray = (arr, cache) => {
  const tmp = []

  // å…ˆå°†ç»“æœå­˜å…¥ç¼“å­˜ï¼Œé˜²æ­¢å¾ªç¯å¼•ç”¨
  cache.set(arr, tmp)

  arr.forEach((el, idx) => {
    tmp[idx] = deepClone(el, cache)
  })

  return tmp
}

// å¤„ç†å¯¹è±¡
const handleObject = (obj, cache) => {
  // å¤„ç†ç‰¹æ®Šå¯¹è±¡ç±»å‹
  if (obj instanceof Date) {
    return new Date(obj.getTime())
  }

  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags)
  }

  if (obj instanceof Error) {
    const error = new Error(obj.message)
    error.name = obj.name
    error.stack = obj.stack
    return error
  }

  // å¤„ç† Map
  if (obj instanceof Map) {
    const map = new Map()
    cache.set(obj, map)
    for (const [key, value] of obj) {
      map.set(deepClone(key, cache), deepClone(value, cache))
    }
    return map
  }

  // å¤„ç† Set
  if (obj instanceof Set) {
    const set = new Set()
    cache.set(obj, set)
    for (const value of obj) {
      set.add(deepClone(value, cache))
    }
    return set
  }

  // å¤„ç†æ™®é€šå¯¹è±¡
  const tmp = {}
  cache.set(obj, tmp) // å…ˆå­˜å…¥ç¼“å­˜é˜²æ­¢å¾ªç¯å¼•ç”¨

  // å¤åˆ¶æ‰€æœ‰å¯æšä¸¾å±æ€§ï¼ˆåŒ…æ‹¬ Symbol é”®ï¼‰
  const keys = [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)]

  keys.forEach((key) => {
    tmp[key] = deepClone(obj[key], cache)
  })

  return tmp
}

// å¤„ç†åŸºæœ¬ç±»å‹
const handleBasic = (obj) => {
  return obj // åŸºæœ¬ç±»å‹ç›´æ¥è¿”å›
}

// åˆ¤æ–­æ˜¯å¦ä¸ºå¯¹è±¡
const isObject = (obj) => {
  return obj !== null && typeof obj === 'object'
}
```

## ç®—æ³•åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**: O(n) - n ä¸ºå¯¹è±¡ä¸­æ‰€æœ‰å±æ€§çš„æ€»æ•°
- **ç©ºé—´å¤æ‚åº¦**: O(n) - éœ€è¦å­˜å‚¨æ‰€æœ‰å…‹éš†çš„å¯¹è±¡å’Œç¼“å­˜
- **ç‰¹ç‚¹**: æ·±åº¦ä¼˜å…ˆéå†ï¼Œæ”¯æŒå¾ªç¯å¼•ç”¨æ£€æµ‹

## å…³é”®æŠ€æœ¯ç‚¹

### 1. å¾ªç¯å¼•ç”¨æ£€æµ‹ä¸å¤„ç†

```javascript
// ä½¿ç”¨ Map ç¼“å­˜å·²å…‹éš†çš„å¯¹è±¡
const cache = new Map()

// æ£€æµ‹å¾ªç¯å¼•ç”¨
if (cache.has(obj)) {
  return cache.get(obj) // è¿”å›å·²å…‹éš†çš„å¯¹è±¡
}

// å…ˆå­˜å…¥ç¼“å­˜ï¼Œå†è¿›è¡Œé€’å½’å…‹éš†
cache.set(obj, result)
```

### 2. æ•°æ®ç±»å‹ç²¾ç¡®åˆ¤æ–­

```javascript
// æ•°ç»„åˆ¤æ–­
Array.isArray(obj)

// å¯¹è±¡ç±»å‹åˆ¤æ–­
obj instanceof Date
obj instanceof RegExp
obj instanceof Error

// åŸºæœ¬ç±»å‹åˆ¤æ–­
typeof obj === 'object' && obj !== null
```

### 3. Symbol å±æ€§å¤„ç†

```javascript
// è·å–åŒ…æ‹¬ Symbol åœ¨å†…çš„æ‰€æœ‰å±æ€§
const keys = [
  ...Object.keys(obj), // å­—ç¬¦ä¸²é”®
  ...Object.getOwnPropertySymbols(obj), // Symbol é”®
]
```

### 4. ç‰¹æ®Šå¯¹è±¡çš„å…‹éš†æŠ€å·§

```javascript
// Date å¯¹è±¡
new Date(obj.getTime())

// RegExp å¯¹è±¡
new RegExp(obj.source, obj.flags)

// Error å¯¹è±¡
const error = new Error(obj.message)
error.name = obj.name
error.stack = obj.stack
```

### 5. å¸¸è§é™·é˜±å’Œå‘ç‚¹

- **å¿˜è®°å¤„ç†å¾ªç¯å¼•ç”¨**: å¯¼è‡´æ ˆæº¢å‡º
- **é—æ¼ Symbol å±æ€§**: Symbol é”®è¢«å¿½ç•¥
- **ç‰¹æ®Šå¯¹è±¡å¤„ç†ä¸å½“**: Dateã€RegExp ç­‰å¤±å»ç‰¹æ€§
- **åŸå‹é“¾é—®é¢˜**: åªå…‹éš†è‡ªæœ‰å±æ€§ï¼Œä¸åŒ…æ‹¬åŸå‹
- **ä¸å¯æšä¸¾å±æ€§**: Object.keys() æ— æ³•è·å–

## ä½¿ç”¨ç¤ºä¾‹

```javascript
// åŸºæœ¬å¯¹è±¡æ‹·è´
const original = {
  name: 'John',
  age: 30,
  hobbies: ['reading', 'coding'],
  address: {
    city: 'New York',
    country: 'USA',
  },
}

const cloned = deepClone(original)
cloned.address.city = 'Boston'
console.log(original.address.city) // 'New York' (æœªå—å½±å“)

// å¾ªç¯å¼•ç”¨å¤„ç†
const obj = { name: 'Alice' }
obj.self = obj
obj.friend = { name: 'Bob', bestFriend: obj }

const clonedObj = deepClone(obj)
console.log(clonedObj.self === clonedObj) // true
console.log(clonedObj.friend.bestFriend === clonedObj) // true

// ç‰¹æ®Šç±»å‹å¤„ç†
const complex = {
  date: new Date('2023-01-01'),
  regex: /hello/gi,
  error: new Error('test error'),
  map: new Map([
    ['key1', 'value1'],
    ['key2', { nested: true }],
  ]),
  set: new Set([1, 2, 3, { a: 1 }]),
  symbol: Symbol('test'),
  [Symbol('key')]: 'symbol value',
}

const clonedComplex = deepClone(complex)
console.log(clonedComplex.date instanceof Date) // true
console.log(clonedComplex.regex instanceof RegExp) // true
console.log(clonedComplex.map instanceof Map) // true

// æ•°ç»„æ·±æ‹·è´
const nestedArray = [1, 'string', [2, 3, [4, 5]], { a: 1, b: [6, 7] }, new Date()]

const clonedArray = deepClone(nestedArray)
clonedArray[2][2][0] = 999
console.log(nestedArray[2][2][0]) // 4 (æœªå—å½±å“)

// å‡½æ•°å¤„ç†ï¼ˆé€šå¸¸ä¸å…‹éš†ï¼Œä¿æŒå¼•ç”¨ï¼‰
const withFunction = {
  data: [1, 2, 3],
  method: function () {
    return this.data.length
  },
}

const clonedWithFunction = deepClone(withFunction)
console.log(clonedWithFunction.method === withFunction.method) // true
```

## è®°å¿†è¦ç‚¹

### æ ¸å¿ƒè®°å¿†ç‚¹

1. **å¾ªç¯å¼•ç”¨æ£€æµ‹** - ä½¿ç”¨ Map ç¼“å­˜å·²å…‹éš†å¯¹è±¡
2. **ç±»å‹ç²¾ç¡®åˆ¤æ–­** - instanceof å’Œ typeof ç»“åˆä½¿ç”¨
3. **Symbol å±æ€§** - ä½¿ç”¨ getOwnPropertySymbols è·å–
4. **ç‰¹æ®Šå¯¹è±¡å¤„ç†** - Dateã€RegExpã€Error ç­‰éœ€è¦ç‰¹æ®Šæ„é€ 
5. **é€’å½’å…‹éš†** - æ·±åº¦ä¼˜å…ˆéå†æ‰€æœ‰å±æ€§

### å¤„ç†é¡ºåºè®°å¿†

```javascript
// 1. æ£€æŸ¥ç¼“å­˜ï¼ˆå¾ªç¯å¼•ç”¨ï¼‰
// 2. åˆ¤æ–­ç±»å‹ï¼ˆæ•°ç»„ã€å¯¹è±¡ã€åŸºæœ¬ç±»å‹ï¼‰
// 3. åˆ›å»ºæ–°å®¹å™¨å¹¶ç¼“å­˜
// 4. é€’å½’å…‹éš†æ‰€æœ‰å±æ€§
// 5. è¿”å›å…‹éš†ç»“æœ
```

## æ‰©å±•æ€è€ƒ

### 1. æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬

```javascript
function deepCloneOptimized(obj, cache = new WeakMap()) {
  // ä½¿ç”¨ WeakMap ä¼˜åŒ–å†…å­˜ä½¿ç”¨
  if (cache.has(obj)) {
    return cache.get(obj)
  }

  // å¿«é€Ÿè·¯å¾„ï¼šåŸºæœ¬ç±»å‹ç›´æ¥è¿”å›
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // æ„é€ å‡½æ•°æ˜ å°„ï¼Œé¿å…é‡å¤ instanceof æ£€æŸ¥
  const ctorMap = new Map([
    [Date, (o) => new Date(o.getTime())],
    [RegExp, (o) => new RegExp(o.source, o.flags)],
    [Array, (o) => []],
    [Object, (o) => {}],
  ])

  const ctor = obj.constructor
  const cloner = ctorMap.get(ctor)

  if (!cloner) {
    return obj // ä¸æ”¯æŒçš„ç±»å‹ç›´æ¥è¿”å›
  }

  const result = cloner(obj)
  cache.set(obj, result)

  if (ctor === Array || ctor === Object) {
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = deepCloneOptimized(obj[key], cache)
      }
    }
  }

  return result
}
```

### 2. æ”¯æŒè‡ªå®šä¹‰å…‹éš†ç­–ç•¥

```javascript
function deepCloneWithStrategy(obj, options = {}) {
  const {
    includeNonEnumerable = false,
    includeSymbols = true,
    cloneFunction = false,
    maxDepth = Infinity,
    currentDepth = 0,
  } = options

  // æ·±åº¦é™åˆ¶
  if (currentDepth >= maxDepth) {
    return obj
  }

  const cache = options.cache || new WeakMap()

  if (cache.has(obj)) {
    return cache.get(obj)
  }

  // å‡½æ•°å¤„ç†ç­–ç•¥
  if (typeof obj === 'function') {
    if (cloneFunction) {
      // ç®€å•çš„å‡½æ•°å…‹éš†ï¼ˆæœ‰é™åˆ¶ï¼‰
      return new Function('return ' + obj.toString())()
    }
    return obj
  }

  // è·å–å±æ€§çš„ç­–ç•¥
  let keys = Object.keys(obj)

  if (includeSymbols) {
    keys = keys.concat(Object.getOwnPropertySymbols(obj))
  }

  if (includeNonEnumerable) {
    const allKeys = Object.getOwnPropertyNames(obj)
    keys = keys.concat(allKeys.filter((k) => !keys.includes(k)))
  }

  const result = Array.isArray(obj) ? [] : {}
  cache.set(obj, result)

  keys.forEach((key) => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, key)

    if (descriptor.get || descriptor.set) {
      // å¤„ç† getter/setter
      Object.defineProperty(result, key, {
        get: descriptor.get,
        set: descriptor.set,
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
      })
    } else {
      result[key] = deepCloneWithStrategy(obj[key], {
        ...options,
        currentDepth: currentDepth + 1,
        cache,
      })
    }
  })

  return result
}
```

### 3. æµå¼æ·±æ‹·è´ï¼ˆå¤„ç†å¤§å¯¹è±¡ï¼‰

```javascript
async function streamDeepClone(obj, options = {}) {
  const { chunkSize = 1000, delay = 0 } = options
  const cache = new WeakMap()

  async function cloneChunk(obj, processedCount = 0) {
    if (cache.has(obj)) {
      return cache.get(obj)
    }

    if (typeof obj !== 'object' || obj === null) {
      return obj
    }

    const result = Array.isArray(obj) ? [] : {}
    cache.set(obj, result)

    const keys = Object.keys(obj)

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i]
      result[key] = await cloneChunk(obj[key], processedCount + 1)

      // å®šæœŸè®©å‡ºæ§åˆ¶æƒ
      if (processedCount % chunkSize === 0 && delay > 0) {
        await new Promise((resolve) => setTimeout(resolve, delay))
      }
    }

    return result
  }

  return await cloneChunk(obj)
}
```

### 4. ç±»å‹å®‰å…¨çš„æ·±æ‹·è´

```javascript
function typedDeepClone(obj, typeGuards = {}) {
  const cache = new WeakMap()

  function clone(value, expectedType) {
    if (cache.has(value)) {
      return cache.get(value)
    }

    // ç±»å‹æ£€æŸ¥
    if (expectedType && typeGuards[expectedType]) {
      if (!typeGuards[expectedType](value)) {
        throw new TypeError(`Expected ${expectedType}, got ${typeof value}`)
      }
    }

    if (typeof value !== 'object' || value === null) {
      return value
    }

    const result = Array.isArray(value) ? [] : {}
    cache.set(value, result)

    for (const key in value) {
      if (value.hasOwnProperty(key)) {
        result[key] = clone(value[key])
      }
    }

    return result
  }

  return clone(obj)
}

// ä½¿ç”¨ç¤ºä¾‹
const typeGuards = {
  user: (obj) => obj && typeof obj.name === 'string' && typeof obj.age === 'number',
  product: (obj) => obj && typeof obj.id === 'number' && typeof obj.price === 'number',
}

const user = { name: 'John', age: 30, address: { city: 'NYC' } }
const clonedUser = typedDeepClone(user, typeGuards)
```

### 5. æ”¯æŒåŸå‹é“¾çš„æ·±æ‹·è´

```javascript
function deepCloneWithPrototype(obj, cache = new WeakMap()) {
  if (cache.has(obj)) {
    return cache.get(obj)
  }

  if (typeof obj !== 'object' || obj === null) {
    return obj
  }

  // ä¿æŒåŸå‹é“¾
  const proto = Object.getPrototypeOf(obj)
  const result = Object.create(proto)

  cache.set(obj, result)

  // å¤åˆ¶æ‰€æœ‰è‡ªæœ‰å±æ€§ï¼ˆåŒ…æ‹¬ä¸å¯æšä¸¾çš„ï¼‰
  const propNames = Object.getOwnPropertyNames(obj)
  const propSymbols = Object.getOwnPropertySymbols(obj)

  [...propNames, ...propSymbols].forEach(key => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, key)

    if (descriptor.value !== undefined) {
      descriptor.value = deepCloneWithPrototype(descriptor.value, cache)
    }

    Object.defineProperty(result, key, descriptor)
  })

  return result
}
```

## å¤ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£æ·±æ‹·è´ä¸æµ…æ‹·è´çš„æ ¹æœ¬åŒºåˆ«
- [ ] æŒæ¡å¾ªç¯å¼•ç”¨çš„æ£€æµ‹å’Œå¤„ç†æ–¹æ³•
- [ ] ç†Ÿç»ƒåˆ¤æ–­å’Œå¤„ç†å„ç§ JavaScript æ•°æ®ç±»å‹
- [ ] ç†è§£ Map ç¼“å­˜åœ¨å¾ªç¯å¼•ç”¨æ£€æµ‹ä¸­çš„ä½œç”¨
- [ ] æŒæ¡ Symbol å±æ€§çš„è·å–å’Œå¤åˆ¶æ–¹æ³•
- [ ] äº†è§£ç‰¹æ®Šå¯¹è±¡ï¼ˆDateã€RegExp ç­‰ï¼‰çš„å…‹éš†æŠ€å·§
- [ ] èƒ½å¤Ÿå¤„ç†å¤æ‚çš„åµŒå¥—ç»“æ„å’Œè¾¹ç•Œæƒ…å†µ
- [ ] ç†è§£æ€§èƒ½ä¼˜åŒ–å’Œå†…å­˜ç®¡ç†çš„è¦ç‚¹
- [ ] æŒæ¡è‡ªå®šä¹‰å…‹éš†ç­–ç•¥çš„æ‰©å±•æ–¹æ³•
- [ ] ç†Ÿæ‚‰å®é™…åº”ç”¨åœºæ™¯å’Œæœ€ä½³å®è·µ
      switchToHandle(el, tmp, idx, cache)
      })

  return tmp
  }

// å¤„ç†å¯¹è±¡ï¼ˆæ ¸å¿ƒï¼šå¾ªç¯å¼•ç”¨å¤„ç†ï¼‰
const handleObject = (obj, cache) => {
// æ£€æŸ¥ç¼“å­˜ï¼Œé˜²æ­¢å¾ªç¯å¼•ç”¨
if (cache.has(obj)) {
return cache.get(obj)
}

const tmp = {}
cache.set(obj, tmp) // å…ˆæ”¾å…¥ç¼“å­˜

// å¤„ç†æ™®é€šå±æ€§
Object.keys(obj).forEach((key) => {
const value = obj[key]
switchToHandle(value, tmp, key, cache)
})

// å¤„ç† Symbol å±æ€§
Object.getOwnPropertySymbols(obj).forEach((sym) => {
const value = obj[sym]
switchToHandle(value, tmp, sym, cache)
})

return tmp
}

// å¤„ç†åŸºæœ¬ç±»å‹å’Œç‰¹æ®Šå¯¹è±¡
const handleBasic = (obj) => {
// Symbol éœ€è¦é‡æ–°åˆ›å»º
if (typeof obj === 'symbol') {
return Symbol(obj.description)
}

// æ­£åˆ™è¡¨è¾¾å¼
if (obj instanceof RegExp) {
return new RegExp(obj.source, obj.flags)
}

// æ—¥æœŸå¯¹è±¡
if (obj instanceof Date) {
return new Date(obj.getTime())
}

// åŸºæœ¬ç±»å‹ç›´æ¥è¿”å›
return obj
}

// å·¥å…·å‡½æ•°
const isObject = (v) => Object.prototype.toString.call(v) === '[object Object]'

const switchToHandle = (el, tmp, idx, cache) => {
if (isObject(el)) {
tmp[idx] = handleObject(el, cache)
} else if (Array.isArray(el)) {
tmp[idx] = handleArray(el, cache)
} else {
tmp[idx] = handleBasic(el)
}
}

```

## ğŸ§  ç®—æ³•åˆ†æ

### æ ¸å¿ƒæ€è·¯

1. **ç±»å‹åˆ¤æ–­**ï¼šåŒºåˆ†æ•°ç»„ã€å¯¹è±¡ã€åŸºæœ¬ç±»å‹
2. **ç¼“å­˜æœºåˆ¶**ï¼šä½¿ç”¨ Map å­˜å‚¨å·²å¤„ç†çš„å¯¹è±¡ï¼Œé¿å…å¾ªç¯å¼•ç”¨
3. **é€’å½’å¤„ç†**ï¼šå¯¹åµŒå¥—çš„å¯¹è±¡å’Œæ•°ç»„è¿›è¡Œé€’å½’æ‹·è´

### å¾ªç¯å¼•ç”¨è§£å†³æ–¹æ¡ˆ

```

ç¬¬ä¸€æ¬¡é‡åˆ°å¯¹è±¡ A â†’ åˆ›å»ºç©ºå¯¹è±¡ A' â†’ æ”¾å…¥ç¼“å­˜ (A â†’ A')
å¤„ç† A çš„å±æ€§æ—¶é‡åˆ° A â†’ ç›´æ¥ä»ç¼“å­˜è¿”å› A'

```

### æ‰§è¡Œæµç¨‹

```

deepClone(obj) â†’ ç±»å‹åˆ¤æ–­ â†’ å¯¹åº”å¤„ç†å‡½æ•°
â†“
handleObject â†’ æ£€æŸ¥ç¼“å­˜ â†’ è®¾ç½®ç¼“å­˜ â†’ é€’å½’å¤„ç†å±æ€§
â†“
switchToHandle â†’ å†æ¬¡ç±»å‹åˆ¤æ–­ â†’ é€’å½’è°ƒç”¨

````

## ğŸ” å…³é”®æŠ€æœ¯ç‚¹

### 1. å¾ªç¯å¼•ç”¨å¤„ç†

```javascript
if (cache.has(obj)) {
  return cache.get(obj) // ç›´æ¥è¿”å›å·²åˆ›å»ºçš„å¯¹è±¡
}

const tmp = {}
cache.set(obj, tmp) // å…ˆè®¾ç½®ç¼“å­˜ï¼Œå†å¤„ç†å±æ€§
````

### 2. Symbol å±æ€§å¤„ç†

```javascript
Object.getOwnPropertySymbols(obj).forEach((sym) => {
  const value = obj[sym]
  switchToHandle(value, tmp, sym, cache)
})
```

### 3. ç‰¹æ®Šå¯¹è±¡å¤„ç†

```javascript
// RegExp
new RegExp(obj.source, obj.flags)

// Date
new Date(obj.getTime())

// Symbol
Symbol(obj.description)
```

### 4. å‡†ç¡®çš„ç±»å‹åˆ¤æ–­

```javascript
const isObject = (v) => Object.prototype.toString.call(v) === '[object Object]'
// é¿å… typeof çš„ä¸å‡†ç¡®æ€§
```

## ğŸ§ª ä½¿ç”¨ç¤ºä¾‹

### å¾ªç¯å¼•ç”¨æµ‹è¯•

```javascript
const a = { name: 'Alice' }
a.self = a

const b = deepClone(a)
console.log(b.name) // 'Alice'
console.log(b.self === b) // trueï¼Œå¾ªç¯å¼•ç”¨ä¿æŒ
console.log(b === a) // falseï¼Œä¸æ˜¯åŒä¸€ä¸ªå¯¹è±¡
```

### å¤æ‚åµŒå¥—å¯¹è±¡

```javascript
const complex = {
  arr: [1, { nested: true }],
  date: new Date(),
  regex: /test/gi,
  sym: Symbol('test'),
  [Symbol('key')]: 'symbol value',
}

const cloned = deepClone(complex)
```

### æ•°ç»„åµŒå¥—

```javascript
const nestedArr = [1, [2, [3, { deep: true }]]]
const clonedArr = deepClone(nestedArr)
```

## ğŸ’¡ å…³é”®è®°å¿†ç‚¹

1. **ç¼“å­˜æœºåˆ¶**ï¼šä½¿ç”¨ Map å­˜å‚¨ `åŸå¯¹è±¡ â†’ å…‹éš†å¯¹è±¡` çš„æ˜ å°„
2. **å…ˆç¼“å­˜å†å¤„ç†**ï¼šé¿å…æ— é™é€’å½’
3. **ç±»å‹åˆ†ç±»å¤„ç†**ï¼šæ•°ç»„ã€å¯¹è±¡ã€åŸºæœ¬ç±»å‹åˆ†åˆ«å¤„ç†
4. **Symbol å±æ€§**ï¼šéœ€è¦å•ç‹¬å¤„ç†ï¼Œä¸ä¼šè¢« `Object.keys` è·å–
5. **ç‰¹æ®Šå¯¹è±¡**ï¼šDateã€RegExpã€Symbol éœ€è¦ç‰¹æ®Šæ„é€ 

## ğŸ¤” æ‰©å±•æ€è€ƒ

### å…¶ä»–è§£å†³æ–¹æ¡ˆ

```javascript
// JSON æ–¹æ³•ï¼ˆæœ‰é™åˆ¶ï¼‰
JSON.parse(JSON.stringify(obj)) // æ— æ³•å¤„ç†å‡½æ•°ã€Symbolã€å¾ªç¯å¼•ç”¨

// ç¬¬ä¸‰æ–¹åº“
import cloneDeep from 'lodash/cloneDeep'

// ç»“æ„åŒ–å…‹éš†ï¼ˆæµè§ˆå™¨ APIï¼‰
structuredClone(obj) // ç°ä»£æµè§ˆå™¨æ”¯æŒ
```

### æ€§èƒ½ä¼˜åŒ–

- **WeakMap æ›¿ä»£ Map**ï¼šè‡ªåŠ¨åƒåœ¾å›æ”¶
- **ç±»å‹æ£€æµ‹ä¼˜åŒ–**ï¼šå‡å°‘ `toString.call` è°ƒç”¨
- **æµ…æ‹·è´æ£€æµ‹**ï¼šå¦‚æœæ²¡æœ‰åµŒå¥—å¯¹è±¡ï¼Œç›´æ¥æµ…æ‹·è´

### è¾¹ç•Œæƒ…å†µ

- **Function å¤„ç†**ï¼šå‡½æ•°æ— æ³•å®Œç¾å…‹éš†
- **DOM èŠ‚ç‚¹**ï¼šéœ€è¦ç‰¹æ®Šå¤„ç†
- **å¤§å¯¹è±¡**ï¼šå¯èƒ½å¯¼è‡´æ ˆæº¢å‡º

## ğŸ“ å¤ä¹ è¦ç‚¹

- [ ] ç†è§£æ·±æ‹·è´ä¸æµ…æ‹·è´çš„åŒºåˆ«
- [ ] æŒæ¡å¾ªç¯å¼•ç”¨çš„æ£€æµ‹å’Œå¤„ç†æ–¹æ³•
- [ ] ç†Ÿæ‚‰å„ç§æ•°æ®ç±»å‹çš„å…‹éš†æ–¹å¼
- [ ] ç†è§£ç¼“å­˜æœºåˆ¶çš„ä½œç”¨å’Œå®ç°
- [ ] æŒæ¡ Symbol å±æ€§çš„å¤„ç†æ–¹æ³•
- [ ] èƒ½å¤Ÿè§£é‡Šä¸ºä»€ä¹ˆè¦å…ˆè®¾ç½®ç¼“å­˜å†å¤„ç†å±æ€§
