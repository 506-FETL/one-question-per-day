# Day 05 复习文档

## 题目描述

实现一个完整的**深拷贝函数**，要求：

- 支持对象和数组的深层复制
- 解决循环引用问题
- 处理各种数据类型（Date、RegExp、Symbol 等）
- 保持原对象的所有特性和属性

本题考查 **递归算法**、**数据类型判断** 和 **循环引用处理** 的综合能力。

## 核心知识点

### 1. 深拷贝 vs 浅拷贝

- **浅拷贝**: 只复制对象的第一层属性，深层属性仍共享引用
- **深拷贝**: 递归复制所有层级的属性，创建完全独立的副本
- **应用场景**: 防止意外修改、状态管理、数据备份

### 2. 循环引用问题

```javascript
const a = { name: 'Alice' }
a.self = a // 创建循环引用

// 不处理循环引用会导致：
// RangeError: Maximum call stack size exceeded
```

### 3. JavaScript 数据类型分类

- **基本类型**: number, string, boolean, undefined, null, symbol, bigint
- **引用类型**: Object, Array, Date, RegExp, Function, Map, Set 等
- **特殊处理**: Symbol 键、不可枚举属性、getter/setter

## 代码实现

```javascript
export default function deepClone(obj, cache = new Map()) {
  // 处理循环引用：如果已经克隆过，直接返回
  if (cache.has(obj)) {
    return cache.get(obj)
  }

  let result = null

  if (Array.isArray(obj)) {
    result = handleArray(obj, cache)
  } else if (isObject(obj)) {
    result = handleObject(obj, cache)
  } else {
    result = handleBasic(obj)
  }

  return result
}

// 处理数组
const handleArray = (arr, cache) => {
  const tmp = []

  // 先将结果存入缓存，防止循环引用
  cache.set(arr, tmp)

  arr.forEach((el, idx) => {
    tmp[idx] = deepClone(el, cache)
  })

  return tmp
}

// 处理对象
const handleObject = (obj, cache) => {
  // 处理特殊对象类型
  if (obj instanceof Date) {
    return new Date(obj.getTime())
  }

  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags)
  }

  if (obj instanceof Error) {
    const error = new Error(obj.message)
    error.name = obj.name
    error.stack = obj.stack
    return error
  }

  // 处理 Map
  if (obj instanceof Map) {
    const map = new Map()
    cache.set(obj, map)
    for (const [key, value] of obj) {
      map.set(deepClone(key, cache), deepClone(value, cache))
    }
    return map
  }

  // 处理 Set
  if (obj instanceof Set) {
    const set = new Set()
    cache.set(obj, set)
    for (const value of obj) {
      set.add(deepClone(value, cache))
    }
    return set
  }

  // 处理普通对象
  const tmp = {}
  cache.set(obj, tmp) // 先存入缓存防止循环引用

  // 复制所有可枚举属性（包括 Symbol 键）
  const keys = [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)]

  keys.forEach((key) => {
    tmp[key] = deepClone(obj[key], cache)
  })

  return tmp
}

// 处理基本类型
const handleBasic = (obj) => {
  return obj // 基本类型直接返回
}

// 判断是否为对象
const isObject = (obj) => {
  return obj !== null && typeof obj === 'object'
}
```

## 算法分析

- **时间复杂度**: O(n) - n 为对象中所有属性的总数
- **空间复杂度**: O(n) - 需要存储所有克隆的对象和缓存
- **特点**: 深度优先遍历，支持循环引用检测

## 关键技术点

### 1. 循环引用检测与处理

```javascript
// 使用 Map 缓存已克隆的对象
const cache = new Map()

// 检测循环引用
if (cache.has(obj)) {
  return cache.get(obj) // 返回已克隆的对象
}

// 先存入缓存，再进行递归克隆
cache.set(obj, result)
```

### 2. 数据类型精确判断

```javascript
// 数组判断
Array.isArray(obj)

// 对象类型判断
obj instanceof Date
obj instanceof RegExp
obj instanceof Error

// 基本类型判断
typeof obj === 'object' && obj !== null
```

### 3. Symbol 属性处理

```javascript
// 获取包括 Symbol 在内的所有属性
const keys = [
  ...Object.keys(obj), // 字符串键
  ...Object.getOwnPropertySymbols(obj), // Symbol 键
]
```

### 4. 特殊对象的克隆技巧

```javascript
// Date 对象
new Date(obj.getTime())

// RegExp 对象
new RegExp(obj.source, obj.flags)

// Error 对象
const error = new Error(obj.message)
error.name = obj.name
error.stack = obj.stack
```

### 5. 常见陷阱和坑点

- **忘记处理循环引用**: 导致栈溢出
- **遗漏 Symbol 属性**: Symbol 键被忽略
- **特殊对象处理不当**: Date、RegExp 等失去特性
- **原型链问题**: 只克隆自有属性，不包括原型
- **不可枚举属性**: Object.keys() 无法获取

## 使用示例

```javascript
// 基本对象拷贝
const original = {
  name: 'John',
  age: 30,
  hobbies: ['reading', 'coding'],
  address: {
    city: 'New York',
    country: 'USA',
  },
}

const cloned = deepClone(original)
cloned.address.city = 'Boston'
console.log(original.address.city) // 'New York' (未受影响)

// 循环引用处理
const obj = { name: 'Alice' }
obj.self = obj
obj.friend = { name: 'Bob', bestFriend: obj }

const clonedObj = deepClone(obj)
console.log(clonedObj.self === clonedObj) // true
console.log(clonedObj.friend.bestFriend === clonedObj) // true

// 特殊类型处理
const complex = {
  date: new Date('2023-01-01'),
  regex: /hello/gi,
  error: new Error('test error'),
  map: new Map([
    ['key1', 'value1'],
    ['key2', { nested: true }],
  ]),
  set: new Set([1, 2, 3, { a: 1 }]),
  symbol: Symbol('test'),
  [Symbol('key')]: 'symbol value',
}

const clonedComplex = deepClone(complex)
console.log(clonedComplex.date instanceof Date) // true
console.log(clonedComplex.regex instanceof RegExp) // true
console.log(clonedComplex.map instanceof Map) // true

// 数组深拷贝
const nestedArray = [1, 'string', [2, 3, [4, 5]], { a: 1, b: [6, 7] }, new Date()]

const clonedArray = deepClone(nestedArray)
clonedArray[2][2][0] = 999
console.log(nestedArray[2][2][0]) // 4 (未受影响)

// 函数处理（通常不克隆，保持引用）
const withFunction = {
  data: [1, 2, 3],
  method: function () {
    return this.data.length
  },
}

const clonedWithFunction = deepClone(withFunction)
console.log(clonedWithFunction.method === withFunction.method) // true
```

## 记忆要点

### 核心记忆点

1. **循环引用检测** - 使用 Map 缓存已克隆对象
2. **类型精确判断** - instanceof 和 typeof 结合使用
3. **Symbol 属性** - 使用 getOwnPropertySymbols 获取
4. **特殊对象处理** - Date、RegExp、Error 等需要特殊构造
5. **递归克隆** - 深度优先遍历所有属性

### 处理顺序记忆

```javascript
// 1. 检查缓存（循环引用）
// 2. 判断类型（数组、对象、基本类型）
// 3. 创建新容器并缓存
// 4. 递归克隆所有属性
// 5. 返回克隆结果
```

## 扩展思考

### 1. 性能优化版本

```javascript
function deepCloneOptimized(obj, cache = new WeakMap()) {
  // 使用 WeakMap 优化内存使用
  if (cache.has(obj)) {
    return cache.get(obj)
  }

  // 快速路径：基本类型直接返回
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // 构造函数映射，避免重复 instanceof 检查
  const ctorMap = new Map([
    [Date, (o) => new Date(o.getTime())],
    [RegExp, (o) => new RegExp(o.source, o.flags)],
    [Array, (o) => []],
    [Object, (o) => {}],
  ])

  const ctor = obj.constructor
  const cloner = ctorMap.get(ctor)

  if (!cloner) {
    return obj // 不支持的类型直接返回
  }

  const result = cloner(obj)
  cache.set(obj, result)

  if (ctor === Array || ctor === Object) {
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = deepCloneOptimized(obj[key], cache)
      }
    }
  }

  return result
}
```

### 2. 支持自定义克隆策略

```javascript
function deepCloneWithStrategy(obj, options = {}) {
  const {
    includeNonEnumerable = false,
    includeSymbols = true,
    cloneFunction = false,
    maxDepth = Infinity,
    currentDepth = 0,
  } = options

  // 深度限制
  if (currentDepth >= maxDepth) {
    return obj
  }

  const cache = options.cache || new WeakMap()

  if (cache.has(obj)) {
    return cache.get(obj)
  }

  // 函数处理策略
  if (typeof obj === 'function') {
    if (cloneFunction) {
      // 简单的函数克隆（有限制）
      return new Function('return ' + obj.toString())()
    }
    return obj
  }

  // 获取属性的策略
  let keys = Object.keys(obj)

  if (includeSymbols) {
    keys = keys.concat(Object.getOwnPropertySymbols(obj))
  }

  if (includeNonEnumerable) {
    const allKeys = Object.getOwnPropertyNames(obj)
    keys = keys.concat(allKeys.filter((k) => !keys.includes(k)))
  }

  const result = Array.isArray(obj) ? [] : {}
  cache.set(obj, result)

  keys.forEach((key) => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, key)

    if (descriptor.get || descriptor.set) {
      // 处理 getter/setter
      Object.defineProperty(result, key, {
        get: descriptor.get,
        set: descriptor.set,
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
      })
    } else {
      result[key] = deepCloneWithStrategy(obj[key], {
        ...options,
        currentDepth: currentDepth + 1,
        cache,
      })
    }
  })

  return result
}
```

### 3. 流式深拷贝（处理大对象）

```javascript
async function streamDeepClone(obj, options = {}) {
  const { chunkSize = 1000, delay = 0 } = options
  const cache = new WeakMap()

  async function cloneChunk(obj, processedCount = 0) {
    if (cache.has(obj)) {
      return cache.get(obj)
    }

    if (typeof obj !== 'object' || obj === null) {
      return obj
    }

    const result = Array.isArray(obj) ? [] : {}
    cache.set(obj, result)

    const keys = Object.keys(obj)

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i]
      result[key] = await cloneChunk(obj[key], processedCount + 1)

      // 定期让出控制权
      if (processedCount % chunkSize === 0 && delay > 0) {
        await new Promise((resolve) => setTimeout(resolve, delay))
      }
    }

    return result
  }

  return await cloneChunk(obj)
}
```

### 4. 类型安全的深拷贝

```javascript
function typedDeepClone(obj, typeGuards = {}) {
  const cache = new WeakMap()

  function clone(value, expectedType) {
    if (cache.has(value)) {
      return cache.get(value)
    }

    // 类型检查
    if (expectedType && typeGuards[expectedType]) {
      if (!typeGuards[expectedType](value)) {
        throw new TypeError(`Expected ${expectedType}, got ${typeof value}`)
      }
    }

    if (typeof value !== 'object' || value === null) {
      return value
    }

    const result = Array.isArray(value) ? [] : {}
    cache.set(value, result)

    for (const key in value) {
      if (value.hasOwnProperty(key)) {
        result[key] = clone(value[key])
      }
    }

    return result
  }

  return clone(obj)
}

// 使用示例
const typeGuards = {
  user: (obj) => obj && typeof obj.name === 'string' && typeof obj.age === 'number',
  product: (obj) => obj && typeof obj.id === 'number' && typeof obj.price === 'number',
}

const user = { name: 'John', age: 30, address: { city: 'NYC' } }
const clonedUser = typedDeepClone(user, typeGuards)
```

### 5. 支持原型链的深拷贝

```javascript
function deepCloneWithPrototype(obj, cache = new WeakMap()) {
  if (cache.has(obj)) {
    return cache.get(obj)
  }

  if (typeof obj !== 'object' || obj === null) {
    return obj
  }

  // 保持原型链
  const proto = Object.getPrototypeOf(obj)
  const result = Object.create(proto)

  cache.set(obj, result)

  // 复制所有自有属性（包括不可枚举的）
  const propNames = Object.getOwnPropertyNames(obj)
  const propSymbols = Object.getOwnPropertySymbols(obj)

  [...propNames, ...propSymbols].forEach(key => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, key)

    if (descriptor.value !== undefined) {
      descriptor.value = deepCloneWithPrototype(descriptor.value, cache)
    }

    Object.defineProperty(result, key, descriptor)
  })

  return result
}
```

## 复习检查清单

- [ ] 理解深拷贝与浅拷贝的根本区别
- [ ] 掌握循环引用的检测和处理方法
- [ ] 熟练判断和处理各种 JavaScript 数据类型
- [ ] 理解 Map 缓存在循环引用检测中的作用
- [ ] 掌握 Symbol 属性的获取和复制方法
- [ ] 了解特殊对象（Date、RegExp 等）的克隆技巧
- [ ] 能够处理复杂的嵌套结构和边界情况
- [ ] 理解性能优化和内存管理的要点
- [ ] 掌握自定义克隆策略的扩展方法
- [ ] 熟悉实际应用场景和最佳实践
      switchToHandle(el, tmp, idx, cache)
      })

  return tmp
  }

// 处理对象（核心：循环引用处理）
const handleObject = (obj, cache) => {
// 检查缓存，防止循环引用
if (cache.has(obj)) {
return cache.get(obj)
}

const tmp = {}
cache.set(obj, tmp) // 先放入缓存

// 处理普通属性
Object.keys(obj).forEach((key) => {
const value = obj[key]
switchToHandle(value, tmp, key, cache)
})

// 处理 Symbol 属性
Object.getOwnPropertySymbols(obj).forEach((sym) => {
const value = obj[sym]
switchToHandle(value, tmp, sym, cache)
})

return tmp
}

// 处理基本类型和特殊对象
const handleBasic = (obj) => {
// Symbol 需要重新创建
if (typeof obj === 'symbol') {
return Symbol(obj.description)
}

// 正则表达式
if (obj instanceof RegExp) {
return new RegExp(obj.source, obj.flags)
}

// 日期对象
if (obj instanceof Date) {
return new Date(obj.getTime())
}

// 基本类型直接返回
return obj
}

// 工具函数
const isObject = (v) => Object.prototype.toString.call(v) === '[object Object]'

const switchToHandle = (el, tmp, idx, cache) => {
if (isObject(el)) {
tmp[idx] = handleObject(el, cache)
} else if (Array.isArray(el)) {
tmp[idx] = handleArray(el, cache)
} else {
tmp[idx] = handleBasic(el)
}
}

```

## 🧠 算法分析

### 核心思路

1. **类型判断**：区分数组、对象、基本类型
2. **缓存机制**：使用 Map 存储已处理的对象，避免循环引用
3. **递归处理**：对嵌套的对象和数组进行递归拷贝

### 循环引用解决方案

```

第一次遇到对象 A → 创建空对象 A' → 放入缓存 (A → A')
处理 A 的属性时遇到 A → 直接从缓存返回 A'

```

### 执行流程

```

deepClone(obj) → 类型判断 → 对应处理函数
↓
handleObject → 检查缓存 → 设置缓存 → 递归处理属性
↓
switchToHandle → 再次类型判断 → 递归调用

````

## 🔍 关键技术点

### 1. 循环引用处理

```javascript
if (cache.has(obj)) {
  return cache.get(obj) // 直接返回已创建的对象
}

const tmp = {}
cache.set(obj, tmp) // 先设置缓存，再处理属性
````

### 2. Symbol 属性处理

```javascript
Object.getOwnPropertySymbols(obj).forEach((sym) => {
  const value = obj[sym]
  switchToHandle(value, tmp, sym, cache)
})
```

### 3. 特殊对象处理

```javascript
// RegExp
new RegExp(obj.source, obj.flags)

// Date
new Date(obj.getTime())

// Symbol
Symbol(obj.description)
```

### 4. 准确的类型判断

```javascript
const isObject = (v) => Object.prototype.toString.call(v) === '[object Object]'
// 避免 typeof 的不准确性
```

## 🧪 使用示例

### 循环引用测试

```javascript
const a = { name: 'Alice' }
a.self = a

const b = deepClone(a)
console.log(b.name) // 'Alice'
console.log(b.self === b) // true，循环引用保持
console.log(b === a) // false，不是同一个对象
```

### 复杂嵌套对象

```javascript
const complex = {
  arr: [1, { nested: true }],
  date: new Date(),
  regex: /test/gi,
  sym: Symbol('test'),
  [Symbol('key')]: 'symbol value',
}

const cloned = deepClone(complex)
```

### 数组嵌套

```javascript
const nestedArr = [1, [2, [3, { deep: true }]]]
const clonedArr = deepClone(nestedArr)
```

## 💡 关键记忆点

1. **缓存机制**：使用 Map 存储 `原对象 → 克隆对象` 的映射
2. **先缓存再处理**：避免无限递归
3. **类型分类处理**：数组、对象、基本类型分别处理
4. **Symbol 属性**：需要单独处理，不会被 `Object.keys` 获取
5. **特殊对象**：Date、RegExp、Symbol 需要特殊构造

## 🤔 扩展思考

### 其他解决方案

```javascript
// JSON 方法（有限制）
JSON.parse(JSON.stringify(obj)) // 无法处理函数、Symbol、循环引用

// 第三方库
import cloneDeep from 'lodash/cloneDeep'

// 结构化克隆（浏览器 API）
structuredClone(obj) // 现代浏览器支持
```

### 性能优化

- **WeakMap 替代 Map**：自动垃圾回收
- **类型检测优化**：减少 `toString.call` 调用
- **浅拷贝检测**：如果没有嵌套对象，直接浅拷贝

### 边界情况

- **Function 处理**：函数无法完美克隆
- **DOM 节点**：需要特殊处理
- **大对象**：可能导致栈溢出

## 📝 复习要点

- [ ] 理解深拷贝与浅拷贝的区别
- [ ] 掌握循环引用的检测和处理方法
- [ ] 熟悉各种数据类型的克隆方式
- [ ] 理解缓存机制的作用和实现
- [ ] 掌握 Symbol 属性的处理方法
- [ ] 能够解释为什么要先设置缓存再处理属性
