# Day 06 å¤ä¹ æ–‡æ¡£

## é¢˜ç›®æè¿°

æ‰‹å†™å®ç° **Array.from æ–¹æ³•**ï¼Œè¦æ±‚ï¼š

- å°†ç±»æ•°ç»„å¯¹è±¡æˆ–å¯è¿­ä»£å¯¹è±¡è½¬æ¢ä¸ºæ•°ç»„
- æ”¯æŒå¯é€‰çš„æ˜ å°„å‡½æ•° mapFn
- æ”¯æŒå¯é€‰çš„ this ç»‘å®š thisArg
- å®ç°è¾…åŠ©å‡½æ•° toInteger å’Œ toLength
- å®Œæ•´çš„å‚æ•°éªŒè¯å’Œé”™è¯¯å¤„ç†

æœ¬é¢˜è€ƒæŸ¥ **ES6 è§„èŒƒç†è§£**ã€**ç±»å‹æ£€æµ‹** å’Œ **å‡½æ•°å¼ç¼–ç¨‹** çš„ç»¼åˆèƒ½åŠ›ã€‚

## æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. Array.from çš„å¤šé‡ç”¨é€”

- **ç±»æ•°ç»„è½¬æ¢**: å°† NodeListã€arguments ç­‰è½¬ä¸ºçœŸæ­£æ•°ç»„
- **å¯è¿­ä»£å¯¹è±¡è½¬æ¢**: å¤„ç† Setã€Mapã€å­—ç¬¦ä¸²ç­‰
- **æ•°ç»„æ˜ å°„**: ç»“åˆ map åŠŸèƒ½ï¼Œä¸€æ­¥å®Œæˆè½¬æ¢å’Œå¤„ç†
- **å¡«å……æ•°ç»„**: é…åˆ Array æ„é€ å‡½æ•°åˆ›å»ºæŒ‡å®šé•¿åº¦æ•°ç»„

### 2. ç±»æ•°ç»„å¯¹è±¡è¯†åˆ«æ ‡å‡†

```javascript
// ç±»æ•°ç»„å¯¹è±¡ç‰¹å¾ï¼š
// 1. æœ‰ length å±æ€§
// 2. length æ˜¯éè´Ÿæ•´æ•°
// 3. æœ‰å¯¹åº”ç´¢å¼•çš„å±æ€§

const arrayLike = {
  0: 'first',
  1: 'second',
  2: 'third',
  length: 3,
}
```

### 3. å¯è¿­ä»£å¯¹è±¡åè®®

```javascript
// å®ç° Symbol.iterator æ–¹æ³•çš„å¯¹è±¡
const iterable = {
  *[Symbol.iterator]() {
    yield 1
    yield 2
    yield 3
  },
}
```

### 4. ECMAScript è§„èŒƒä¸­çš„æŠ½è±¡æ“ä½œ

- **ToInteger**: å°†å€¼è½¬æ¢ä¸ºæ•´æ•°
- **ToLength**: ç¡®ä¿é•¿åº¦åœ¨å®‰å…¨èŒƒå›´å†…
- **IsCallable**: æ£€æµ‹å€¼æ˜¯å¦å¯è°ƒç”¨
- **GetMethod**: è·å–å¯¹è±¡çš„æ–¹æ³•

## ä»£ç å®ç°

```javascript
export default function myFrom(arrayLike, mapFn, thisArg) {
  // å‡½æ•°å¯è°ƒç”¨æ€§æ£€æµ‹
  const isCallable = (fn) =>
    typeof fn === 'function' || Object.prototype.toString.call(fn) === '[object Function]'

  // ES è§„èŒƒï¼šToInteger æ“ä½œ
  const toInteger = (v) => {
    const _v = Number(v)
    if (isNaN(_v)) return 0
    if (v === 0 || !isFinite(_v)) return _v

    // å¸¦ç¬¦å·çš„å‘ä¸‹å–æ•´
    return (_v > 0 ? 1 : -1) * Math.floor(Math.abs(_v))
  }

  // ES è§„èŒƒï¼šToLength æ“ä½œ
  const toLength = (v) => {
    const len = toInteger(v)
    return Math.min(Math.max(len, 0), Number.MAX_SAFE_INTEGER)
  }

  // å‚æ•°éªŒè¯
  if (arrayLike == null) {
    throw new TypeError('Array.from called on null or undefined')
  }

  if (mapFn !== undefined && !isCallable(mapFn)) {
    throw new TypeError(
      'Array.from: when provided, the second argument must be a function',
    )
  }

  // è½¬æ¢ä¸ºå¯¹è±¡
  const O = Object(arrayLike)

  // æ£€æŸ¥æ˜¯å¦æ˜¯å¯è¿­ä»£å¯¹è±¡
  const iteratorMethod = O[Symbol.iterator]

  if (iteratorMethod != null) {
    // å¤„ç†å¯è¿­ä»£å¯¹è±¡è·¯å¾„
    if (!isCallable(iteratorMethod)) {
      throw new TypeError('Array.from: @@iterator property is not a function')
    }

    return handleIterable(O, iteratorMethod, mapFn, thisArg)
  } else {
    // å¤„ç†ç±»æ•°ç»„å¯¹è±¡è·¯å¾„
    return handleArrayLike(O, mapFn, thisArg)
  }
}

// å¤„ç†å¯è¿­ä»£å¯¹è±¡
function handleIterable(O, iteratorMethod, mapFn, thisArg) {
  const result = []
  const iterator = iteratorMethod.call(O)
  let index = 0

  try {
    while (true) {
      const next = iterator.next()

      if (next.done) {
        break
      }

      let value = next.value

      if (mapFn) {
        try {
          value = mapFn.call(thisArg, value, index)
        } catch (error) {
          // ç¡®ä¿è¿­ä»£å™¨è¢«æ­£ç¡®å…³é—­
          if (typeof iterator.return === 'function') {
            iterator.return()
          }
          throw error
        }
      }

      result[index] = value
      index++

      // é˜²æ­¢æ— é™è¿­ä»£
      if (index >= Number.MAX_SAFE_INTEGER) {
        throw new RangeError('Array.from: array too large')
      }
    }
  } catch (error) {
    // ç¡®ä¿è¿­ä»£å™¨è¢«æ­£ç¡®å…³é—­
    if (typeof iterator.return === 'function') {
      try {
        iterator.return()
      } catch (returnError) {
        // å¿½ç•¥ return æ–¹æ³•çš„é”™è¯¯
      }
    }
    throw error
  }

  return result
}

// å¤„ç†ç±»æ•°ç»„å¯¹è±¡
function handleArrayLike(O, mapFn, thisArg) {
  const len = toLength(O.length)
  const result = new Array(len)

  for (let i = 0; i < len; i++) {
    let value = O[i]

    if (mapFn) {
      value = mapFn.call(thisArg, value, i)
    }

    result[i] = value
  }

  return result
}

// è¾…åŠ©å‡½æ•°ï¼šToInteger å®ç°
const toInteger = (v) => {
  const _v = Number(v)
  if (isNaN(_v)) return 0
  if (v === 0 || !isFinite(_v)) return _v

  return (_v > 0 ? 1 : -1) * Math.floor(Math.abs(_v))
}

// è¾…åŠ©å‡½æ•°ï¼šToLength å®ç°
const toLength = (v) => {
  const len = toInteger(v)
  return Math.min(Math.max(len, 0), Number.MAX_SAFE_INTEGER)
}
```

## ç®—æ³•åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**: O(n) - n ä¸ºæºå¯¹è±¡çš„é•¿åº¦
- **ç©ºé—´å¤æ‚åº¦**: O(n) - éœ€è¦åˆ›å»ºæ–°æ•°ç»„å­˜å‚¨ç»“æœ
- **ç‰¹ç‚¹**: æ”¯æŒä¸¤ç§ä¸åŒçš„è½¬æ¢è·¯å¾„ï¼Œä¸¥æ ¼éµå¾ª ES è§„èŒƒ

## å…³é”®æŠ€æœ¯ç‚¹

### 1. åŒè·¯å¾„å¤„ç†ç­–ç•¥

```javascript
// è·¯å¾„1ï¼šå¯è¿­ä»£å¯¹è±¡
if (O[Symbol.iterator] != null) {
  return handleIterable(O, iteratorMethod, mapFn, thisArg)
}

// è·¯å¾„2ï¼šç±»æ•°ç»„å¯¹è±¡
return handleArrayLike(O, mapFn, thisArg)
```

### 2. ä¸¥æ ¼çš„ç±»å‹æ£€æµ‹

```javascript
// å‡½æ•°æ£€æµ‹
const isCallable = (fn) =>
  typeof fn === 'function' || Object.prototype.toString.call(fn) === '[object Function]'

// null/undefined æ£€æµ‹
if (arrayLike == null) {
  throw new TypeError('Array.from called on null or undefined')
}
```

### 3. ES è§„èŒƒçš„æ•°å€¼è½¬æ¢

```javascript
// ToInteger: å¤„ç†å„ç§è¾¹ç•Œæƒ…å†µ
const toInteger = (v) => {
  const _v = Number(v)
  if (isNaN(_v)) return 0 // NaN -> 0
  if (v === 0 || !isFinite(_v)) return _v // 0, Â±Infinity

  // å¸¦ç¬¦å·çš„å‘ä¸‹å–æ•´
  return (_v > 0 ? 1 : -1) * Math.floor(Math.abs(_v))
}

// ToLength: ç¡®ä¿åœ¨å®‰å…¨æ•´æ•°èŒƒå›´å†…
const toLength = (v) => {
  const len = toInteger(v)
  return Math.min(Math.max(len, 0), Number.MAX_SAFE_INTEGER)
}
```

### 4. è¿­ä»£å™¨èµ„æºç®¡ç†

```javascript
try {
  // è¿­ä»£è¿‡ç¨‹
  while (true) {
    const next = iterator.next()
    if (next.done) break
    // å¤„ç†å€¼...
  }
} catch (error) {
  // ç¡®ä¿è¿­ä»£å™¨è¢«æ­£ç¡®å…³é—­
  if (typeof iterator.return === 'function') {
    try {
      iterator.return()
    } catch (returnError) {
      // å¿½ç•¥ return æ–¹æ³•çš„é”™è¯¯
    }
  }
  throw error
}
```

### 5. å¸¸è§é™·é˜±å’Œå‘ç‚¹

- **å¿˜è®°å¤„ç†å¯è¿­ä»£å¯¹è±¡**: åªè€ƒè™‘ç±»æ•°ç»„æƒ…å†µ
- **this ç»‘å®šé”™è¯¯**: mapFn çš„æ‰§è¡Œä¸Šä¸‹æ–‡å¤„ç†ä¸å½“
- **æ•°å€¼è½¬æ¢ä¸å½“**: ä¸éµå¾ª ES è§„èŒƒçš„è½¬æ¢è§„åˆ™
- **è¿­ä»£å™¨æ³„æ¼**: å¼‚å¸¸æ—¶æœªæ­£ç¡®å…³é—­è¿­ä»£å™¨
- **è¾¹ç•Œå€¼å¤„ç†**: length ä¸ºè´Ÿæ•°æˆ–è¶…å¤§å€¼çš„æƒ…å†µ

## ä½¿ç”¨ç¤ºä¾‹

```javascript
// åŸºæœ¬ç±»æ•°ç»„è½¬æ¢
const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 }
console.log(myFrom(arrayLike)) // ['a', 'b', 'c']

// NodeList è½¬æ¢ï¼ˆæµè§ˆå™¨ç¯å¢ƒï¼‰
const divs = document.querySelectorAll('div')
const divArray = myFrom(divs)
console.log(Array.isArray(divArray)) // true

// å­—ç¬¦ä¸²è½¬æ¢
console.log(myFrom('hello')) // ['h', 'e', 'l', 'l', 'o']
console.log(myFrom('ğŸ‰ğŸŒŸ')) // ['ğŸ‰', 'ğŸŒŸ']

// Set/Map è½¬æ¢
const set = new Set([1, 2, 3, 2, 1])
console.log(myFrom(set)) // [1, 2, 3]

const map = new Map([
  ['a', 1],
  ['b', 2],
])
console.log(myFrom(map)) // [['a', 1], ['b', 2]]

// é…åˆæ˜ å°„å‡½æ•°
const numbers = { 0: '1', 1: '2', 2: '3', length: 3 }
const doubled = myFrom(numbers, (x) => parseInt(x) * 2)
console.log(doubled) // [2, 4, 6]

// this ç»‘å®šç¤ºä¾‹
const multiplier = {
  factor: 10,
  multiply(x) {
    return x * this.factor
  },
}

const values = { 0: 1, 1: 2, 2: 3, length: 3 }
const result = myFrom(values, multiplier.multiply, multiplier)
console.log(result) // [10, 20, 30]

// arguments å¯¹è±¡è½¬æ¢
function testArgs() {
  const argsArray = myFrom(arguments, (arg, index) => `${index}: ${arg}`)
  return argsArray
}
console.log(testArgs('a', 'b', 'c')) // ['0: a', '1: b', '2: c']

// åˆ›å»ºæŒ‡å®šé•¿åº¦æ•°ç»„
const emptyArray = myFrom({ length: 5 }, (_, i) => i * i)
console.log(emptyArray) // [0, 1, 4, 9, 16]

// å¤„ç†ç¨€ç–æ•°ç»„
const sparse = { 0: 'a', 2: 'c', length: 4 }
console.log(myFrom(sparse)) // ['a', undefined, 'c', undefined]

// è‡ªå®šä¹‰å¯è¿­ä»£å¯¹è±¡
const customIterable = {
  *[Symbol.iterator]() {
    yield 'first'
    yield 'second'
    yield 'third'
  },
}
console.log(myFrom(customIterable)) // ['first', 'second', 'third']

// é”™è¯¯å¤„ç†ç¤ºä¾‹
try {
  myFrom(null) // TypeError: Array.from called on null or undefined
} catch (e) {
  console.log(e.message)
}

try {
  myFrom([1, 2, 3], 'not a function') // TypeError: second argument must be a function
} catch (e) {
  console.log(e.message)
}
```

## è®°å¿†è¦ç‚¹

### æ ¸å¿ƒè®°å¿†ç‚¹

1. **åŒè·¯å¾„å¤„ç†** - å¯è¿­ä»£å¯¹è±¡å’Œç±»æ•°ç»„å¯¹è±¡ä¸åŒå¤„ç†
2. **ES è§„èŒƒéµå¾ª** - ToIntegerã€ToLength çš„æ­£ç¡®å®ç°
3. **è¿­ä»£å™¨ç®¡ç†** - ç¡®ä¿èµ„æºæ­£ç¡®é‡Šæ”¾
4. **ç±»å‹å®‰å…¨** - ä¸¥æ ¼çš„å‚æ•°éªŒè¯å’Œé”™è¯¯å¤„ç†
5. **this ç»‘å®š** - mapFn çš„æ‰§è¡Œä¸Šä¸‹æ–‡æ­£ç¡®ä¼ é€’

### åˆ¤æ–­é¡ºåºè®°å¿†

```javascript
// 1. å‚æ•°éªŒè¯ï¼ˆnull æ£€æŸ¥ã€å‡½æ•°æ£€æŸ¥ï¼‰
// 2. å¯¹è±¡è½¬æ¢ï¼ˆObject(arrayLike)ï¼‰
// 3. è·¯å¾„é€‰æ‹©ï¼ˆSymbol.iterator å­˜åœ¨æ€§ï¼‰
// 4. æ‰§è¡Œè½¬æ¢ï¼ˆè¿­ä»£å™¨ vs ç´¢å¼•è®¿é—®ï¼‰
// 5. è¿”å›ç»“æœ
```

## æ‰©å±•æ€è€ƒ

### 1. æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬

```javascript
// é’ˆå¯¹å¸¸è§æƒ…å†µçš„å¿«é€Ÿè·¯å¾„
function optimizedMyFrom(arrayLike, mapFn, thisArg) {
  // å¿«é€Ÿè·¯å¾„ï¼šçœŸæ•°ç»„ä¸”æ— æ˜ å°„å‡½æ•°
  if (Array.isArray(arrayLike) && !mapFn) {
    return arrayLike.slice() // æµ…æ‹·è´
  }

  // å¿«é€Ÿè·¯å¾„ï¼šå­—ç¬¦ä¸²ä¸”æ— æ˜ å°„å‡½æ•°
  if (typeof arrayLike === 'string' && !mapFn) {
    return [...arrayLike] // åˆ©ç”¨æ‰©å±•è¿ç®—ç¬¦
  }

  // å›é€€åˆ°å®Œæ•´å®ç°
  return myFrom(arrayLike, mapFn, thisArg)
}
```

### 2. æ”¯æŒå¼‚æ­¥æ˜ å°„å‡½æ•°

```javascript
async function asyncMyFrom(arrayLike, asyncMapFn, thisArg) {
  const items = myFrom(arrayLike) // å…ˆè½¬æ¢ä¸ºæ•°ç»„

  if (!asyncMapFn) {
    return items
  }

  const results = []
  for (let i = 0; i < items.length; i++) {
    const result = await asyncMapFn.call(thisArg, items[i], i)
    results[i] = result
  }

  return results
}

// ä½¿ç”¨ç¤ºä¾‹
const urls = ['url1', 'url2', 'url3']
const responses = await asyncMyFrom(urls, async (url) => {
  const response = await fetch(url)
  return response.json()
})
```

### 3. æ”¯æŒå¹¶å‘æ˜ å°„

```javascript
async function concurrentMyFrom(arrayLike, asyncMapFn, thisArg, concurrency = 3) {
  const items = myFrom(arrayLike)

  if (!asyncMapFn) {
    return items
  }

  const results = new Array(items.length)
  const promises = []

  for (let i = 0; i < items.length; i++) {
    const promise = asyncMapFn.call(thisArg, items[i], i).then((result) => {
      results[i] = result
    })

    promises.push(promise)

    // æ§åˆ¶å¹¶å‘æ•°
    if (promises.length >= concurrency) {
      await Promise.race(promises)
      // ç§»é™¤å·²å®Œæˆçš„ promise
      promises.splice(0, 1)
    }
  }

  await Promise.all(promises)
  return results
}
```

### 4. æ”¯æŒæµå¼å¤„ç†

```javascript
function* streamMyFrom(arrayLike, mapFn, thisArg) {
  const O = Object(arrayLike)
  const iteratorMethod = O[Symbol.iterator]

  if (iteratorMethod) {
    const iterator = iteratorMethod.call(O)
    let index = 0

    try {
      while (true) {
        const next = iterator.next()
        if (next.done) break

        let value = next.value
        if (mapFn) {
          value = mapFn.call(thisArg, value, index)
        }

        yield value
        index++
      }
    } finally {
      if (typeof iterator.return === 'function') {
        iterator.return()
      }
    }
  } else {
    const len = toLength(O.length)
    for (let i = 0; i < len; i++) {
      let value = O[i]
      if (mapFn) {
        value = mapFn.call(thisArg, value, i)
      }
      yield value
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šå¤„ç†å¤§æ•°æ®é›†æ—¶èŠ‚çœå†…å­˜
const hugeArrayLike = { length: 1000000 /* ... */ }
for (const item of streamMyFrom(hugeArrayLike, (x) => x * 2)) {
  console.log(item) // é€ä¸ªå¤„ç†ï¼Œä¸å ç”¨å¤§é‡å†…å­˜
}
```

### 5. å¸¦éªŒè¯çš„ç±»å‹å®‰å…¨ç‰ˆæœ¬

```javascript
function typedMyFrom(arrayLike, mapFn, thisArg, validator) {
  const result = myFrom(arrayLike, mapFn, thisArg)

  if (validator) {
    return result.map((item, index) => {
      if (!validator(item, index)) {
        throw new TypeError(`Invalid item at index ${index}: ${item}`)
      }
      return item
    })
  }

  return result
}

// ä½¿ç”¨ç¤ºä¾‹
const numberValidator = (item) => typeof item === 'number'
const numbers = typedMyFrom(['1', '2', '3'], (x) => Number(x), null, numberValidator)
console.log(numbers) // [1, 2, 3]

try {
  typedMyFrom(['1', 'invalid', '3'], (x) => Number(x), null, numberValidator)
} catch (e) {
  console.log(e.message) // "Invalid item at index 1: NaN"
}
```

## å¤ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£ Array.from çš„åŒè·¯å¾„å¤„ç†æœºåˆ¶
- [ ] æŒæ¡å¯è¿­ä»£å¯¹è±¡å’Œç±»æ•°ç»„å¯¹è±¡çš„åŒºåˆ«
- [ ] ç†Ÿç»ƒå®ç° ES è§„èŒƒä¸­çš„æŠ½è±¡æ“ä½œ
- [ ] ç†è§£è¿­ä»£å™¨åè®®å’Œèµ„æºç®¡ç†
- [ ] æŒæ¡ä¸¥æ ¼çš„ç±»å‹æ£€æµ‹å’Œé”™è¯¯å¤„ç†
- [ ] ç†Ÿæ‚‰ this ç»‘å®šåœ¨æ˜ å°„å‡½æ•°ä¸­çš„åº”ç”¨
- [ ] äº†è§£è¾¹ç•Œæƒ…å†µå’Œå¼‚å¸¸å¤„ç†çš„è¦ç‚¹
- [ ] èƒ½å¤Ÿå¤„ç†å¤æ‚çš„æ•°æ®ç±»å‹è½¬æ¢åœºæ™¯
- [ ] ç†è§£æ€§èƒ½ä¼˜åŒ–å’Œå†…å­˜ç®¡ç†ç­–ç•¥
- [ ] æŒæ¡å®é™…åº”ç”¨ä¸­çš„æœ€ä½³å®è·µ

  // ES è§„èŒƒï¼šToLength æ“ä½œ
  const maxSafeInteger = Number.MAX_SAFE_INTEGER
  const toLength = (v) => {
  const n = toInteger(v)
  if (n > maxSafeInteger) throw new RangeError('length exceeds MAX_SAFE_INTEGER')

      return Math.max(0, n) // ç¡®ä¿éè´Ÿæ•°

  }

  // å‚æ•°éªŒè¯ï¼šæ£€æŸ¥ arrayLike
  if (arrayLike == null)
  throw new TypeError(
  `provided arrayLike must be an array-like object - not null/undefined`,
  )

  // å¤„ç†ä¸åŒç±»å‹çš„è¾“å…¥
  const items =
  arrayLike instanceof Set || arrayLike instanceof Map
  ? [...arrayLike] // å¯è¿­ä»£å¯¹è±¡å…ˆè½¬æ¢
  : Object(arrayLike) // åŒ…è£…ä¸ºå¯¹è±¡

  // å‚æ•°éªŒè¯ï¼šæ£€æŸ¥ mapFn
  if (typeof mapFn !== 'undefined') {
  if (!isCallable(mapFn)) throw new TypeError(`provided mapFn must be a function`)
  }

  // è·å–é•¿åº¦å¹¶åˆ›å»ºæ•°ç»„
  const len = toLength(items.length)
  const arr = new Array(len)

  let i = 0,
  current

  // éå†å¹¶è½¬æ¢å…ƒç´ 
  while (i < len) {
  current = items[i]

      if (mapFn) {
        // ä½¿ç”¨æ˜ å°„å‡½æ•°ï¼Œæ”¯æŒ this ç»‘å®š
        arr[i] =
          typeof thisArg === 'undefined'
            ? mapFn(current, i)
            : mapFn.call(thisArg, current, i)
      } else {
        // ç›´æ¥å¤åˆ¶å…ƒç´ 
        arr[i] = current
      }
      i += 1

  }

  arr.length = len
  return arr
  }

````

## ğŸ§  ç®—æ³•åˆ†æ

### æ ¸å¿ƒæ€è·¯

1. **å‚æ•°éªŒè¯**ï¼šä¸¥æ ¼æŒ‰ç…§ ES è§„èŒƒæ£€æŸ¥è¾“å…¥
2. **ç±»å‹å¤„ç†**ï¼šåŒºåˆ†ç±»æ•°ç»„å’Œå¯è¿­ä»£å¯¹è±¡
3. **é•¿åº¦è§„èŒƒåŒ–**ï¼šä½¿ç”¨ toLength ç¡®ä¿å®‰å…¨èŒƒå›´
4. **å…ƒç´ è½¬æ¢**ï¼šæ”¯æŒæ˜ å°„å‡½æ•°å’Œ this ç»‘å®š

### æ—¶é—´å¤æ‚åº¦

- **O(n)**ï¼šå…¶ä¸­ n æ˜¯è¾“å…¥å¯¹è±¡çš„é•¿åº¦
- æ¯ä¸ªå…ƒç´ è®¿é—®å’Œå¤„ç†éƒ½æ˜¯å¸¸æ•°æ—¶é—´

### ç©ºé—´å¤æ‚åº¦

- **O(n)**ï¼šåˆ›å»ºæ–°æ•°ç»„å­˜å‚¨è½¬æ¢ç»“æœ
- ä¸åŒ…æ‹¬æ˜ å°„å‡½æ•°å¯èƒ½çš„é¢å¤–ç©ºé—´

## ğŸ” å…³é”®æŠ€æœ¯ç‚¹

### 1. ä¸¥æ ¼çš„ç±»å‹æ£€æµ‹

```javascript
const isCallable = (fn) =>
  typeof fn === 'function' || Object.prototype.toString.call(fn) === '[object Function]'
````

### 2. ES è§„èŒƒçš„æ•´æ•°è½¬æ¢

```javascript
const toInteger = (v) => {
  const _v = Number(v)
  if (isNaN(_v)) return 0
  if (v === 0 || !isFinite(_v)) return _v

  return (_v > 0 ? 1 : -1) * Math.floor(Math.abs(_v))
}
```

### 3. å®‰å…¨çš„é•¿åº¦å¤„ç†

```javascript
const toLength = (v) => {
  const n = toInteger(v)
  if (n > maxSafeInteger) throw new RangeError('length exceeds MAX_SAFE_INTEGER')
  return Math.max(0, n)
}
```

### 4. this ç»‘å®šçš„æ­£ç¡®å¤„ç†

```javascript
arr[i] =
  typeof thisArg === 'undefined' ? mapFn(current, i) : mapFn.call(thisArg, current, i)
```

## ğŸ§ª ä½¿ç”¨ç¤ºä¾‹

### åŸºç¡€è½¬æ¢

```javascript
// ç±»æ•°ç»„å¯¹è±¡
myFrom({ 0: 'a', 1: 'b', length: 2 }) // ['a', 'b']

// å­—ç¬¦ä¸²
myFrom('hello') // ['h', 'e', 'l', 'l', 'o']

// Set å¯¹è±¡
myFrom(new Set([1, 2, 3])) // [1, 2, 3]
```

### æ˜ å°„è½¬æ¢

```javascript
// å¸¦æ˜ å°„å‡½æ•°
function addIndex(el, i) {
  return el + i
}
myFrom({ 0: 'a', 1: 'b', length: 2 }, addIndex) // ['a0', 'b1']

// æ•°å€¼è½¬æ¢
myFrom('123', Number) // [1, 2, 3]
```

### this ç»‘å®š

```javascript
const context = { prefix: 'item_' }
function addPrefix(el, i) {
  return this.prefix + el
}
myFrom(['a', 'b'], addPrefix, context) // ['item_a', 'item_b']
```

### é”™è¯¯å¤„ç†

```javascript
// null/undefined æ£€æŸ¥
myFrom(null) // TypeError

// éå‡½æ•°æ˜ å°„æ£€æŸ¥
myFrom([1, 2], 'not a function') // TypeError
```

## ğŸ’¡ å…³é”®è®°å¿†ç‚¹

1. **å‚æ•°é¡ºåº**ï¼š`arrayLike, mapFn, thisArg`
2. **null æ£€æŸ¥**ï¼šä½¿ç”¨ `== null` åŒæ—¶æ£€æŸ¥ `null` å’Œ `undefined`
3. **å¯è¿­ä»£å¯¹è±¡**ï¼šSetã€Map éœ€è¦å…ˆå±•å¼€ä¸ºæ•°ç»„
4. **æ˜ å°„å‡½æ•°**ï¼šä¼ å…¥ `(element, index)` ä¸¤ä¸ªå‚æ•°
5. **this ç»‘å®š**ï¼šä½¿ç”¨ `call` æ–¹æ³•ç»‘å®šä¸Šä¸‹æ–‡
6. **é•¿åº¦å®‰å…¨**ï¼šç¡®ä¿åœ¨ `MAX_SAFE_INTEGER` èŒƒå›´å†…

## ğŸ¤” æ‰©å±•æ€è€ƒ

### ä¸åŸç”Ÿ Array.from çš„å·®å¼‚

- **Symbol.iterator æ”¯æŒ**ï¼šåŸç”Ÿç‰ˆæœ¬ä¼˜å…ˆä½¿ç”¨è¿­ä»£å™¨åè®®
- **æ›´å¤šè¾¹ç•Œæƒ…å†µ**ï¼šåŸç”Ÿç‰ˆæœ¬å¤„ç†æ›´å¤šç‰¹æ®Šæƒ…å†µ
- **æ€§èƒ½ä¼˜åŒ–**ï¼šåŸç”Ÿå®ç°åœ¨å¼•æ“å±‚é¢ä¼˜åŒ–

### åº”ç”¨åœºæ™¯

- **DOM æ“ä½œ**ï¼š`Array.from(document.querySelectorAll('.item'))`
- **å­—ç¬¦ä¸²å¤„ç†**ï¼š`Array.from('abc')` æ”¯æŒ Unicode
- **æ•°æ®è½¬æ¢**ï¼šæ‰¹é‡å¤„ç†ç±»æ•°ç»„æ•°æ®
- **å‡½æ•°å¼ç¼–ç¨‹**ï¼šç»“åˆæ˜ å°„å‡½æ•°è¿›è¡Œæ•°æ®å˜æ¢

### ä¼˜åŒ–æ–¹å‘

- **è¿­ä»£å™¨åè®®**ï¼šæ·»åŠ  `Symbol.iterator` æ”¯æŒ
- **ç¨€ç–æ•°ç»„**ï¼šå¤„ç†ç¨€ç–æ•°ç»„çš„ hole
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€

## ğŸ“ å¤ä¹ è¦ç‚¹

- [ ] ç†è§£ç±»æ•°ç»„å¯¹è±¡å’Œå¯è¿­ä»£å¯¹è±¡çš„åŒºåˆ«
- [ ] æŒæ¡ ES è§„èŒƒçš„ toInteger å’Œ toLength å®ç°
- [ ] ç†Ÿæ‚‰å‡½æ•°å¯è°ƒç”¨æ€§çš„æ£€æµ‹æ–¹æ³•
- [ ] ç†è§£æ˜ å°„å‡½æ•°å’Œ this ç»‘å®šçš„å¤„ç†
- [ ] æŒæ¡å„ç§è¾“å…¥ç±»å‹çš„å¤„ç†æ–¹å¼
- [ ] èƒ½å¤Ÿå®ç°å®Œæ•´çš„å‚æ•°éªŒè¯é€»è¾‘
