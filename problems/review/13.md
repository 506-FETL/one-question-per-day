# Day 13 复习文档

## 题目描述

实现一个特殊的 `add` 对象，要求支持属性访问链式调用和数值运算：

- `add[100] + 1` 输出 `101`
- `value[200][300] + 100` 输出 `701` (累加 100+200+300+100)
- `add[100][200][300] - 300` 输出 `300` (累加 100+200+300-300)

本题考查 **Proxy 代理对象** 和 **Symbol.toPrimitive** 的深度应用。

## 核心知识点

### 1. Proxy 代理对象

- **基本概念**: Proxy 可以拦截并自定义操作（如属性查找、赋值、枚举、函数调用等）
- **get 捕获器**: 拦截对象的读取属性操作
- **应用场景**: 动态属性生成、数据验证、操作记录等

### 2. Symbol.toPrimitive

- **作用**: 对象转换为原始值时调用的方法
- **优先级**: 最高，优先于 valueOf() 和 toString()
- **参数**: hint 可以是 'number'、'string' 或 'default'

### 3. 链式调用设计模式

- **核心思想**: 每次操作返回新的相同类型对象
- **累积状态**: 在对象内部维护累积值

## 代码实现

```javascript
function createProxy(value = 0) {
  return new Proxy(
    {},
    {
      get(target, property) {
        // 拦截 Symbol.toPrimitive，用于数值转换
        if (property === Symbol.toPrimitive) {
          return () => value
        }
        // 累加属性值，返回新的代理对象
        return createProxy(value + Number(property))
      },
    },
  )
}

let add = createProxy()
export default add
```

## 算法分析

- **时间复杂度**: O(n) - n 为链式调用的深度
- **空间复杂度**: O(n) - 每次调用创建新的 Proxy 对象
- **特点**: 惰性求值，只有在需要转换为原始值时才计算结果

## 关键技术点

### 1. Proxy get 捕获器的妙用

```javascript
// 捕获器参数详解
get(target, property, receiver) {
  // target: 被代理的原始对象
  // property: 被访问的属性名（可以是字符串或 Symbol）
  // receiver: 代理对象本身
}
```

### 2. 数值转换的关键点

```javascript
// Symbol.toPrimitive 的实现
if (property === Symbol.toPrimitive) {
  return () => value // 返回函数，而不是直接返回值
}
```

### 3. 类型转换注意事项

```javascript
Number('100') // 100 - 正常转换
Number('abc') // NaN - 非数字字符串
Number('') // 0   - 空字符串
Number(null) // 0   - null转换
```

### 4. 常见陷阱和坑点

- **忘记返回函数**: `Symbol.toPrimitive` 必须返回函数
- **属性名类型**: property 可能是字符串、数字或 Symbol
- **链式调用中断**: 每次必须返回新的 Proxy 对象
- **内存泄漏**: 深度链式调用可能产生大量对象

## 使用示例

```javascript
// 基础使用
const result1 = add[100] + 1
console.log(result1) // 101

// 链式调用
const chain = add[100][200][300]
console.log(chain + 0) // 600
console.log(chain - 100) // 500

// 复杂计算
const complex = add[10][20][30]
console.log(complex * 2) // 120
console.log(String(complex)) // "60"

// 验证原理
console.log(add[100][Symbol.toPrimitive]()) // 100
```

## 记忆要点

### 核心记忆点

1. **Proxy + Symbol.toPrimitive** 是解决动态属性累加的经典组合
2. **get 捕获器** 中必须区分 Symbol.toPrimitive 和普通属性
3. **链式调用** 的核心是每次返回新的相同类型对象
4. **数值转换** 时机：运算符操作、显式转换、模板字符串等

### 调试技巧

```javascript
// 添加调试信息
function createProxy(value = 0) {
  console.log(`Creating proxy with value: ${value}`)
  return new Proxy(
    {},
    {
      get(t, p) {
        console.log(`Accessing property: ${String(p)}`)
        if (p === Symbol.toPrimitive) {
          console.log(`Converting to primitive: ${value}`)
          return () => value
        }
        return createProxy(value + Number(p))
      },
    },
  )
}
```

## 扩展思考

### 1. 性能优化思路

```javascript
// 缓存优化版本
const proxyCache = new Map()
function createProxy(value = 0) {
  if (proxyCache.has(value)) {
    return proxyCache.get(value)
  }
  const proxy = new Proxy(
    {},
    {
      get(t, p) {
        if (p === Symbol.toPrimitive) {
          return () => value
        }
        return createProxy(value + Number(p))
      },
    },
  )
  proxyCache.set(value, proxy)
  return proxy
}
```

### 2. 支持更多操作符

```javascript
// 扩展版本支持减法
function createProxy(value = 0) {
  return new Proxy(
    {},
    {
      get(t, p) {
        if (p === Symbol.toPrimitive) {
          return () => value
        }
        // 支持负数语法 add.sub[100]
        if (typeof p === 'string' && p.startsWith('sub')) {
          return createProxy(value - Number(p.slice(3)))
        }
        return createProxy(value + Number(p))
      },
    },
  )
}
```

### 3. 类型安全版本

```javascript
function createProxy(value = 0) {
  return new Proxy(
    {},
    {
      get(t, p) {
        if (p === Symbol.toPrimitive) {
          return () => value
        }
        const numValue = Number(p)
        if (isNaN(numValue)) {
          throw new Error(`Invalid property: ${String(p)}`)
        }
        return createProxy(value + numValue)
      },
    },
  )
}
```

## 复习检查清单

- [ ] 理解 Proxy 对象的基本用法和 get 捕获器
- [ ] 掌握 Symbol.toPrimitive 的作用和使用时机
- [ ] 熟练实现链式调用的设计模式
- [ ] 理解 JavaScript 类型转换机制
- [ ] 能够识别和避免常见的实现陷阱
- [ ] 掌握调试技巧和性能优化方法
- [ ] 理解属性访问和数值转换的执行时机
- [ ] 能够扩展功能支持更多操作类型
