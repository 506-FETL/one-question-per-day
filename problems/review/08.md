# Day 08 复习文档

## 题目描述

手写实现一个完整的 **Promise 类**，要求：

- 完整的状态管理（pending、fulfilled、rejected）
- 支持链式调用（then、catch、finally）
- 异步执行机制（微任务）
- 静态方法（resolve、reject、all、race）
- 错误处理和状态透传

本题考查 **异步编程**、**状态机设计** 和 **微任务机制** 的深度理解。

## 核心知识点

### 1. Promise 状态机核心

```javascript
const PENDING = "pending"; // 等待中：初始状态
const FULFILLED = "fulfilled"; // 已成功：操作成功完成
const REJECTED = "rejected"; // 已拒绝：操作失败
```

**状态转换规则**：

- 只能从 PENDING 转换到 FULFILLED 或 REJECTED
- 状态一旦改变，不可再次改变（不可逆性）
- 状态改变时必须有一个不可变的值（result）

### 2. Promise 关键特性

- **状态不可逆**: 防止重复调用 resolve/reject
- **异步执行**: 所有回调必须在下一个事件循环执行
- **链式调用**: 每个 then/catch 返回新的 Promise 实例
- **值透传**: 非函数回调时的值传递机制
- **错误冒泡**: 未处理的错误会向上传播

### 3. 微任务实现优先级

```javascript
// 1. Node.js 环境：process.nextTick（最高优先级）
// 2. 浏览器环境：MutationObserver
// 3. 兜底方案：setTimeout（宏任务，不符合规范但可用）

function nextTick(fn) {
  if (typeof process !== "undefined" && process.nextTick) {
    process.nextTick(fn);
  } else if (typeof MutationObserver !== "undefined") {
    const observer = new MutationObserver(fn);
    const textNode = document.createTextNode("1");
    observer.observe(textNode, { characterData: true });
    textNode.data = "2";
  } else {
    setTimeout(fn, 0);
  }
}
```

### 4. then 方法的复杂处理逻辑

- **thenable 对象识别**: 有 then 方法的对象
- **循环引用检测**: 防止 Promise 解析自身
- **异常捕获**: try-catch 包裹所有用户代码
- **状态同步**: 处理已决议 Promise 的立即执行

## 代码实现

```javascript
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

export default class MyPromise {
  #state = PENDING; // 当前状态
  #result = undefined; // 结果值
  #handlers = []; // 处理函数队列

  constructor(executor) {
    // 定义 resolve 函数
    const resolve = (data) => {
      this.#changeState(FULFILLED, data);
    };

    // 定义 reject 函数
    const reject = (reason) => {
      this.#changeState(REJECTED, reason);
    };

    try {
      // 立即执行传入的执行器函数
      executor(resolve, reject);
    } catch (error) {
      // 执行器中的同步错误直接 reject
      reject(error);
    }
  }

  // 状态变更的核心方法
  #changeState(state, result) {
    // 状态只能改变一次
    if (this.#state !== PENDING) return;

    this.#state = state;
    this.#result = result;

    // 状态确定后，异步执行所有处理函数
    this.#runHandlers();
  }

  // 异步执行处理函数队列
  #runHandlers() {
    if (this.#state === PENDING) return;

    // 使用微任务异步执行
    nextTick(() => {
      while (this.#handlers.length > 0) {
        const handler = this.#handlers.shift();
        this.#runHandler(handler);
      }
    });
  }

  // 执行单个处理函数
  #runHandler(handler) {
    const { onFulfilled, onRejected, resolve, reject } = handler;

    try {
      if (this.#state === FULFILLED) {
        // 成功状态的处理
        if (typeof onFulfilled === "function") {
          const result = onFulfilled(this.#result);
          resolve(result);
        } else {
          // 值透传：如果不是函数，直接传递值
          resolve(this.#result);
        }
      } else if (this.#state === REJECTED) {
        // 失败状态的处理
        if (typeof onRejected === "function") {
          const result = onRejected(this.#result);
          resolve(result); // 注意：catch 处理后返回 fulfilled
        } else {
          // 错误透传：如果不是函数，继续传递错误
          reject(this.#result);
        }
      }
    } catch (error) {
      // 处理函数执行出错，reject 新 Promise
      reject(error);
    }
  }

  // then 方法实现
  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      const handler = {
        onFulfilled: this.#wrapWithThenableHandle(onFulfilled, resolve, reject),
        onRejected,
        resolve,
        reject,
      };

      if (this.#state === PENDING) {
        // 状态未确定，加入队列等待
        this.#handlers.push(handler);
      } else {
        // 状态已确定，异步执行处理函数
        nextTick(() => this.#runHandler(handler));
      }
    });
  }

  // 包装 onFulfilled，处理 thenable 对象
  #wrapWithThenableHandle(onFulfilled, resolve, reject) {
    return (value) => {
      if (typeof onFulfilled !== "function") {
        resolve(value);
        return;
      }

      try {
        const result = onFulfilled(value);

        // 处理返回值
        if (result === this) {
          // 循环引用检测
          throw new TypeError("Chaining cycle detected for promise");
        }

        if (this.#isThenable(result)) {
          // 如果返回 thenable 对象，等待其解析
          result.then(resolve, reject);
        } else {
          // 普通值直接 resolve
          resolve(result);
        }
      } catch (error) {
        reject(error);
      }
    };
  }

  // 判断是否为 thenable 对象
  #isThenable(obj) {
    return (
      obj !== null &&
      (typeof obj === "object" || typeof obj === "function") &&
      typeof obj.then === "function"
    );
  }

  // catch 方法实现
  catch(onRejected) {
    return this.then(null, onRejected);
  }

  // finally 方法实现
  finally(callback) {
    return this.then(
      (value) => MyPromise.resolve(callback()).then(() => value),
      (reason) =>
        MyPromise.resolve(callback()).then(() => {
          throw reason;
        }),
    );
  }

  // 静态方法：resolve
  static resolve(value) {
    if (value instanceof MyPromise) {
      return value;
    }

    return new MyPromise((resolve) => {
      if (value && typeof value.then === "function") {
        // thenable 对象
        value.then(resolve);
      } else {
        // 普通值
        resolve(value);
      }
    });
  }

  // 静态方法：reject
  static reject(reason) {
    return new MyPromise((_, reject) => reject(reason));
  }

  // 静态方法：all
  static all(promises) {
    return new MyPromise((resolve, reject) => {
      const promiseArray = Array.from(promises);

      if (promiseArray.length === 0) {
        resolve([]);
        return;
      }

      const results = Array.from({ length: promiseArray.length });
      let completedCount = 0;

      promiseArray.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          (value) => {
            results[index] = value;
            completedCount++;

            if (completedCount === promiseArray.length) {
              resolve(results);
            }
          },
          (reason) => {
            reject(reason); // 任意一个 reject，整体 reject
          },
        );
      });
    });
  }

  // 静态方法：race
  static race(promises) {
    return new MyPromise((resolve, reject) => {
      const promiseArray = Array.from(promises);

      if (promiseArray.length === 0) {
        return; // 永远不会 resolve
      }

      promiseArray.forEach((promise) => {
        MyPromise.resolve(promise).then(resolve, reject);
      });
    });
  }

  // 静态方法：allSettled
  static allSettled(promises) {
    return new MyPromise((resolve) => {
      const promiseArray = Array.from(promises);

      if (promiseArray.length === 0) {
        resolve([]);
        return;
      }

      const results = Array.from({ length: promiseArray.length });
      let completedCount = 0;

      promiseArray.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          (value) => {
            results[index] = { status: "fulfilled", value };
            completedCount++;

            if (completedCount === promiseArray.length) {
              resolve(results);
            }
          },
          (reason) => {
            results[index] = { status: "rejected", reason };
            completedCount++;

            if (completedCount === promiseArray.length) {
              resolve(results);
            }
          },
        );
      });
    });
  }

  // 静态方法：any（ES2021）
  static any(promises) {
    return new MyPromise((resolve, reject) => {
      const promiseArray = Array.from(promises);

      if (promiseArray.length === 0) {
        reject(new AggregateError([], "All promises were rejected"));
        return;
      }

      const errors = Array.from({ length: promiseArray.length });
      let rejectedCount = 0;

      promiseArray.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          (value) => {
            resolve(value); // 任意一个 resolve，整体 resolve
          },
          (reason) => {
            errors[index] = reason;
            rejectedCount++;

            if (rejectedCount === promiseArray.length) {
              reject(new AggregateError(errors, "All promises were rejected"));
            }
          },
        );
      });
    });
  }
}

// 微任务实现
function nextTick(fn) {
  if (typeof process !== "undefined" && process.nextTick) {
    // Node.js 环境
    process.nextTick(fn);
  } else if (typeof MutationObserver !== "undefined") {
    // 浏览器环境
    const observer = new MutationObserver(fn);
    const textNode = document.createTextNode("1");
    observer.observe(textNode, { characterData: true });
    textNode.data = "2";
  } else {
    // 兜底方案
    setTimeout(fn, 0);
  }
}
```

## 算法分析

- **时间复杂度**: O(1) - 单个 Promise 操作，O(n) - Promise.all 等批量操作
- **空间复杂度**: O(n) - n 为处理函数队列长度
- **特点**: 异步执行、状态不可逆、支持链式调用

## 关键技术点

### 1. 状态管理的关键要点

```javascript
// 状态检查：防止重复状态变更
if (this.#state !== PENDING) return;

// 状态同步：状态确定后立即处理队列
this.#state = state;
this.#result = result;
this.#runHandlers();
```

### 2. 微任务的正确实现

```javascript
// 确保异步执行，符合 Promise/A+ 规范
nextTick(() => {
  while (this.#handlers.length > 0) {
    const handler = this.#handlers.shift();
    this.#runHandler(handler);
  }
});
```

### 3. thenable 对象处理

```javascript
// 检测 thenable 对象
#isThenable(obj) {
  return obj !== null &&
         (typeof obj === 'object' || typeof obj === 'function') &&
         typeof obj.then === 'function'
}

// 处理 thenable 返回值
if (this.#isThenable(result)) {
  result.then(resolve, reject)
} else {
  resolve(result)
}
```

### 4. 循环引用检测

```javascript
// 防止 Promise 解析自身
if (result === this) {
  throw new TypeError("Chaining cycle detected for promise");
}
```

### 5. 常见陷阱和坑点

- **同步执行错误**: 忘记使用微任务异步执行回调
- **状态重复变更**: 没有检查当前状态就修改
- **值透传错误**: 非函数回调处理不当
- **内存泄漏**: 处理函数队列没有正确清理
- **thenable 处理**: 错误识别或处理 thenable 对象

## 使用示例

```javascript
// 基本使用
const promise1 = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve("Hello World");
  }, 1000);
});

promise1
  .then((value) => {
    console.log(value); // "Hello World"
    return `${value}!`;
  })
  .then((value) => {
    console.log(value); // "Hello World!"
  });

// 错误处理
const promise2 = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error("Something went wrong"));
  }, 500);
});

promise2
  .catch((error) => {
    console.error(error.message); // "Something went wrong"
    return "Recovered";
  })
  .then((value) => {
    console.log(value); // "Recovered"
  });

// 链式调用
MyPromise.resolve(10)
  .then((x) => x * 2)
  .then((x) => x + 5)
  .then((x) => {
    console.log(x); // 25
    return new MyPromise((resolve) => {
      setTimeout(() => resolve(x * 3), 100);
    });
  })
  .then((x) => {
    console.log(x); // 75
  });

// finally 使用
const promise3 = new MyPromise((resolve, reject) => {
  Math.random() > 0.5 ? resolve("success") : reject("failure");
});

promise3
  .then((value) => console.log("Resolved:", value))
  .catch((error) => console.log("Rejected:", error))
  .finally(() => console.log("Cleanup completed"));

// Promise.all 使用
const promises = [
  MyPromise.resolve(1),
  MyPromise.resolve(2),
  new MyPromise((resolve) => setTimeout(() => resolve(3), 100)),
];

MyPromise.all(promises).then((values) => {
  console.log(values); // [1, 2, 3]
});

// Promise.race 使用
const racePromises = [
  new MyPromise((resolve) => setTimeout(() => resolve("slow"), 1000)),
  new MyPromise((resolve) => setTimeout(() => resolve("fast"), 100)),
];

MyPromise.race(racePromises).then((value) => {
  console.log(value); // "fast"
});

// 错误示例：循环引用
const cyclicPromise = new MyPromise((resolve) => resolve());
const p2 = cyclicPromise.then(() => p2); // 将抛出 TypeError

// thenable 对象处理
const thenable = {
  then(resolve, reject) {
    setTimeout(() => resolve("thenable result"), 50);
  },
};

MyPromise.resolve(thenable).then((value) => {
  console.log(value); // "thenable result"
});

// 异步链式调用
async function example() {
  try {
    const result1 = await new MyPromise((resolve) => {
      setTimeout(() => resolve("step1"), 100);
    });
    console.log(result1);

    const result2 = await new MyPromise((resolve) => {
      setTimeout(() => resolve("step2"), 100);
    });
    console.log(result2);

    return "completed";
  } catch (error) {
    console.error("Error:", error);
  }
}

example().then((result) => console.log(result));

// Promise.allSettled 使用
const mixedPromises = [
  MyPromise.resolve("success"),
  MyPromise.reject("error"),
  new MyPromise((resolve) => setTimeout(() => resolve("delayed"), 200)),
];

MyPromise.allSettled(mixedPromises).then((results) => {
  console.log(results);
  // [
  //   { status: 'fulfilled', value: 'success' },
  //   { status: 'rejected', reason: 'error' },
  //   { status: 'fulfilled', value: 'delayed' }
  // ]
});

// Promise.any 使用（需要 AggregateError polyfill）
const anyPromises = [
  MyPromise.reject("error1"),
  new MyPromise((resolve) => setTimeout(() => resolve("success"), 100)),
  MyPromise.reject("error2"),
];

MyPromise.any(anyPromises)
  .then((value) => {
    console.log(value); // "success"
  })
  .catch((error) => {
    console.log(error.message); // 如果全部失败："All promises were rejected"
  });
```

## 记忆要点

### 核心记忆点

1. **状态机三态** - pending/fulfilled/rejected 及其转换规则
2. **微任务执行** - 所有回调必须异步执行
3. **值透传机制** - 非函数回调的处理方式
4. **thenable 处理** - 识别和处理具有 then 方法的对象
5. **链式调用** - 每个 then/catch 返回新 Promise

### 实现顺序记忆

```javascript
// 1. 构造函数（执行器立即执行）
// 2. 状态变更（changeState 方法）
// 3. 处理队列（runHandlers 异步执行）
// 4. 单个处理（runHandler 错误捕获）
// 5. then 方法（新 Promise 包装）
```

## 扩展思考

### 1. 支持取消的 Promise

```javascript
class CancellablePromise extends MyPromise {
  constructor(executor) {
    let isCancelled = false;
    let cancelCallback = null;

    super((resolve, reject) => {
      const wrappedResolve = (value) => {
        if (!isCancelled) resolve(value);
      };

      const wrappedReject = (reason) => {
        if (!isCancelled) reject(reason);
      };

      cancelCallback = executor(wrappedResolve, wrappedReject);
    });

    this.cancel = () => {
      isCancelled = true;
      if (typeof cancelCallback === "function") {
        cancelCallback();
      }
    };
  }
}

// 使用示例
const cancellable = new CancellablePromise((resolve, reject) => {
  const timer = setTimeout(() => resolve("completed"), 1000);

  // 返回取消函数
  return () => clearTimeout(timer);
});

setTimeout(() => cancellable.cancel(), 500); // 取消执行
```

### 2. 支持重试的 Promise

```javascript
class RetryablePromise extends MyPromise {
  static withRetry(promiseFactory, maxRetries = 3, delay = 1000) {
    return new MyPromise(async (resolve, reject) => {
      let lastError;

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          const result = await promiseFactory();
          resolve(result);
          return;
        } catch (error) {
          lastError = error;

          if (attempt < maxRetries) {
            await new MyPromise((r) => setTimeout(r, delay * 2 ** attempt));
          }
        }
      }

      reject(lastError);
    });
  }
}

// 使用示例
const fetchWithRetry = RetryablePromise.withRetry(
  () => fetch("/api/data"),
  3,
  1000,
);
```

### 3. 支持超时的 Promise

```javascript
class TimeoutPromise extends MyPromise {
  static withTimeout(promise, timeout, timeoutMessage = "Operation timeout") {
    return MyPromise.race([
      promise,
      new MyPromise((_, reject) => {
        setTimeout(() => reject(new Error(timeoutMessage)), timeout);
      }),
    ]);
  }
}

// 使用示例
const promiseWithTimeout = TimeoutPromise.withTimeout(
  fetch("/api/slow-endpoint"),
  5000,
  "Request timeout after 5 seconds",
);
```

### 4. 支持进度的 Promise

```javascript
class ProgressPromise extends MyPromise {
  constructor(executor) {
    const progressCallbacks = [];

    super((resolve, reject) => {
      const progress = (value) => {
        progressCallbacks.forEach((callback) => callback(value));
      };

      executor(resolve, reject, progress);
    });

    this.onProgress = (callback) => {
      progressCallbacks.push(callback);
      return this;
    };
  }
}

// 使用示例
const uploadFile = new ProgressPromise((resolve, reject, progress) => {
  // 模拟文件上传
  let uploaded = 0;
  const total = 100;

  const interval = setInterval(() => {
    uploaded += 10;
    progress((uploaded / total) * 100);

    if (uploaded >= total) {
      clearInterval(interval);
      resolve("Upload completed");
    }
  }, 100);
});

uploadFile
  .onProgress((percent) => console.log(`Upload progress: ${percent}%`))
  .then((result) => console.log(result));
```

### 5. 支持管道的 Promise

```javascript
class PipelinePromise extends MyPromise {
  static pipeline(...functions) {
    return (initialValue) => {
      return functions.reduce(
        (promise, fn) => promise.then(fn),
        MyPromise.resolve(initialValue),
      );
    };
  }

  pipe(fn) {
    return this.then(fn);
  }
}

// 使用示例
const processData = PipelinePromise.pipeline(
  (data) => data.trim(),
  (data) => data.toUpperCase(),
  (data) => data.split(" "),
  (data) => data.filter((word) => word.length > 3),
);

processData("  hello world programming  ").then((result) =>
  console.log(result),
); // ['HELLO', 'WORLD', 'PROGRAMMING']

// 链式管道
MyPromise.resolve("initial data")
  .pipe((data) => data.toUpperCase())
  .pipe((data) => data.split(" "))
  .pipe((data) => data.join("-"))
  .then((result) => console.log(result)); // 'INITIAL-DATA'
```

## 复习检查清单

- [ ] 理解 Promise 状态机的核心原理
- [ ] 掌握微任务的正确实现方法
- [ ] 熟练处理 thenable 对象和循环引用
- [ ] 理解 then 方法的复杂处理逻辑
- [ ] 掌握值透传和错误冒泡机制
- [ ] 熟悉所有静态方法的实现细节
- [ ] 能够处理异步执行的各种边界情况
- [ ] 理解 Promise/A+ 规范的关键要求
- [ ] 掌握 Promise 在实际项目中的应用
- [ ] 了解 Promise 的性能优化和扩展方法
