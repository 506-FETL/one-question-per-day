# Day 10 复习文档

## 题目描述

手写实现 JavaScript 的**核心方法**，包括：

- Function.prototype.call - 改变函数执行上下文
- Function.prototype.apply - 类似 call，但参数为数组
- Function.prototype.bind - 返回绑定上下文的新函数
- instanceof 操作符 - 检查原型链关系
- new 操作符 - 创建实例对象

本题考查 **this 绑定机制**、**原型链原理** 和 **JavaScript 底层实现** 的深度理解。

## 核心知识点

### 1. this 绑定机制的四种规则

```javascript
// 1. 默认绑定 - 独立函数调用
function foo() {
  console.log(this);
}
foo(); // 严格模式: undefined, 非严格模式: window

// 2. 隐式绑定 - 对象方法调用
const obj = {
  foo() {
    console.log(this);
  },
};
obj.foo(); // this 指向 obj

// 3. 显式绑定 - call/apply/bind
foo.call(obj); // 强制 this 指向 obj

// 4. new 绑定 - 构造函数调用
function Constructor() {
  this.name = "test";
}
new Constructor(); // this 指向新创建的实例
```

### 2. 原型链关系图

```javascript
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function () {
  return `Hello, ${this.name}`;
};

const alice = new Person("Alice");

// 原型链关系：
// alice.__proto__ === Person.prototype
// Person.prototype.__proto__ === Object.prototype
// Object.prototype.__proto__ === null
```

### 3. 构造函数调用的四个步骤

1. 创建一个新的空对象
2. 将空对象的 **proto** 指向构造函数的 prototype
3. 将构造函数的 this 绑定到新对象
4. 如果构造函数返回对象，则返回该对象；否则返回新对象

### 4. Symbol 的妙用

```javascript
// 使用 Symbol 避免属性名冲突
const uniqueKey = Symbol("temp");
obj[uniqueKey] = func;
// 执行后删除，不会污染原对象
delete obj[uniqueKey];
```

## 代码实现

```javascript
/**
 * 1. 手写 Function.prototype.call
 * 改变函数的 this 指向，并立即执行函数
 */
Function.prototype.myCall = function (context, ...args) {
  // 处理边界情况：context 为 null 或 undefined
  if (context === null || context === undefined) {
    context = globalThis; // 兼容 Node.js 和浏览器
  }

  // 确保 context 是对象类型
  context = new Object(context);

  // 使用 Symbol 创建唯一属性名，避免冲突
  const fnSymbol = Symbol("fn");

  // 将当前函数赋值给 context 的属性
  context[fnSymbol] = this;

  try {
    // 通过对象方法调用的方式执行函数（隐式绑定）
    const result = context[fnSymbol](...args);
    return result;
  } finally {
    // 清理临时属性，避免污染原对象
    delete context[fnSymbol];
  }
};

/**
 * 2. 手写 Function.prototype.apply
 * 与 call 类似，但参数以数组形式传递
 */
Function.prototype.myApply = function (context, argsArray) {
  // 处理边界情况
  if (context === null || context === undefined) {
    context = globalThis;
  }

  context = new Object(context);

  // 参数数组默认为空数组
  const args = Array.isArray(argsArray) ? argsArray : [];

  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;

  try {
    const result = context[fnSymbol](...args);
    return result;
  } finally {
    delete context[fnSymbol];
  }
};

/**
 * 3. 手写 Function.prototype.bind
 * 返回一个新函数，预设 this 和部分参数（柯里化）
 */
Function.prototype.myBind = function (context, ...outerArgs) {
  // 保存原函数
  const originalFunc = this;

  // 检查调用者是否为函数
  if (typeof originalFunc !== "function") {
    throw new TypeError("Function.prototype.bind called on non-function");
  }

  // 返回绑定后的新函数
  const boundFunction = function (...innerArgs) {
    // 判断是否通过 new 调用
    if (new.target) {
      // new 调用：忽略绑定的 this，使用新创建的对象
      return new originalFunc(...outerArgs, ...innerArgs);
    } else {
      // 普通调用：使用绑定的 this
      return originalFunc.myCall(context, ...outerArgs, ...innerArgs);
    }
  };

  // 处理原型链继承
  if (originalFunc.prototype) {
    // 创建一个空函数作为中介，避免直接引用
    function Empty() {}
    Empty.prototype = originalFunc.prototype;
    boundFunction.prototype = new Empty();
  }

  return boundFunction;
};

/**
 * 4. 手写 instanceof 操作符
 * 检查对象的原型链中是否存在构造函数的 prototype
 */
function myInstanceof(left, right) {
  // 处理基本类型
  if (typeof left !== "object" || left === null) {
    return false;
  }

  // 检查右侧是否为函数
  if (typeof right !== "function") {
    throw new TypeError("Right-hand side of instanceof is not a function");
  }

  // 获取构造函数的 prototype
  const prototype = right.prototype;

  // 从对象的原型链开始查找
  let current = Object.getPrototypeOf(left);

  while (current !== null) {
    if (current === prototype) {
      return true;
    }
    current = Object.getPrototypeOf(current);
  }

  return false;
}

/**
 * 5. 手写 new 操作符
 * 模拟 new 的完整过程
 */
function myNew(constructor, ...args) {
  // 检查构造函数
  if (typeof constructor !== "function") {
    throw new TypeError("Constructor must be a function");
  }

  // 1. 创建新对象，并设置原型链
  const newObj = Object.create(constructor.prototype);

  // 2. 执行构造函数，绑定 this 到新对象
  const result = constructor.apply(newObj, args);

  // 3. 判断构造函数的返回值
  // 如果返回对象类型，则返回该对象；否则返回新创建的对象
  if (
    result !== null &&
    (typeof result === "object" || typeof result === "function")
  ) {
    return result;
  }

  return newObj;
}

/**
 * 增强版 bind：支持更多特性
 */
Function.prototype.myBindAdvanced = function (context, ...outerArgs) {
  const originalFunc = this;

  if (typeof originalFunc !== "function") {
    throw new TypeError("Function.prototype.bind called on non-function");
  }

  const boundFunction = function (...innerArgs) {
    const isNewCall = new.target === boundFunction;

    if (isNewCall) {
      // new 调用时的特殊处理
      const instance = Object.create(originalFunc.prototype);
      const result = originalFunc.apply(instance, [...outerArgs, ...innerArgs]);

      // 如果构造函数返回对象，使用该对象；否则使用创建的实例
      return result && typeof result === "object" ? result : instance;
    } else {
      // 普通调用
      return originalFunc.apply(context, [...outerArgs, ...innerArgs]);
    }
  };

  // 维护原型链
  if (originalFunc.prototype) {
    boundFunction.prototype = Object.create(originalFunc.prototype);
  }

  // 复制函数属性
  Object.defineProperty(boundFunction, "length", {
    value: Math.max(0, originalFunc.length - outerArgs.length),
    configurable: true,
  });

  Object.defineProperty(boundFunction, "name", {
    value: `bound ${originalFunc.name}`,
    configurable: true,
  });

  return boundFunction;
};

/**
 * 更精确的 instanceof 实现
 */
function myInstanceofAdvanced(left, right) {
  // 处理 null 和 undefined
  if (left == null) return false;

  // 处理基本类型的包装
  if (typeof left !== "object" && typeof left !== "function") {
    // 检查基本类型的包装对象
    if (right === String && typeof left === "string") return false;
    if (right === Number && typeof left === "number") return false;
    if (right === Boolean && typeof left === "boolean") return false;
    return false;
  }

  // 检查右侧
  if (typeof right !== "function") {
    throw new TypeError("Right-hand side of instanceof is not callable");
  }

  // 特殊处理：Function 的 instanceof
  if (right === Function) {
    return typeof left === "function";
  }

  // 特殊处理：Object 的 instanceof
  if (right === Object) {
    return typeof left === "object" || typeof left === "function";
  }

  const prototype = right.prototype;
  if (prototype == null) {
    throw new TypeError(
      "Function has non-object prototype in instanceof check",
    );
  }

  let current = Object.getPrototypeOf(left);

  while (current != null) {
    if (current === prototype) {
      return true;
    }
    current = Object.getPrototypeOf(current);
  }

  return false;
}

/**
 * 支持类语法的 new 实现
 */
function myNewAdvanced(constructor, ...args) {
  if (typeof constructor !== "function") {
    throw new TypeError("Constructor must be a function");
  }

  // 检查是否为箭头函数（不能作为构造函数）
  if (!constructor.prototype) {
    throw new TypeError("Constructor is not constructable");
  }

  // 创建新对象
  const newObj = Object.create(constructor.prototype);

  // 设置正确的 new.target
  const boundConstructor = constructor.bind(newObj);
  Object.defineProperty(boundConstructor, "prototype", {
    value: constructor.prototype,
  });

  try {
    const result = Reflect.construct(constructor, args, constructor);

    // 检查返回值
    if (
      result != null &&
      (typeof result === "object" || typeof result === "function")
    ) {
      return result;
    }
  } catch (error) {
    // 如果构造函数执行出错，确保清理工作
    throw error;
  }

  return newObj;
}
```

## 算法分析

- **时间复杂度**: O(1) - call/apply/bind, O(n) - instanceof(n为原型链长度)
- **空间复杂度**: O(1) - 基本实现，O(1) - 临时Symbol属性
- **特点**: 原生JS行为模拟、原型链操作、this绑定

## 关键技术点

### 1. Symbol 避免属性冲突

```javascript
// 错误方式：可能覆盖已有属性
context.fn = this;

// 正确方式：使用 Symbol 确保唯一性
const fnSymbol = Symbol("temp");
context[fnSymbol] = this;
```

### 2. call/apply 的核心原理

```javascript
// 核心思想：利用隐式绑定改变 this
// obj.method() -> method 内的 this 指向 obj

function myCall(context, ...args) {
  context[fn] = this; // 将函数作为 context 的方法
  context[fn](...args); // 调用方法，this 自动绑定到 context
  delete context[fn]; // 清理临时属性
}
```

### 3. bind 的 new 调用检测

```javascript
function boundFunction(...args) {
  // 检测是否通过 new 调用
  if (new.target) {
    // new 调用：忽略绑定的 this
    return new originalFunc(...outerArgs, ...args);
  } else {
    // 普通调用：使用绑定的 this
    return originalFunc.call(context, ...outerArgs, ...args);
  }
}
```

### 4. instanceof 的原型链遍历

```javascript
function myInstanceof(obj, constructor) {
  let current = Object.getPrototypeOf(obj);
  const target = constructor.prototype;

  // 沿着原型链向上查找
  while (current !== null) {
    if (current === target) return true;
    current = Object.getPrototypeOf(current);
  }

  return false;
}
```

### 5. 常见陷阱和坑点

- **this丢失**: 不使用隐式绑定改变this指向
- **属性污染**: 直接在对象上添加属性而不清理
- **参数处理**: apply的参数不是数组时的处理
- **new检测**: bind函数被new调用时的特殊处理
- **原型链**: instanceof的原型链遍历终止条件

## 使用示例

```javascript
// call 使用示例
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: "Alice" };
console.log(greet.myCall(person, "Hello", "!")); // "Hello, Alice!"

// apply 使用示例
const numbers = [1, 5, 3, 9, 2];
console.log(Math.max.myApply(null, numbers)); // 9

// bind 使用示例
const boundGreet = greet.myBind(person, "Hi");
console.log(boundGreet("?")); // "Hi, Alice?"

// bind 的 new 调用
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const BoundPerson = Person.myBind(null, "John");
const john = new BoundPerson(25);
console.log(john.name); // "John"
console.log(john.age); // 25

// instanceof 使用示例
console.log(myInstanceof(john, Person)); // true
console.log(myInstanceof(john, Object)); // true
console.log(myInstanceof(john, Array)); // false

// new 使用示例
function Car(brand, model) {
  this.brand = brand;
  this.model = model;
  this.start = function () {
    return `${this.brand} ${this.model} is starting`;
  };
}

const myCar = myNew(Car, "Toyota", "Camry");
console.log(myCar.brand); // "Toyota"
console.log(myCar.start()); // "Toyota Camry is starting"

// 构造函数返回对象的情况
function SpecialConstructor() {
  this.name = "instance";
  return { custom: "object" }; // 返回自定义对象
}

const special = myNew(SpecialConstructor);
console.log(special.custom); // "object"
console.log(special.name); // undefined

// 复杂继承示例
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function () {
  return `${this.name} makes a sound`;
};

function Dog(name, breed) {
  Animal.myCall(this, name);
  this.breed = breed;
}

// 设置原型链
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function () {
  return `${this.name} barks!`;
};

const dog = myNew(Dog, "Buddy", "Golden Retriever");
console.log(dog.speak()); // "Buddy makes a sound"
console.log(dog.bark()); // "Buddy barks!"
console.log(myInstanceof(dog, Dog)); // true
console.log(myInstanceof(dog, Animal)); // true

// 边界情况测试
console.log(greet.myCall(null, "Hello", "!")); // this指向global
console.log(greet.myCall(undefined, "Hi", "?")); // this指向global
console.log(greet.myCall(42, "Hey", ".")); // this指向Number包装对象

// 箭头函数与 bind（箭头函数无法绑定 this）
const arrowFunc = (x) => x * 2;
const boundArrow = arrowFunc.myBind({ value: 10 });
console.log(boundArrow(5)); // 10（this绑定无效）

// 异常处理测试
try {
  myInstanceof(123, "not a function");
} catch (e) {
  console.log(e.message); // "Right-hand side of instanceof is not a function"
}

try {
  myNew("not a function");
} catch (e) {
  console.log(e.message); // "Constructor must be a function"
}

// 性能对比测试
function performanceTest() {
  const iterations = 1000000;
  const obj = { name: "Test" };

  function testFunc() {
    return this.name;
  }

  // 原生 call
  console.time("Native call");
  for (let i = 0; i < iterations; i++) {
    testFunc.call(obj);
  }
  console.timeEnd("Native call");

  // 自实现 call
  console.time("Custom call");
  for (let i = 0; i < iterations; i++) {
    testFunc.myCall(obj);
  }
  console.timeEnd("Custom call");
}

// performanceTest()
```

## 记忆要点

### 核心记忆点

1. **Symbol技巧** - 使用Symbol避免属性名冲突
2. **隐式绑定** - 通过对象方法调用改变this指向
3. **new检测** - bind函数中判断是否通过new调用
4. **原型链遍历** - instanceof的查找过程
5. **返回值处理** - 构造函数返回对象时的特殊情况

### 实现模式记忆

```javascript
// call/apply 模式
// 1. 处理context（null/undefined）
// 2. 创建Symbol属性
// 3. 赋值函数并调用
// 4. 清理临时属性

// bind 模式
// 1. 保存原函数
// 2. 返回新函数
// 3. 检测new调用
// 4. 选择合适的this
```

## 扩展思考

### 1. 支持异步函数的bind

```javascript
Function.prototype.asyncBind = function (context, ...outerArgs) {
  const originalFunc = this;

  return async function (...innerArgs) {
    if (new.target) {
      throw new TypeError("Async function cannot be called with new");
    }

    try {
      const result = await originalFunc.myCall(
        context,
        ...outerArgs,
        ...innerArgs,
      );
      return result;
    } catch (error) {
      throw error;
    }
  };
};

// 使用示例
async function fetchData(url) {
  const response = await fetch(url);
  return `Data from ${this.name}: ${response.status}`;
}

const api = { name: "UserAPI" };
const boundFetch = fetchData.asyncBind(api);
boundFetch("/users").then(console.log);
```

### 2. 支持装饰器的call

```javascript
Function.prototype.decoratedCall = function (
  context,
  decorators = [],
  ...args
) {
  let func = this;

  // 应用装饰器
  for (const decorator of decorators.reverse()) {
    func = decorator(func);
  }

  return func.myCall(context, ...args);
};

// 装饰器示例
function logDecorator(func) {
  return function (...args) {
    console.log(`Calling ${func.name} with args:`, args);
    const result = func.apply(this, args);
    console.log(`Result:`, result);
    return result;
  };
}

function timingDecorator(func) {
  return function (...args) {
    const start = performance.now();
    const result = func.apply(this, args);
    const end = performance.now();
    console.log(`Execution time: ${end - start}ms`);
    return result;
  };
}

// 使用示例
function calculate(a, b) {
  return a + b;
}

calculate.decoratedCall({}, [logDecorator, timingDecorator], 5, 3);
```

### 3. 支持柯里化的bind

```javascript
Function.prototype.curry = function (...outerArgs) {
  const originalFunc = this;
  const totalArgs = originalFunc.length;

  function curried(...currentArgs) {
    const allArgs = [...outerArgs, ...currentArgs];

    if (allArgs.length >= totalArgs) {
      return originalFunc.apply(this, allArgs);
    } else {
      return curried.bind(this, ...currentArgs);
    }
  }

  return curried;
};

// 使用示例
function multiply(a, b, c) {
  return a * b * c;
}

const curriedMultiply = multiply.curry();
const step1 = curriedMultiply(2);
const step2 = step1(3);
const result = step2(4); // 24
```

### 4. 支持管道的apply

```javascript
Function.prototype.pipeline = function (context, ...funcs) {
  return (...args) => {
    let result = this.myApply(context, args);

    for (const func of funcs) {
      result = func.call(context, result);
    }

    return result;
  };
};

// 使用示例
function add(a, b) {
  return a + b;
}

function double(x) {
  return x * 2;
}

function square(x) {
  return x * x;
}

const pipeline = add.pipeline(null, double, square);
console.log(pipeline(3, 4)); // ((3+4)*2)^2 = 196
```

### 5. 支持缓存的new

```javascript
function memoizedNew(constructor, cacheKey) {
  const cache = new Map();

  return function (...args) {
    const key = cacheKey ? cacheKey(...args) : JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key);
    }

    const instance = myNew(constructor, ...args);
    cache.set(key, instance);

    return instance;
  };
}

// 使用示例
function ExpensiveObject(id, data) {
  this.id = id;
  this.data = data;
  this.processed = this.heavyProcessing(data);
}

ExpensiveObject.prototype.heavyProcessing = function (data) {
  // 模拟昂贵操作
  return data.toUpperCase();
};

const createCachedObject = memoizedNew(
  ExpensiveObject,
  (id) => id, // 缓存键为 id
);

const obj1 = createCachedObject(1, "test");
const obj2 = createCachedObject(1, "different"); // 返回缓存的 obj1
console.log(obj1 === obj2); // true
```

## 复习检查清单

- [ ] 理解this绑定的四种规则和优先级
- [ ] 掌握call/apply/bind的实现原理
- [ ] 熟练使用Symbol避免属性名冲突
- [ ] 理解new操作符的完整执行过程
- [ ] 掌握instanceof的原型链查找机制
- [ ] 能够处理各种边界情况和异常
- [ ] 了解原生实现与自定义实现的性能差异
- [ ] 熟悉原型链和构造函数的关系
- [ ] 能够扩展和优化基础实现
- [ ] 理解在实际项目中的应用场景
      delete context[fn]
      return res
      }

// 2. 手写 apply
Function.prototype.Apply = function (context, args = []) {
if (context === undefined || context === null) {
context = window
}
let fn = Symbol()
context[fn] = this
let res = context[fn](...args)
delete context[fn]
return res
}

// 3. 手写 bind
Function.prototype.Bind = function (context, ...args) {
if (context === undefined || context === null) {
context = window
}
let fn = this
let f = Symbol()
const result = function (...args1) {
if (this instanceof fn) {
// result如果作为构造函数被调用，this指向的是new出来的对象
// this instanceof fn，判断new出来的对象是否为fn的实例
this[f] = fn
let res = this[f](...args, ...args1)
delete this[f]
return res
} else {
// bind返回的函数作为普通函数被调用时
context[f] = fn
let res = context[f](...args, ...args1)
delete context[f]
return res
}
}
// 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法
result.prototype = Object.create(fn.prototype)
result.prototype.constructor = result
return result
}

// 4. 手写 instanceof
export function instanceOf(obj, fn) {
let proto = obj.**proto**
if (proto) {
if (proto === fn.prototype) {
return true
} else {
return instanceOf(proto, fn)
}
} else {
return false
}
}

// 5. 手写 new
export function selfNew(fn, ...args) {
// 创建一个instance对象，该对象的原型是fn.prototype
let instance = Object.create(fn.prototype)
// 调用构造函数，使用apply，将this指向新生成的对象
let res = fn.apply(instance, args)
// 如果fn函数有返回值，并且返回值是一个对象或方法，则返回该对象，否则返回新生成的instance对象
return typeof res === 'object' || typeof res === 'function' ? res : instance
}

````

## 🧠 算法分析

### 核心思路

1. **call/apply**：通过对象属性调用实现 this 绑定
2. **bind**：返回新函数，支持预设参数和构造函数调用
3. **instanceof**：递归查找原型链，比较 prototype
4. **new**：创建对象、绑定原型、执行构造函数、处理返回值

### 时间复杂度

- **call/apply**：O(1) - 直接属性访问和调用
- **bind**：O(1) - 返回函数创建
- **instanceof**：O(n) - n 为原型链深度
- **new**：O(1) - 对象创建和函数调用

### 空间复杂度

- **call/apply**：O(1) - 临时属性存储
- **bind**：O(1) - 闭包变量存储
- **instanceof**：O(n) - 递归调用栈
- **new**：O(1) - 新对象创建

## 🔍 关键技术点

### 1. Symbol 避免属性冲突

```javascript
let fn = Symbol() // 创建唯一标识符
context[fn] = this // 避免覆盖原有属性
````

### 2. 原型链递归查找

```javascript
function instanceOf(obj, fn) {
  const proto = obj.__proto__;
  if (proto === fn.prototype) return true;
  return proto ? instanceOf(proto, fn) : false;
}
```

### 3. 构造函数返回值处理

```javascript
// new 操作需要判断构造函数的返回值类型
return typeof res === "object" || typeof res === "function" ? res : instance;
```

### 4. bind 的构造函数检测

```javascript
if (this instanceof fn) {
  // 作为构造函数调用时的特殊处理
} else {
  // 普通函数调用
}
```

### 5. 原型继承的正确建立

```javascript
result.prototype = Object.create(fn.prototype);
result.prototype.constructor = result;
```

## 🧪 使用示例

### call 和 apply 示例

```javascript
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: "Alice" };

// call 用法
greet.Call(person, "Hello", "!"); // "Hello, Alice!"

// apply 用法
greet.Apply(person, ["Hi", "?"]); // "Hi, Alice?"
```

### bind 示例

```javascript
function multiply(a, b) {
  return a * b;
}

// 普通绑定
const double = multiply.Bind(null, 2);
double(5); // 10

// 构造函数绑定
function Person(name) {
  this.name = name;
}

const BoundPerson = Person.Bind(null, "John");
const john = new BoundPerson(); // {name: 'John'}
```

### instanceof 示例

```javascript
function Animal() {}
function Dog() {}
Dog.prototype = Object.create(Animal.prototype);

const dog = new Dog();
instanceOf(dog, Dog); // true
instanceOf(dog, Animal); // true
instanceOf(dog, Object); // true
```

### new 示例

```javascript
function Car(brand) {
  this.brand = brand;
  this.wheels = 4;
}

const car = selfNew(Car, "Toyota");
// car: {brand: 'Toyota', wheels: 4, __proto__: Car.prototype}

// 构造函数返回对象的情况
function Factory() {
  return { type: "custom" };
}

const obj = selfNew(Factory); // {type: 'custom'}
```

## 💡 关键记忆点

1. **call/apply 原理**：通过对象属性调用实现 this 绑定
2. **bind 双重功能**：普通调用 + 构造函数调用的不同处理
3. **instanceof 本质**：递归查找原型链上的 prototype
4. **new 四步骤**：创建对象 → 绑定原型 → 执行函数 → 返回结果
5. **Symbol 的作用**：避免临时属性与原有属性冲突
6. **原型继承**：bind 返回的函数需要正确继承原型

## 🤔 扩展思考

### this 绑定优先级

1. **new 绑定** > **显式绑定** > **隐式绑定** > **默认绑定**
2. bind 在 new 调用时会被忽略

### 边界情况处理

- **null/undefined context**：默认绑定到全局对象
- **构造函数返回对象**：返回该对象而非实例
- **原型链断裂**：instanceof 需要处理 null 原型

### 性能考虑

- **Symbol 创建成本**：每次调用都创建新的 Symbol
- **递归深度限制**：原型链过长可能导致栈溢出
- **内存泄漏风险**：临时属性需要及时清理

## 📝 复习要点

- [ ] 理解 this 绑定的四种方式和优先级
- [ ] 掌握原型链的查找机制和断点处理
- [ ] 熟悉构造函数的执行过程和返回值规则
- [ ] 能够实现 call、apply、bind 的核心逻辑
- [ ] 理解 instanceof 和 new 的底层原理
- [ ] 掌握 Symbol 在避免属性冲突中的应用
