# Day 09 å¤ä¹ æ–‡æ¡£

## é¢˜ç›®æè¿°

å®ç°äºŒå‰æ ‘çš„**å‚ç›´éå†**ï¼Œè¦æ±‚ä»å·¦åˆ°å³ã€ä»ä¸Šåˆ°ä¸‹éå†äºŒå‰æ ‘ã€‚æ ¸å¿ƒæŒ‘æˆ˜æ˜¯ï¼š

- å»ºç«‹æ­£ç¡®çš„åæ ‡ç³»ç»Ÿï¼ˆå‚ç›´çº¿å’Œæ·±åº¦ï¼‰
- å¤„ç†åŒä¸€ä½ç½®å¤šä¸ªèŠ‚ç‚¹çš„æ’åºè§„åˆ™
- ä¿æŒçˆ¶èŠ‚ç‚¹å…³ç³»çš„é¡ºåºç»§æ‰¿

æœ¬é¢˜è€ƒæŸ¥ **æ ‘éå†ç®—æ³•**ã€**åæ ‡è®¡ç®—** å’Œ **å¤šç»´æ’åº** çš„ç»¼åˆåº”ç”¨ã€‚

![äºŒå‰æ ‘å‚ç›´éå†ç¤ºæ„å›¾](image.png)

ä¸Šè¿°äºŒå‰æ ‘çš„å‚ç›´éå†ç»“æœä¸ºï¼š[6,4,2,7,1,9,10,3,8,5]

## æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. å‚ç›´éå†çš„åæ ‡ç³»ç»Ÿ

```javascript
// åæ ‡å®šä¹‰ï¼š(å‚ç›´çº¿, æ·±åº¦)
//         (0, 0) æ ¹èŠ‚ç‚¹
//       /           \
//   (-1, 1)       (1, 1)
//    /    \       /    \
// (-2, 2) (0, 2) (0, 2) (2, 2)
```

**å‚ç›´çº¿è®¡ç®—è§„åˆ™**ï¼š

- æ ¹èŠ‚ç‚¹å‚ç›´çº¿ä¸º 0
- å·¦å­èŠ‚ç‚¹å‚ç›´çº¿ = çˆ¶èŠ‚ç‚¹å‚ç›´çº¿ - 1
- å³å­èŠ‚ç‚¹å‚ç›´çº¿ = çˆ¶èŠ‚ç‚¹å‚ç›´çº¿ + 1

**æ·±åº¦è®¡ç®—è§„åˆ™**ï¼š

- æ ¹èŠ‚ç‚¹æ·±åº¦ä¸º 0
- å­èŠ‚ç‚¹æ·±åº¦ = çˆ¶èŠ‚ç‚¹æ·±åº¦ + 1

### 2. å¤æ‚æ’åºè§„åˆ™

1. **ä¸»æ’åº**ï¼šæŒ‰å‚ç›´çº¿ä»å·¦åˆ°å³ï¼ˆå‡åºï¼‰
2. **æ¬¡æ’åº**ï¼šåŒå‚ç›´çº¿æŒ‰æ·±åº¦ä»ä¸Šåˆ°ä¸‹ï¼ˆå‡åºï¼‰
3. **ä¸‰çº§æ’åº**ï¼šåŒä½ç½®æŒ‰çˆ¶èŠ‚ç‚¹çš„éå†é¡ºåº

### 3. å…³é”®éš¾ç‚¹ï¼šåŒä½ç½®èŠ‚ç‚¹å¤„ç†

```javascript
// ç¤ºä¾‹ï¼šèŠ‚ç‚¹9å’Œ10éƒ½åœ¨ä½ç½®(1, 3)
// å› ä¸ºèŠ‚ç‚¹8åœ¨èŠ‚ç‚¹7ä¹‹åè¢«è®¿é—®ï¼Œæ‰€ä»¥10åœ¨9ä¹‹å
//     ...
//    /   \
//   7     8
//  /     /
// 9     10
```

### 4. ä¸‰ç§å®ç°æ–¹æ¡ˆå¯¹æ¯”

- **DFS + æ’åº**: ç®€å•ä½†æ•ˆç‡è¾ƒä½ï¼ŒO(n log n)
- **BFS + åˆ†ç»„**: æŒ‰å±‚å¤„ç†ï¼Œä¾¿äºç†è§£
- **DFS + ç›´æ¥æ„å»º**: æœ€ä¼˜è§£ï¼ŒO(n)

## ä»£ç å®ç°

```javascript
// èŠ‚ç‚¹ç±»å®šä¹‰
export class Node {
  constructor(val) {
    this.value = val
    this.left = null
    this.right = null
  }
}

/**
 * æ–¹æ¡ˆä¸€ï¼šDFS + åæ ‡æ”¶é›† + æ’åº
 * æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(n)
 */
export function traverse(root) {
  if (!root) return []

  const nodes = []

  // DFS æ”¶é›†æ‰€æœ‰èŠ‚ç‚¹çš„åæ ‡ä¿¡æ¯
  function dfs(node, col, row, parentCol) {
    if (!node) return

    // æ”¶é›†èŠ‚ç‚¹ä¿¡æ¯ï¼š[å€¼, å‚ç›´çº¿, æ·±åº¦, çˆ¶èŠ‚ç‚¹å‚ç›´çº¿]
    nodes.push([node.value, col, row, parentCol])

    // é€’å½’éå†å­æ ‘
    dfs(node.left, col - 1, row + 1, col)
    dfs(node.right, col + 1, row + 1, col)
  }

  dfs(root, 0, 0, 0)

  // å¤šçº§æ’åº
  nodes.sort((a, b) => {
    const [val1, col1, row1, parentCol1] = a
    const [val2, col2, row2, parentCol2] = b

    // 1. æŒ‰å‚ç›´çº¿æ’åº
    if (col1 !== col2) return col1 - col2

    // 2. åŒå‚ç›´çº¿æŒ‰æ·±åº¦æ’åº
    if (row1 !== row2) return row1 - row2

    // 3. åŒä½ç½®æŒ‰çˆ¶èŠ‚ç‚¹å‚ç›´çº¿æ’åºï¼ˆå·¦çˆ¶ä¼˜å…ˆï¼‰
    return parentCol1 - parentCol2
  })

  return nodes.map(([val]) => val)
}

/**
 * æ–¹æ¡ˆäºŒï¼šBFS + å±‚åºå¤„ç†
 * æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(n)
 */
export function traverseBFS(root) {
  if (!root) return []

  const columnMap = new Map()
  const queue = [[root, 0, 0]] // [èŠ‚ç‚¹, å‚ç›´çº¿, æ·±åº¦]

  while (queue.length > 0) {
    const [node, col, row] = queue.shift()

    // æŒ‰å‚ç›´çº¿åˆ†ç»„å­˜å‚¨
    if (!columnMap.has(col)) {
      columnMap.set(col, [])
    }
    columnMap.get(col).push([node.value, row])

    // æ·»åŠ å­èŠ‚ç‚¹åˆ°é˜Ÿåˆ—
    if (node.left) {
      queue.push([node.left, col - 1, row + 1])
    }
    if (node.right) {
      queue.push([node.right, col + 1, row + 1])
    }
  }

  // æŒ‰å‚ç›´çº¿æ’åºå¹¶æå–ç»“æœ
  const sortedColumns = Array.from(columnMap.keys()).sort((a, b) => a - b)
  const result = []

  for (const col of sortedColumns) {
    const nodes = columnMap.get(col)
    // åŒå‚ç›´çº¿å†…æŒ‰æ·±åº¦æ’åº
    nodes.sort((a, b) => a[1] - b[1])
    result.push(...nodes.map(([val]) => val))
  }

  return result
}

/**
 * æ–¹æ¡ˆä¸‰ï¼šDFS + ç›´æ¥æ„å»ºç»“æœï¼ˆæœ€ä¼˜è§£ï¼‰
 * æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(n)
 */
export function traverseOptimal(root) {
  if (!root) return []

  const columnMap = new Map()
  let minCol = 0,
    maxCol = 0

  // DFS éå†å¹¶ç›´æ¥æŒ‰é¡ºåºè®°å½•
  function dfs(node, col, row) {
    if (!node) return

    // æ›´æ–°åˆ—èŒƒå›´
    minCol = Math.min(minCol, col)
    maxCol = Math.max(maxCol, col)

    // åˆå§‹åŒ–è¯¥åˆ—çš„æ•°ç»„
    if (!columnMap.has(col)) {
      columnMap.set(col, [])
    }

    // æŒ‰æ·±åº¦å’Œè®¿é—®é¡ºåºæ’å…¥
    const column = columnMap.get(col)
    let inserted = false

    for (let i = 0; i < column.length; i++) {
      if (row < column[i][1]) {
        column.splice(i, 0, [node.value, row])
        inserted = true
        break
      } else if (row === column[i][1]) {
        // åŒæ·±åº¦èŠ‚ç‚¹ï¼ŒæŒ‰ DFS è®¿é—®é¡ºåºå†³å®š
        // è¿™é‡Œéœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œå®é™…ä¸ŠåŸ DFS é¡ºåºå°±æ˜¯æ­£ç¡®çš„
        column.splice(i + 1, 0, [node.value, row])
        inserted = true
        break
      }
    }

    if (!inserted) {
      column.push([node.value, row])
    }

    // å…ˆå·¦åå³çš„ DFS é¡ºåº
    dfs(node.left, col - 1, row + 1)
    dfs(node.right, col + 1, row + 1)
  }

  dfs(root, 0, 0)

  // æŒ‰åˆ—é¡ºåºæ”¶é›†ç»“æœ
  const result = []
  for (let col = minCol; col <= maxCol; col++) {
    if (columnMap.has(col)) {
      const nodes = columnMap.get(col)
      result.push(...nodes.map(([val]) => val))
    }
  }

  return result
}

/**
 * å¢å¼ºç‰ˆï¼šæ”¯æŒé‡å¤å€¼å¤„ç†
 */
export function traverseWithDuplicates(root) {
  if (!root) return []

  const result = []
  const columnGroups = new Map()

  function dfs(node, col, row, visitOrder) {
    if (!node) return visitOrder

    // è®°å½•èŠ‚ç‚¹ä¿¡æ¯
    if (!columnGroups.has(col)) {
      columnGroups.set(col, [])
    }

    columnGroups.get(col).push({
      value: node.value,
      row: row,
      order: visitOrder,
    })

    // é€’å½’éå†ï¼ˆå…ˆå·¦åå³ï¼‰
    visitOrder = dfs(node.left, col - 1, row + 1, visitOrder + 1)
    visitOrder = dfs(node.right, col + 1, row + 1, visitOrder + 1)

    return visitOrder
  }

  dfs(root, 0, 0, 0)

  // æ’åºå¹¶æ„å»ºç»“æœ
  const sortedColumns = Array.from(columnGroups.keys()).sort((a, b) => a - b)

  for (const col of sortedColumns) {
    const nodes = columnGroups.get(col)

    // å¤šçº§æ’åºï¼šè¡Œ -> è®¿é—®é¡ºåº
    nodes.sort((a, b) => {
      if (a.row !== b.row) return a.row - b.row
      return a.order - b.order
    })

    result.push(...nodes.map((node) => node.value))
  }

  return result
}
```

## ç®—æ³•åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**: O(n) - æœ€ä¼˜è§£åªéœ€ä¸€æ¬¡éå†ï¼ŒO(n log n) - éœ€è¦æ’åºçš„æ–¹æ¡ˆ
- **ç©ºé—´å¤æ‚åº¦**: O(n) - å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹ä¿¡æ¯å’Œé€’å½’æ ˆ
- **ç‰¹ç‚¹**: å¤šç»´æ’åºã€åæ ‡æ˜ å°„ã€æ ‘éå†

## å…³é”®æŠ€æœ¯ç‚¹

### 1. åæ ‡ç³»å»ºç«‹

```javascript
// å‚ç›´çº¿å’Œæ·±åº¦çš„è®¡ç®—
function dfs(node, col, row) {
  // å½“å‰èŠ‚ç‚¹ä½ç½®ï¼š(col, row)

  // å·¦å­æ ‘ï¼šå‚ç›´çº¿-1ï¼Œæ·±åº¦+1
  dfs(node.left, col - 1, row + 1)

  // å³å­æ ‘ï¼šå‚ç›´çº¿+1ï¼Œæ·±åº¦+1
  dfs(node.right, col + 1, row + 1)
}
```

### 2. å¤šçº§æ’åºç­–ç•¥

```javascript
// æ’åºä¼˜å…ˆçº§ï¼šå‚ç›´çº¿ > æ·±åº¦ > çˆ¶èŠ‚ç‚¹å…³ç³»
nodes.sort((a, b) => {
  if (a.col !== b.col) return a.col - b.col // å‚ç›´çº¿
  if (a.row !== b.row) return a.row - b.row // æ·±åº¦
  return a.parentCol - b.parentCol // çˆ¶èŠ‚ç‚¹å…³ç³»
})
```

### 3. åŒä½ç½®èŠ‚ç‚¹çš„é¡ºåºå¤„ç†

```javascript
// å…³é”®ï¼šDFS çš„è®¿é—®é¡ºåºå¤©ç„¶ç¬¦åˆè¦æ±‚
// å·¦å­æ ‘å…ˆè®¿é—®ï¼Œå³å­æ ‘åè®¿é—®
// åŒæ·±åº¦èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹å…³ç³»å†³å®šæœ€ç»ˆé¡ºåº

function handleSamePosition(nodes) {
  // å¯¹äºåŒä¸€ä½ç½®(col, row)çš„èŠ‚ç‚¹
  // æŒ‰ç…§ DFS ä¸­çˆ¶èŠ‚ç‚¹çš„è®¿é—®é¡ºåºæ’åˆ—
  return nodes.sort((a, b) => a.dfsOrder - b.dfsOrder)
}
```

### 4. å†…å­˜ä¼˜åŒ–æŠ€å·§

```javascript
// ä½¿ç”¨ Map ä»£æ›¿å¯¹è±¡ï¼Œæ”¯æŒæ•°å­—é”®
const columnMap = new Map()

// åŠ¨æ€èŒƒå›´è®¡ç®—ï¼Œå‡å°‘éå†
let minCol = Infinity,
  maxCol = -Infinity

// åŠæ—¶æ¸…ç†ä¸éœ€è¦çš„æ•°æ®
for (let col = minCol; col <= maxCol; col++) {
  if (columnMap.has(col)) {
    // å¤„ç†å®Œç«‹å³åˆ é™¤
    const nodes = columnMap.get(col)
    result.push(...nodes)
    columnMap.delete(col)
  }
}
```

### 5. å¸¸è§é™·é˜±å’Œå‘ç‚¹

- **æ’åºè§„åˆ™é”™è¯¯**: å¿˜è®°è€ƒè™‘çˆ¶èŠ‚ç‚¹å…³ç³»
- **åæ ‡è®¡ç®—é”™è¯¯**: å·¦å³å­æ ‘æ–¹å‘æå
- **åŒä½ç½®å¤„ç†**: æ²¡æœ‰æ­£ç¡®å¤„ç†åŒæ·±åº¦åŒåˆ—çš„èŠ‚ç‚¹
- **è¾¹ç•Œæƒ…å†µ**: ç©ºæ ‘ã€å•èŠ‚ç‚¹ã€é“¾å¼æ ‘
- **å†…å­˜æº¢å‡º**: å¤§æ ‘é€’å½’æ·±åº¦è¿‡æ·±

## ä½¿ç”¨ç¤ºä¾‹

```javascript
// æ„å»ºæµ‹è¯•äºŒå‰æ ‘
//       1
//      / \
//     2   3
//    / \   \
//   4   5   6
//  /         \
// 7           8

const root = new Node(1)
root.left = new Node(2)
root.right = new Node(3)
root.left.left = new Node(4)
root.left.right = new Node(5)
root.right.right = new Node(6)
root.left.left.left = new Node(7)
root.right.right.right = new Node(8)

// å‚ç›´éå†
console.log(traverse(root))
// è¾“å‡º: [7, 4, 2, 1, 5, 3, 6, 8]

// åˆ†æéå†è¿‡ç¨‹ï¼š
// å‚ç›´çº¿ -2: [7] (æ·±åº¦3)
// å‚ç›´çº¿ -1: [4] (æ·±åº¦2)
// å‚ç›´çº¿  0: [2, 1, 5] (æ·±åº¦1,0,2)
// å‚ç›´çº¿  1: [3] (æ·±åº¦1)
// å‚ç›´çº¿  2: [6] (æ·±åº¦2)
// å‚ç›´çº¿  3: [8] (æ·±åº¦3)

// å¤æ‚ç¤ºä¾‹ï¼šåŒä½ç½®å¤šèŠ‚ç‚¹
//       1
//      / \
//     2   3
//    /|   |\
//   4 5   6 7
//    X     X
//   8 9   10 11

const complexRoot = new Node(1)
complexRoot.left = new Node(2)
complexRoot.right = new Node(3)
complexRoot.left.left = new Node(4)
complexRoot.left.right = new Node(5)
complexRoot.right.left = new Node(6)
complexRoot.right.right = new Node(7)
complexRoot.left.right.left = new Node(8)
complexRoot.left.right.right = new Node(9)
complexRoot.right.left.left = new Node(10)
complexRoot.right.left.right = new Node(11)

console.log(traverse(complexRoot))
// éœ€è¦ç‰¹åˆ«æ³¨æ„8,9,10,11åœ¨å‚ç›´çº¿0ä¸Šçš„æ’åº

// è¾¹ç•Œæƒ…å†µæµ‹è¯•
console.log(traverse(null)) // []
console.log(traverse(new Node(42))) // [42]

// é“¾å¼æ ‘æµ‹è¯•
const chainRoot = new Node(1)
let current = chainRoot
for (let i = 2; i <= 5; i++) {
  current.left = new Node(i)
  current = current.left
}
console.log(traverse(chainRoot)) // [5, 4, 3, 2, 1]

// æ€§èƒ½æµ‹è¯•
function buildPerfectTree(depth) {
  if (depth === 0) return null

  const root = new Node(depth)
  root.left = buildPerfectTree(depth - 1)
  root.right = buildPerfectTree(depth - 1)
  return root
}

const perfTree = buildPerfectTree(10)
console.time('traverse')
const result = traverse(perfTree)
console.timeEnd('traverse')
console.log(`Traversed ${result.length} nodes`)

// éªŒè¯ç»“æœæ­£ç¡®æ€§
function validateResult(root, result) {
  const allNodes = []

  function collectAll(node) {
    if (!node) return
    allNodes.push(node.value)
    collectAll(node.left)
    collectAll(node.right)
  }

  collectAll(root)

  // æ£€æŸ¥èŠ‚ç‚¹æ•°é‡
  if (allNodes.length !== result.length) {
    return false
  }

  // æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«åŒ…å«
  const resultSet = new Set(result)
  return allNodes.every((val) => resultSet.has(val))
}

console.log('Result valid:', validateResult(root, traverse(root)))
```

## è®°å¿†è¦ç‚¹

### æ ¸å¿ƒè®°å¿†ç‚¹

1. **åæ ‡ç³»å»ºç«‹** - å‚ç›´çº¿(å·¦-1å³+1)å’Œæ·±åº¦(å±‚+1)
2. **ä¸‰çº§æ’åº** - å‚ç›´çº¿ > æ·±åº¦ > çˆ¶èŠ‚ç‚¹å…³ç³»
3. **DFSé¡ºåº** - å…ˆå·¦åå³çš„è®¿é—®é¡ºåºæ˜¯å…³é”®
4. **åŒä½ç½®å¤„ç†** - çˆ¶èŠ‚ç‚¹çš„è®¿é—®é¡ºåºå†³å®šå­èŠ‚ç‚¹é¡ºåº
5. **èŒƒå›´ä¼˜åŒ–** - åŠ¨æ€è®¡ç®—å‚ç›´çº¿èŒƒå›´é¿å…æ— æ•ˆéå†

### ç®—æ³•æµç¨‹è®°å¿†

```javascript
// 1. DFSéå†æ”¶é›†åæ ‡ä¿¡æ¯
// 2. å¤šçº§æ’åº(å‚ç›´çº¿->æ·±åº¦->çˆ¶èŠ‚ç‚¹)
// 3. æŒ‰æ’åºç»“æœæå–å€¼
// 4. è¿”å›æœ€ç»ˆæ•°ç»„
```

## æ‰©å±•æ€è€ƒ

### 1. æ”¯æŒè‡ªå®šä¹‰æ’åºè§„åˆ™

```javascript
function customTraverse(root, compareFn) {
  const nodes = []

  function dfs(node, col, row, parent) {
    if (!node) return

    nodes.push({
      value: node.value,
      col,
      row,
      parent,
      node: node,
    })

    dfs(node.left, col - 1, row + 1, node)
    dfs(node.right, col + 1, row + 1, node)
  }

  dfs(root, 0, 0, null)

  // ä½¿ç”¨è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°
  nodes.sort(compareFn)

  return nodes.map((n) => n.value)
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šæŒ‰å€¼æ’åº
const byValue = (a, b) => {
  if (a.col !== b.col) return a.col - b.col
  if (a.row !== b.row) return a.row - b.row
  return a.value - b.value // åŒä½ç½®æŒ‰å€¼æ’åº
}
```

### 2. æ”¯æŒæ°´å¹³éå†

```javascript
function horizontalTraverse(root) {
  if (!root) return []

  const rowMap = new Map()

  function dfs(node, col, row) {
    if (!node) return

    if (!rowMap.has(row)) {
      rowMap.set(row, [])
    }

    rowMap.get(row).push([node.value, col])

    dfs(node.left, col - 1, row + 1)
    dfs(node.right, col + 1, row + 1)
  }

  dfs(root, 0, 0)

  const result = []
  const sortedRows = Array.from(rowMap.keys()).sort((a, b) => a - b)

  for (const row of sortedRows) {
    const nodes = rowMap.get(row)
    nodes.sort((a, b) => a[1] - b[1]) // æŒ‰åˆ—æ’åº
    result.push(...nodes.map(([val]) => val))
  }

  return result
}
```

### 3. æ”¯æŒå¯¹è§’çº¿éå†

```javascript
function diagonalTraverse(root) {
  if (!root) return []

  const diagonalMap = new Map()

  function dfs(node, col, row) {
    if (!node) return

    // å¯¹è§’çº¿ç´¢å¼• = col + row
    const diagonal = col + row

    if (!diagonalMap.has(diagonal)) {
      diagonalMap.set(diagonal, [])
    }

    diagonalMap.get(diagonal).push({
      value: node.value,
      col,
      row,
    })

    dfs(node.left, col - 1, row + 1)
    dfs(node.right, col + 1, row + 1)
  }

  dfs(root, 0, 0)

  const result = []
  const sortedDiagonals = Array.from(diagonalMap.keys()).sort((a, b) => a - b)

  for (const diag of sortedDiagonals) {
    const nodes = diagonalMap.get(diag)
    // åŒå¯¹è§’çº¿æŒ‰åˆ—æ’åº
    nodes.sort((a, b) => a.col - b.col)
    result.push(...nodes.map((n) => n.value))
  }

  return result
}
```

### 4. æ”¯æŒå±‚æ¬¡ç»Ÿè®¡

```javascript
function traverseWithStats(root) {
  if (!root) return { result: [], stats: {} }

  const nodes = []
  const stats = {
    totalNodes: 0,
    maxDepth: 0,
    columnRange: [0, 0],
    nodesPerColumn: new Map(),
    nodesPerRow: new Map(),
  }

  function dfs(node, col, row) {
    if (!node) return

    stats.totalNodes++
    stats.maxDepth = Math.max(stats.maxDepth, row)
    stats.columnRange[0] = Math.min(stats.columnRange[0], col)
    stats.columnRange[1] = Math.max(stats.columnRange[1], col)

    // ç»Ÿè®¡æ¯åˆ—èŠ‚ç‚¹æ•°
    stats.nodesPerColumn.set(col, (stats.nodesPerColumn.get(col) || 0) + 1)
    stats.nodesPerRow.set(row, (stats.nodesPerRow.get(row) || 0) + 1)

    nodes.push([node.value, col, row])

    dfs(node.left, col - 1, row + 1)
    dfs(node.right, col + 1, row + 1)
  }

  dfs(root, 0, 0)

  nodes.sort((a, b) => {
    if (a[1] !== b[1]) return a[1] - b[1]
    return a[2] - b[2]
  })

  return {
    result: nodes.map(([val]) => val),
    stats: stats,
  }
}
```

### 5. æ”¯æŒå¯è§†åŒ–è¾“å‡º

```javascript
function visualizeTraversal(root) {
  if (!root) return ''

  const grid = new Map()
  let minCol = 0,
    maxCol = 0,
    maxRow = 0

  function dfs(node, col, row) {
    if (!node) return

    minCol = Math.min(minCol, col)
    maxCol = Math.max(maxCol, col)
    maxRow = Math.max(maxRow, row)

    if (!grid.has(row)) {
      grid.set(row, new Map())
    }
    grid.get(row).set(col, node.value)

    dfs(node.left, col - 1, row + 1)
    dfs(node.right, col + 1, row + 1)
  }

  dfs(root, 0, 0)

  // æ„å»ºå¯è§†åŒ–å­—ç¬¦ä¸²
  let result = ''
  for (let row = 0; row <= maxRow; row++) {
    let line = ''
    for (let col = minCol; col <= maxCol; col++) {
      if (grid.has(row) && grid.get(row).has(col)) {
        line += grid.get(row).get(col).toString().padStart(3)
      } else {
        line += '   '
      }
    }
    result += line.trim() + '\n'
  }

  return result
}

// ä½¿ç”¨ç¤ºä¾‹
console.log(visualizeTraversal(root))
//   2
// 4   1   3
//7     5     6
//               8
```

## å¤ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£å‚ç›´éå†çš„åæ ‡ç³»ç»Ÿå’Œæ’åºè§„åˆ™
- [ ] æŒæ¡DFSéå†å’Œåæ ‡è®¡ç®—çš„æ–¹æ³•
- [ ] ç†Ÿç»ƒå¤„ç†åŒä½ç½®å¤šèŠ‚ç‚¹çš„æ’åºé—®é¢˜
- [ ] ç†è§£ä¸‰çº§æ’åºçš„ä¼˜å…ˆçº§å’Œå®ç°
- [ ] èƒ½å¤Ÿå¤„ç†å„ç§ç‰¹æ®Šæ ‘ç»“æ„çš„éå†
- [ ] æŒæ¡ä¸åŒç®—æ³•æ–¹æ¡ˆçš„æ—¶ç©ºå¤æ‚åº¦
- [ ] äº†è§£å†…å­˜ä¼˜åŒ–å’Œæ€§èƒ½ä¼˜åŒ–æŠ€å·§
- [ ] ç†Ÿæ‚‰äºŒå‰æ ‘éå†çš„å„ç§å˜ä½“
- [ ] èƒ½å¤Ÿæ‰©å±•åˆ°å…¶ä»–æ–¹å‘çš„éå†ç®—æ³•
- [ ] ç†è§£åœ¨å®é™…åº”ç”¨ä¸­çš„ä½¿ç”¨åœºæ™¯
      }
      }
      /\*\*

* @param {Node} root
* @returns {number[]}
  \*/
  export default function traverse(root) {
  if (root === null) return []

const tramap = {}
const result = []

function dfs(root, line, deep, parentLine) {
if (root === null) return

    const value = root.value
    if (!Object.hasOwn(tramap, line)) {
      tramap[line] = []
    }

    tramap[line].push({ value, deep, parentLine })

    dfs(root.left, line + 1, deep + 1, line)
    dfs(root.right, line - 1, deep + 1, line)

}

dfs(root, 0, 0, 0)

Object.keys(tramap)
.map(Number)
.sort((a, b) => b - a)
.forEach((key) => {
tramap[key]
.sort((a, b) => a.deep - b.deep || b.parentLine - a.parentLine)
.forEach((node) => {
result.push(node.value)
})
})

return result
}

```

## ğŸ§  ç®—æ³•åˆ†æ

### æ ¸å¿ƒæ€è·¯

1. **DFS éå†**ï¼šæ·±åº¦ä¼˜å…ˆéå†æ”¶é›†æ‰€æœ‰èŠ‚ç‚¹ä¿¡æ¯
2. **åæ ‡è®°å½•**ï¼šä¸ºæ¯ä¸ªèŠ‚ç‚¹è®°å½•å‚ç›´çº¿ä½ç½®ã€æ·±åº¦ã€çˆ¶èŠ‚ç‚¹ä½ç½®
3. **åˆ†ç»„å­˜å‚¨**ï¼šæŒ‰å‚ç›´çº¿ä½ç½®åˆ†ç»„å­˜å‚¨èŠ‚ç‚¹
4. **å¤šçº§æ’åº**ï¼šæŒ‰å‚ç›´çº¿ã€æ·±åº¦ã€çˆ¶èŠ‚ç‚¹å…³ç³»æ’åº

### ç®—æ³•æ­¥éª¤

```

1. DFS(root, line=0, depth=0, parentLine=0)
2. å·¦å­æ ‘ï¼šDFS(left, line+1, depth+1, line)
3. å³å­æ ‘ï¼šDFS(right, line-1, depth+1, line)
4. æŒ‰å‚ç›´çº¿åˆ†ç»„ï¼štramap[line] = [{value, deep, parentLine}]
5. æ’åºè¾“å‡º

````

### æ—¶é—´å¤æ‚åº¦

- **O(n log n)**ï¼šéå† O(n) + æ’åº O(n log n)

### ç©ºé—´å¤æ‚åº¦

- **O(n)**ï¼šå­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹ä¿¡æ¯çš„æ˜ å°„è¡¨

## ğŸ” å…³é”®æŠ€æœ¯ç‚¹

### 1. åæ ‡ç³»è®¾è®¡

```javascript
// å·¦å­æ ‘ï¼šline + 1ï¼Œå³å­æ ‘ï¼šline - 1
dfs(root.left, line + 1, deep + 1, line)
dfs(root.right, line - 1, deep + 1, line)
````

### 2. èŠ‚ç‚¹ä¿¡æ¯è®°å½•

```javascript
tramap[line].push({ value, deep, parentLine })
// value: èŠ‚ç‚¹å€¼
// deep: æ·±åº¦ï¼ˆè·ç¦»æ ¹èŠ‚ç‚¹çš„è·ç¦»ï¼‰
// parentLine: çˆ¶èŠ‚ç‚¹çš„å‚ç›´çº¿ä½ç½®
```

### 3. å¤šçº§æ’åºç­–ç•¥

```javascript
// 1. å‚ç›´çº¿æ’åºï¼šä»å³åˆ°å·¦ï¼ˆb - aï¼‰
.sort((a, b) => b - a)

// 2. åŒä¸€å‚ç›´çº¿å†…æ’åº
.sort((a, b) => a.deep - b.deep || b.parentLine - a.parentLine)
// ä¼˜å…ˆæŒ‰æ·±åº¦å‡åºï¼Œå†æŒ‰çˆ¶èŠ‚ç‚¹ä½ç½®é™åº
```

### 4. å¯¹è±¡å±æ€§æ£€æŸ¥

```javascript
if (!Object.hasOwn(tramap, line)) {
  tramap[line] = []
}
// ä½¿ç”¨ Object.hasOwn æ›¿ä»£ hasOwnProperty
```

## ğŸ§ª ä½¿ç”¨ç¤ºä¾‹

### ç®€å•äºŒå‰æ ‘

```javascript
//       1
//      / \
//     2   3
//    / \
//   4   5

const root = new Node(1)
root.left = new Node(2)
root.right = new Node(3)
root.left.left = new Node(4)
root.left.right = new Node(5)

traverse(root) // [4, 2, 1, 5, 3]
```

### å¤æ‚äº¤å‰æ ‘

```javascript
//       1
//      / \
//     2   3
//    /   / \
//   4   5   6
//  /     \
// 7       8

// å‚ç›´çº¿åˆ†ç»„ï¼š
// line +3: [7]
// line +2: [4]
// line +1: [2]
// line +0: [1, 5]
// line -1: [3, 8]
// line -2: [6]

// ç»“æœï¼š[7, 4, 2, 1, 5, 3, 8, 6]
```

### åŒæ·±åº¦èŠ‚ç‚¹æ’åº

```javascript
//       1
//      / \
//     2   3
//    / \ / \
//   4  5 6  7

// åœ¨ line 0 ä¸Šï¼š
// æ·±åº¦ 2 çš„èŠ‚ç‚¹ 5 å’Œ 6
// 5 çš„çˆ¶èŠ‚ç‚¹ 2 åœ¨ line +1
// 6 çš„çˆ¶èŠ‚ç‚¹ 3 åœ¨ line -1
// ç”±äº +1 > -1ï¼Œæ‰€ä»¥ 5 åœ¨ 6 å‰é¢
```

## ğŸ’¡ å…³é”®è®°å¿†ç‚¹

1. **åæ ‡è§„åˆ™**ï¼šå·¦å­æ ‘ +1ï¼Œå³å­æ ‘ -1
2. **ä¸‰ä¸ªä¿¡æ¯**ï¼šèŠ‚ç‚¹å€¼ã€æ·±åº¦ã€çˆ¶èŠ‚ç‚¹å‚ç›´çº¿ä½ç½®
3. **æ’åºé¡ºåº**ï¼šå‚ç›´çº¿ï¼ˆé™åºï¼‰â†’ æ·±åº¦ï¼ˆå‡åºï¼‰â†’ çˆ¶èŠ‚ç‚¹ä½ç½®ï¼ˆé™åºï¼‰
4. **DFS éå†**ï¼šé€’å½’æ”¶é›†æ‰€æœ‰èŠ‚ç‚¹çš„ä½ç½®ä¿¡æ¯
5. **åˆ†ç»„å¤„ç†**ï¼šæŒ‰å‚ç›´çº¿åˆ†ç»„ï¼Œç»„å†…æŒ‰è§„åˆ™æ’åº
6. **çˆ¶èŠ‚ç‚¹ç»§æ‰¿**ï¼šåŒæ·±åº¦èŠ‚ç‚¹çš„é¡ºåºç»§æ‰¿è‡ªçˆ¶èŠ‚ç‚¹å…³ç³»

## ğŸ¤” æ‰©å±•æ€è€ƒ

### å…¶ä»–éå†æ–¹å¼

- **BFS å‚ç›´éå†**ï¼šä½¿ç”¨é˜Ÿåˆ—ï¼ŒæŒ‰å±‚çº§æ”¶é›†
- **Morris éå†**ï¼šO(1) ç©ºé—´å¤æ‚åº¦çš„éå†æ–¹å¼
- **çº¿æ®µæ ‘ä¼˜åŒ–**ï¼šå¯¹äºæå¤§çš„åæ ‡èŒƒå›´

### å®é™…åº”ç”¨

- **GUI å¸ƒå±€**ï¼šå‚ç›´å¯¹é½ç»„ä»¶
- **æ•°æ®å¯è§†åŒ–**ï¼šæ ‘å½¢å›¾çš„åˆ—å¯¹é½
- **æ–‡æ¡£ç»“æ„**ï¼šæŒ‰åˆ—æ•´ç†å†…å®¹
- **æ¸¸æˆå¼€å‘**ï¼šæ£‹ç›˜æˆ–ç½‘æ ¼å¸ƒå±€

### ç®—æ³•å˜ç§

- **æ°´å¹³éå†**ï¼šæŒ‰æ°´å¹³çº¿åˆ†ç»„
- **å¯¹è§’çº¿éå†**ï¼šæŒ‰å¯¹è§’çº¿åˆ†ç»„
- **èºæ—‹éå†**ï¼šèºæ—‹å¼è®¿é—®èŠ‚ç‚¹

### ä¼˜åŒ–æ–¹å‘

- **æ‡’æ’åº**ï¼šåªåœ¨éœ€è¦æ—¶æ’åºç‰¹å®šå‚ç›´çº¿
- **æµå¼å¤„ç†**ï¼šè¾¹éå†è¾¹è¾“å‡ºï¼Œå‡å°‘å†…å­˜å ç”¨
- **å¹¶è¡Œå¤„ç†**ï¼šå¤šçº¿ç¨‹å¤„ç†ä¸åŒå‚ç›´çº¿

## ğŸ“ å¤ä¹ è¦ç‚¹

- [ ] ç†è§£å‚ç›´éå†çš„åæ ‡ç³»ç»Ÿ
- [ ] æŒæ¡ DFS æ”¶é›†èŠ‚ç‚¹ä¿¡æ¯çš„æ–¹æ³•
- [ ] ç†Ÿæ‚‰å¤šçº§æ’åºçš„å®ç°
- [ ] ç†è§£çˆ¶èŠ‚ç‚¹å…³ç³»çš„ç»§æ‰¿è§„åˆ™
- [ ] èƒ½å¤Ÿå¤„ç†å¤æ‚çš„äº¤å‰äºŒå‰æ ‘
- [ ] æŒæ¡ Object.hasOwn çš„ç”¨æ³•
