# Day 04 复习文档

## 题目描述

实现一个 `sum()` 函数，支持**柯里化累加**功能：

- 支持连续调用：`sum(1)(2)(3) == 6`
- 支持空调用：`sum(1)()(2) == 3`
- 默认值为 0：`sum() == 0`
- 使用 `==` 比较（触发类型转换）

本题考查 **函数柯里化**、**Symbol.toPrimitive** 和 **闭包机制** 的综合运用。

## 核心知识点

### 1. 函数柯里化 (Currying)

- **定义**: 将多参数函数转换为一系列单参数函数的技术
- **特点**: 每次调用返回一个新函数，支持部分应用
- **优势**: 代码复用、参数预设、函数组合
- **实现**: 通过闭包保持参数状态

### 2. Symbol.toPrimitive 类型转换

- **作用**: 控制对象到原始值的转换行为
- **触发场景**: `==` 比较、数学运算、字符串拼接
- **优先级**: 最高，优先于 `valueOf()` 和 `toString()`
- **参数**: hint 可为 'number'、'string' 或 'default'

### 3. 闭包状态管理

- **机制**: 内部函数访问外部函数的变量
- **持久化**: 变量在函数执行完后依然存在
- **应用**: 保持累加状态，实现状态封装

## 代码实现

```javascript
export default function sum(v = 0) {
  // 返回包装函数，支持继续调用和累加
  function wrapper(newArg = 0) {
    return sum(v + newArg) // 递归调用，传入累加后的值
  }

  // 定义类型转换行为，返回当前累加值
  wrapper[Symbol.toPrimitive] = () => v

  return wrapper
}
```

## 算法分析

- **时间复杂度**: O(n) - n 为调用次数
- **空间复杂度**: O(n) - 递归调用栈的深度
- **特点**: 每次调用创建新函数，保持不可变性

## 关键技术点

### 1. 递归累加机制

```javascript
// 每次调用的执行流程
sum(1)(
  // v=1, 返回 wrapper 函数
  2,
)(
  // v=1+2=3, 返回新的 wrapper 函数
  3,
) == // v=3+3=6, 返回新的 wrapper 函数
  6 // 触发 Symbol.toPrimitive，返回 6
```

### 2. Symbol.toPrimitive 的工作原理

```javascript
// 当函数用于比较或运算时触发
const result = sum(1)(2)(3)
console.log(result == 6) // true，触发 toPrimitive
console.log(result + 0) // 6，触发 toPrimitive
console.log(String(result)) // "6"，触发 toPrimitive
console.log(Number(result)) // 6，触发 toPrimitive

// 直接调用
console.log(result[Symbol.toPrimitive]()) // 6
```

### 3. 闭包变量的生命周期

```javascript
function sum(v = 0) {
  // v 被闭包捕获，在 wrapper 生命周期内持续存在
  function wrapper(newArg = 0) {
    return sum(v + newArg) // v 在这里依然可访问
  }

  wrapper[Symbol.toPrimitive] = () => v // v 在这里也可访问
  return wrapper
}
```

### 4. 默认参数的巧妙运用

```javascript
// 支持空调用的关键
function wrapper(newArg = 0) {
  return sum(v + newArg) // newArg 默认为 0
}

// 使用效果
sum(1)() // 等价于 sum(1)(0)
sum(1)()(2) // 等价于 sum(1)(0)(2)
```

### 5. 常见陷阱和坑点

- **严格相等**: `===` 不会触发类型转换，需要使用 `==`
- **函数引用**: 每次调用返回新函数，引用不相等
- **内存泄漏**: 深度嵌套调用可能产生大量闭包
- **类型转换**: 必须正确实现 Symbol.toPrimitive

## 使用示例

```javascript
// 基本累加
console.log(sum(1)(2)(3) == 6) // true
console.log(sum(5)(10) == 15) // true

// 空调用处理
console.log(sum(1)()(2) == 3) // true
console.log(sum()(5) == 5) // true
console.log(sum()() == 0) // true

// 默认值
console.log(sum() == 0) // true
console.log(sum(0) == 0) // true

// 负数处理
console.log(sum(-1)(2)(-3) == -2) // true
console.log(sum(10)(-5) == 5) // true

// 小数处理
console.log(sum(1.5)(2.3) == 3.8) // true
console.log(sum(0.1)(0.2) == 0.3) // false (浮点精度问题)

// 多次连续调用
const chain = sum(1)(2)(3)(4)(5)
console.log(chain == 15) // true
console.log(chain(10) == 25) // true

// 中间结果保存
const intermediate = sum(10)(20)
console.log(intermediate == 30) // true
console.log(intermediate(5) == 35) // true
console.log(intermediate == 30) // true (不影响原值)

// 函数特性验证
const fn = sum(5)
console.log(typeof fn) // "function"
console.log(fn instanceof Function) // true
console.log(fn.length) // 1 (参数个数)
```

## 记忆要点

### 核心记忆点

1. **递归结构** - 每次调用返回新的 sum 函数
2. **闭包保存状态** - v 参数在闭包中累积
3. **Symbol.toPrimitive** - 控制类型转换返回累加值
4. **默认参数** - newArg = 0 处理空调用
5. **不可变性** - 每次调用创建新函数，不修改原函数

### 类型转换记忆

```javascript
// == 运算符的转换优先级
// 1. Symbol.toPrimitive (hint: 'default')
// 2. valueOf()
// 3. toString()
```

## 扩展思考

### 1. 支持多参数版本

```javascript
function sum(...args) {
  const total = args.reduce((acc, val) => acc + (val || 0), 0)

  function wrapper(...newArgs) {
    return sum(total, ...newArgs)
  }

  wrapper[Symbol.toPrimitive] = () => total
  return wrapper
}

// 使用示例
console.log(sum(1, 2, 3)(4, 5) == 15) // true
```

### 2. 支持其他运算符

```javascript
function calculator(initial = 0) {
  function wrapper(value = 0) {
    return calculator(initial + value)
  }

  // 支持多种转换
  wrapper[Symbol.toPrimitive] = (hint) => {
    switch (hint) {
      case 'number':
        return initial
      case 'string':
        return String(initial)
      default:
        return initial
    }
  }

  // 支持 valueOf 和 toString
  wrapper.valueOf = () => initial
  wrapper.toString = () => String(initial)

  // 扩展运算方法
  wrapper.add = (value) => calculator(initial + value)
  wrapper.subtract = (value) => calculator(initial - value)
  wrapper.multiply = (value) => calculator(initial * value)
  wrapper.divide = (value) => calculator(initial / value)

  return wrapper
}

// 使用示例
console.log(calculator(10).add(5).multiply(2) == 30) // true
```

### 3. 链式调用终结器

```javascript
function sum(v = 0) {
  function wrapper(newArg) {
    // 如果没有参数且不是第一次调用，返回结果
    if (arguments.length === 0 && v !== 0) {
      return v
    }

    return sum(v + (newArg || 0))
  }

  wrapper[Symbol.toPrimitive] = () => v
  wrapper.end = () => v // 显式终结方法

  return wrapper
}

// 使用示例
console.log(sum(1)(2)(3)()) // 6
console.log(sum(1)(2)(3).end()) // 6
```

### 4. 支持异步累加

```javascript
function asyncSum(v = 0) {
  function wrapper(newArg = 0) {
    if (newArg instanceof Promise) {
      return newArg.then((val) => asyncSum(v + val))
    }
    return asyncSum(v + newArg)
  }

  wrapper[Symbol.toPrimitive] = () => v
  wrapper.then = (onResolve) => Promise.resolve(v).then(onResolve)

  return wrapper
}

// 使用示例
asyncSum(1)(Promise.resolve(2))(3).then((result) => {
  console.log(result) // 6
})
```

### 5. 内存优化版本

```javascript
// 使用 WeakMap 缓存结果，避免重复计算
const cache = new WeakMap()

function optimizedSum(v = 0) {
  // 检查缓存
  if (cache.has(optimizedSum) && cache.get(optimizedSum)[v]) {
    return cache.get(optimizedSum)[v]
  }

  function wrapper(newArg = 0) {
    return optimizedSum(v + newArg)
  }

  wrapper[Symbol.toPrimitive] = () => v

  // 缓存结果
  if (!cache.has(optimizedSum)) {
    cache.set(optimizedSum, {})
  }
  cache.get(optimizedSum)[v] = wrapper

  return wrapper
}
```

### 6. 类型安全版本

```javascript
function typedSum(v = 0) {
  // 类型检查
  if (typeof v !== 'number' || isNaN(v)) {
    throw new TypeError('参数必须是有效数字')
  }

  function wrapper(newArg = 0) {
    if (typeof newArg !== 'number' || isNaN(newArg)) {
      throw new TypeError('参数必须是有效数字')
    }
    return typedSum(v + newArg)
  }

  wrapper[Symbol.toPrimitive] = () => v

  // 添加类型信息
  wrapper.getType = () => 'number'
  wrapper.getValue = () => v
  wrapper.isValid = () => !isNaN(v) && isFinite(v)

  return wrapper
}
```

## 复习检查清单

- [ ] 理解柯里化的基本概念和实现原理
- [ ] 掌握 Symbol.toPrimitive 的作用和使用场景
- [ ] 熟练运用闭包进行状态管理
- [ ] 理解递归函数的设计模式
- [ ] 掌握默认参数处理空调用的技巧
- [ ] 了解类型转换的优先级和机制
- [ ] 能够扩展支持多参数和其他运算
- [ ] 理解内存管理和性能优化要点
- [ ] 掌握错误处理和类型检查方法
- [ ] 熟悉实际应用场景和最佳实践

3. **类型转换**：通过 `Symbol.toPrimitive` 实现值的获取

### 执行流程

```
sum(1) → wrapper { v: 1, Symbol.toPrimitive: () => 1 }
       ↓
   wrapper(2) → sum(1+2) → wrapper { v: 3, Symbol.toPrimitive: () => 3 }
                          ↓
                      wrapper(3) → sum(3+3) → wrapper { v: 6, Symbol.toPrimitive: () => 6 }
                                             ↓
                                         == 6 → 调用 Symbol.toPrimitive → 返回 6
```

## 🔍 关键技术点

### 1. 默认参数处理

```javascript
function sum(v = 0) {
  // 主函数默认值
  function wrapper(newArg = 0) {
    // 包装函数默认值
    return sum(v + newArg)
  }
}
```

### 2. Symbol.toPrimitive 的作用

```javascript
wrapper[Symbol.toPrimitive] = () => v

// 当执行 wrapper == 6 时：
// 1. JavaScript 引擎检测到需要类型转换
// 2. 调用 wrapper[Symbol.toPrimitive]()
// 3. 返回 v 的值进行比较
```

### 3. 闭包保持状态

```javascript
function sum(v = 0) {
  // v 被闭包捕获
  function wrapper(newArg = 0) {
    return sum(v + newArg) // 访问外层的 v
  }
  // wrapper 能访问 v，即使 sum 执行完毕
}
```

### 4. 递归调用模式

```javascript
sum(1) → sum(1+2) → sum(3+3) → ...
//每次都创建新的函数实例，保持独立的状态
```

## 🧪 使用示例

### 基础用法

```javascript
const sum1 = sum(1)
console.log(sum1 == 1) // true，触发 Symbol.toPrimitive

const _sum = sum()
console.log(_sum == 0) // true，默认值 0
```

### 连续调用

```javascript
console.log(sum(1)(2)(3) == 6) // true
console.log(sum(5)(-1)(2) == 6) // true
```

### 空参数调用

```javascript
console.log(sum(1)(2)() == 3) // true，() 相当于 (0)
console.log(sum(1)()(2) == 3) // true，中间的 () 不影响结果
```

### 分步调用

```javascript
const step1 = sum(1) // { v: 1 }
const step2 = step1(2) // { v: 3 }
const step3 = step2(3) // { v: 6 }
console.log(step3 == 6) // true
```

## 💡 关键记忆点

1. **递归模式**：`sum(v) → wrapper → sum(v + newArg)`
2. **闭包状态**：每个 wrapper 都保持自己的 v 值
3. **类型转换**：`Symbol.toPrimitive` 必须返回函数
4. **默认参数**：两层都需要设置默认值 0
5. **比较操作**：`==` 会触发类型转换，`===` 不会

## 🤔 扩展思考

### 与其他实现方式对比

```javascript
// 方式1：使用 valueOf()
wrapper.valueOf = () => v

// 方式2：使用 toString()
wrapper.toString = () => String(v)

// 方式3：使用 Symbol.toPrimitive（推荐）
wrapper[Symbol.toPrimitive] = () => v
```

### 类型转换优先级

1. `Symbol.toPrimitive`（最高优先级）
2. `valueOf()`
3. `toString()`

### 应用场景

- **链式计算**：jQuery 风格的链式调用
- **函数式编程**：柯里化函数的实际应用
- **DSL 设计**：领域特定语言的语法设计

## 📝 复习要点

- [ ] 理解柯里化函数的递归结构
- [ ] 掌握 Symbol.toPrimitive 的使用方法
- [ ] 熟悉闭包在状态保持中的作用
- [ ] 理解 `==` 和 `===` 的区别
- [ ] 能够解释每次调用的执行流程
- [ ] 掌握默认参数在递归中的处理
